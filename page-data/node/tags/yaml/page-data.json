{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/yaml",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2021-05-20T00:00:00.000Z","id":"95f5c8b2-77be-5e34-b420-2968ceb655ee","slug":"/blog/2021/05/20/configure-plugins-with-jcasc/","strippedHtml":"This blog post is for anyone interested to know how to configure a plugin using the Jenkins Configuration as a Code (JCasC) plugin, more specifically, this blog will guide you to get the YAML equivalent of a plugin’s configuration and use it to do some changes to the plugin without using the Jenkins UI.\n\nIf you’re a beginner at JCasC and want to learn more about it, you can head over to the following resources to understand JCasC better:\n\nJCasC Documentation\n\nOverview of JCasC (Video Presentation)\n\nManage JCasC (DevOps World 2018)\n\nConfiguring your first plugin using JCasC (Video Demo)\n\nOverview\n\nSo, these are the steps we will be following to achieve our aim:\n\nBrief Introduction to jenkins.yaml file\n\nConfigure the plugin on the UI\n\nDownload the Configuration\n\nUpdate JCasC file locally\n\nLoad the jenkins.yaml file on the Jenkins server\n\nVerify the changes on the UI\n\nBrief Introduction to jenkins.yaml file\n\nThe jenkins.yaml file contains the configuration of the Jenkins instance in YAML format.\nThe JCasC plugin refers to this file to configure the Jenkins instance.\n\nThe default location of jenkins.yaml is $JENKINS_HOME/jenkins.yaml, from where it can be fetched into the Jenkins server whenever you apply a new configuration.\n\nDownload your jenkins.yaml file by going to Manage Jenkins Configuration as Code Download Configuration.\n\nMake sure this file is saved at location $JENKINS_HOME/jenkins.yaml.\n\nLet’s change the systemMessage field to:\n\nFigure 1. Updating the jenkins.yaml file\n\nReload the existing configuration to apply the system message change\n\nNow, go back to the Dashboard and you can see the updated System Message on top:\n\nFigure 2. Viewing the changes on Dashboard\n\nThis file will be used later to configure the plugin using JCasC.\n\nConfigure the plugin on the UI\n\nFor this demo, install the View Job Filters plugin.\n\nLet’s create a view by clicking on the New View option on the left side of the Dashboard.\n\nGive it a name (say, “testView”) and set its type to List View, and click on the OK button.\n\nFigure 3. Creating the View\n\nNow click on Add Job Filter to add any kind of filter, so let’s select Build Duration Filter and fill the field with any value (say, \"60\" minutes),\n\nFigure 4. Adding filter to the view\n\nClick on Apply Save.\n\nTo view the full configuration, check out your main jenkins.yaml configuration file, by clicking on Manage Jenkins Configuration as Code View Configuration\n\nGo to the views section in this YAML file to see details related to the view,\n\nFigure 5. Here, details regarding the view (which we just created) is visible\n\nDownload the Configuration\n\nNow that you have successfully configured your plugin by UI, let’s download the configuration by going to Manage Jenkins on the Dashboard, then click on Configuration as Code under \"System Configuration\".\n\nNow click on the Download Configuration button to save the configuration file locally.\n\nFigure 6. Downloading the Configuration\n\nUpdate JCasC file locally\n\nAdd some changes in your downloaded copy of the jenkins.yaml file, to see those changes being automatically reflected on the UI.\n\nFor demo purposes, let’s change the name to “YoutubeDemoView” and set the buildDurationMinutes as \"55\".\n\nFigure 7. Changing the View details locally\n\nSave the file.\n\nLoad the jenkins.yaml file on the Jenkins server\n\nNow to reflect the local changes done in the jenkins.yaml file onto the Jenkins server, click on the Reload existing configuration button.\n\nFigure 8. Applying the New Configuration to the Jenkins instance\n\nVerify the changes on the UI\n\nGo back to the main page by clicking on the Jenkins logo on the top-left side.\n\nAnd you will notice that the name of your view has been changed from \"testView\" to “YoutubeDemoView”,\n\nAnd the field value of Build Duration Filter has been changed from \"60\" to “55”.\n\nThese two are the exact changes that we did locally in our jenkins.yaml file.\n\nFigure 9. Verifying the changes\n\nCongratulations! You’ve successfully configured a plugin (“View Job Filter”) automatically with the help of the “Jenkins Configuration as Code” plugin! You can repeat the same process for other plugins as well.","title":"Configure Plugins with JCasC","tags":["jcasc","tutorial","plugins","yaml"],"authors":[]}},{"node":{"date":"2018-08-14T00:00:00.000Z","id":"2fa297fb-b9d2-5c87-846c-6ac7d68adea3","slug":"/blog/2018/08/14/simple-pull-request-plugin-final-evaluation/","strippedHtml":"About me\n\nI am Abhishek Gautam, 3rd year student from Visvesvaraya National Institute of\ntechnology, India, Nagpur. I was a member of ACM Chapter and Google student developer club of my\ncollege. I am passionate about automation.\n\nProject Summary\n\nThis is a GSoC 2018 project.\n\nThis project aims to develop a pull request Job Plugin. Users should be able to\nconfigure job type using YAML file placed in root directory of the\nGit repository being the subject of the pull request. The plugin should interact with various\nplatforms like Bitbucket, Github, Gitlab, etc whenever a pull request is created or updated.\n\nPlugin detects the presence of certain types of reports at conventional locations,\nand publish them automatically. If the reports are not present at their respective conventional\nlocation, the location of the report can be configured in the YAML file.\n\nMy mentors are\nOleg Nenashev (Org Admin),\nMartin d’Anjou,\nKristin Whetstone,\nJeff Knurek\n\nProject Repository\n\nProject repository\n\nCode changes\n\nAll the pull requests made can be found here\n\nList of major pull requests.\n\nPhase 1\n\nPR-5 : Git wrappers like clone, pull, checkout,\npullChangesOfPullrequest, merge, deleteBranch and merge added.\n\nPR-6 : Yaml to Declarative Pipeline code generation.\n\nPlease see Phase 1 blog post\n\nPhase 2\n\nPR-11 : Implemented StepConfigurator\nusing Jenkins configuration as code plugin.\n\nPR-19 : Unit tests created for agent and yaml to pipeline generation.\n\nPlease see Phase 2 blog post\n\nPhase 3\n\nPR-25 : Declarative pipeline code generator code\nexported to extensions for extensibility and support of custom sections\n\nJenkinsfile.yaml example\n\nDocumentation of Jenkinsfile.yaml and yaml format can be found here\n\nTasks completed in Coding Phase 3\n\nAdd unit tests, JenkinsRule tests JENKINS-52495\n\nRefactor snippet generator to extensions ( JENKINS-52491)\n\nPlugin overview (Present in README.md)\n\nFuture tasks\n\nPhase 3 Jira Epic\n\nRelease 1.0 ( JENKINS-52519)\n\nSupport the “when” Declarative Pipeline directive ( JENKINS-52520)\n\nNice2have: Support hierarchical report types ( JENKINS-52521)\n\nAcceptance Test Harness tests JENKINS-52496\n\nAutomatic Workspace Cleanup when PR is closed ( JENKINS-51897)\n\nTest Multi-Branch Pipeline features support:\n\nSupport for webhooks ( JENKINS-51941)\n\nCheck if trusted people have approved a pull request and start build accordingly ( JENKINS-52517)\n\nFinalize documentation ( JENKINS-52518)\n\nTest the integration with various platforms Bitbucket, Gitlab, Github.\n\nPhase 3 evaluation presentation video\n\nVideo: Link to video evaluation\n\nPhase 3 evaluation presentation slides\n\nLink to presentation slides\n\nMy GSoC experience\n\nStudent applications started on March 12 16:00 UTC and ended on March 27 16:00 UTC. Application period allowed me to explore\nmany new technology and platforms that are making peoples life easy.\n\nBefore starting of the application\nperiod I did not know anything about Jenkins. I found Jenkins organisation on the GSoC organisations page\nand came to know that I is a CI/CD platform that is used automate various things related to software development. I studied\nabout Jenkins online and went through the problem statements provided by some mentors.\n\nI decided that to work on Simple Pull-Request Job Plugin project.\nThen I wrote a draft proposal for this project and received many comments to refactor the proposal and enhance its quality from the mentors,\nthen finally I submitted my final proposal to Google.\n\nI was able to complete most of the tasks decided in Phase 1 and 2. After Phase 2 I was not able to give time to the project because\nof the placement season in the my college. I modified the code so that other plugin developers can contribute to it by Jenkins extensions.\n\nAll the mentors made themselves available for most of the weekly calls and provided many valuable suggestions during the\nentire period of GSoC. Sometimes I was not able to communicate effectively. As communication is the key while working remotely, mentors\nsuggested to communicate more thorough gitter chat.\n\nMy overall experience of GSoC was good and all the mentors helped me as they can all times. This project allowed me to explore\nJenkins and the services offered by it. I am allowed to work on the project after GSoC ends (This is a good thing).\n\nHow to reach me\n\nEmail: gautamabhishek46@gmail.com\n\nGitter room: https://gitter.im/Jenkinsci/simple-pull-request-job-plugin\n\nReferences\n\nProject repository\n\nProject page\n\nGitter chat\n\nBug Tracker\n\nDemo Repository","title":"alpha-3 release Pipeline as YAML (Simple pull request plugin)","tags":["gsoc2018","plugin","pipeline","yaml"],"authors":[]}},{"node":{"date":"2018-07-17T00:00:00.000Z","id":"2629d18c-2a10-59b8-8b11-b24bb8b2b87d","slug":"/blog/2018/07/17/simple-pull-request-plugin/","strippedHtml":"About me\n\nI am Abhishek Gautam, 3rd year student from Visvesvaraya National Institute of\ntechnology, India, Nagpur. I was a member of ACM Chapter and Google student developer club of my\ncollege. I am passionate about automation.\n\nProject Summary\n\nThis is a GSoC 2018 project.\n\nThis project aims to develop a pull request Job Plugin. Users should be able to\nconfigure job type using YAML file placed in root directory of the\nGit repository being the subject of the pull request. The plugin should interact with various\nplatforms like Bitbucket, Github, Gitlab, etc whenever a pull request is created or updated.\n\nPlugin detects the presence of certain types of reports at conventional locations,\nand publish them automatically. If the reports are not present at their respective conventional\nlocation, the location of the report can be configured in the YAML file.\n\nMy mentors are\nOleg Nenashev (Org Admin),\nMartin d’Anjou,\nKristin Whetstone,\nJeff Knurek\n\nBenefits to the community\n\nProject administrators will be able to handle pull request builds more easily.\n\nBuild specifications for pull requests can be written in a concise declarative format.\n\nBuild reports will be automatically published to Github, Bitbucket, etc.\n\nBuild status updates will be sent to git servers automatically.\n\nUsers will not have to deal with pipeline code.\n\nIf there will be no merge conflicts or build failures, the PR can be merged into target branch.\n\nPhase 1 blog post\n\nPlease see Phase 1 blog post\n\nImplementations till now\n\nAlpha version of the plugin is released. It supports all features of Multi-Branch Pipeline and offers the following features.\n\nBuild description is defined via YAML file stored within the SCM repo. This plugin\nwill depend on GitHub plugin, Bitbucket plugin, Gitlab plugin if users will be\nusing respective platforms for their repositories.\n\nConversion of YAML to Declarative Pipeline: A class YamlToPipeline\nis written which will load the \"Jenkinsfile.yaml\" and make use of PipelineSnippetGenerator class\nto generate Declarative pipeline code.\n\nReporting of results, only xml report types is supported for now.\n\nUse of Yaml file (Jenkinsfile.yaml) from target branch.\n\nGit Push step: To push the changes of pull request to the target branch. This is implemented\nusing git-plugin, PushCommand is used for this from git-plugin. credentialId,\nbranch name and repository url for interacting with Github, Bitbucket, etc\nwill be taken automatically from \"Branch-Source\" (Users have to fill this\ndetails of branch source in job configuration UI). (You can see\nHow to run the demo)\n\nStepConfigurator: To generate pipeline code for all supported steps in Jenkins. This is using\nJenkins configuration-as-code plugin (JCasC plugin) to configure a particular step object and\nthen that step object is passed to Snippetizer.object2Groovy() method to generate the script of that step.\n\nJenkinsfile.yaml example\n\nFor the phase 1 prototype demonstration, the following yaml file was used.\nNote that this format is subject to change in the next phases of the project,\nas we formalise the yaml format definition.\n\n#  Docker image agent example\nagent:\n label: my_label\n customWorkspace: path_to_workspace\n dockerImage: maven:3-alpine\n args: -v /tmp:/tmp\n\n  tools:\n    maven : maven_3.0.1\n    jdk : jdk8\n\nconfiguration:\n  # Push PR changes to the target branch if the build succeeds.\n  # default value is false\n  pushPrOnSuccess: false\n\n  # Trusted user to approve pull requests\n  prApprovers:\n    - username1\n    - username2\n    - username3\n\nenvironment:\n  variables:\n    variable_1: value_1\n    variable_2: value_2\n\n  # Credentials contains only two fields. credentialId must be present in the Jenkins Credentials\n  credentials:\n    - credentialId : fileCredentialId\n      variable : FILE\n\n      # In user scripts Username and Password can be accessed by LOGIN_USR and LOGIN_PSW\n      # respectively as environment variales\n    - credentialId : dummyGitRepo\n      variable : LOGIN\n\nstages:\n  - name: stage1\n    agent: any\n    steps:\n      - sh: \"scripts/hello\"\n      - sleep:\n          time: 2\n          unit: SECONDS\n      - sleep: 2\n      - junit:\n          testResults: \"target/**.xml\"\n          allowEmptyResults: true\n          testDataPublishers:\n            - AutomateTestDataPublisher\n            - JunitResultPublisher:\n                urlOverride: \"urlOverride\"\n    # Post section for \"stage1\". All Conditions which are available in Jenkins\n    # declarative pipeline are supported\n    post:\n      failure:\n        - sh: \"scripts/hello\"\n\n# Outer post section. Just like declarative pipeline.\npost:\n  always:\n    - sh: \"scripts/hello\"\n\nCoding Phase 2 plans (Completed)\n\nDecide a proper YAML format to use for Jenkinsfile.yaml\n\nCreate Step Configurator for SPRP plugin. JENKINS-51637.\nThis will enable users to use Pipeline steps in Jenkinsfile.yaml.\n\nAutomatic indentation generation in the generated PipelineSnippetGenerator class.\n\nWrite tests for the plugin.\n\nCoding Phase 3 plans\n\nTest Multi-Branch Pipeline features support:\n\nSupport for webhooks ( JENKINS-51941)\n\nCheck if trusted people have approved a pull request and start build accordingly ( JENKINS-52517)\n\nFinalize documentation ( JENKINS-52518)\n\nRelease 1.0 ( JENKINS-52519)\n\nPlugin overview blog post\n\nCoding Phase 3 plans after release\n\nSupport the “when” Declarative Pipeline directive ( JENKINS-52520)\n\nNice2have: Support hierarchical report types ( JENKINS-52521)\n\nAdd unit tests, JenkinsRule tests, and ATH tests ( JENKINS-52495, JENKINS-52496)\n\nAutomatic Workspace Cleanup when PR is closed ( JENKINS-51897)\n\nRefactor snippet generator to extensions ( JENKINS-52491)\n\nPhase 3 Jira Epic\n\nPhase 2 evaluation presentation video\n\nVideo:\n\nPhase 2 evaluation presentation slides\n\nHow to reach me\n\nEmail: gautamabhishek46@gmail.com\n\nGitter room: https://gitter.im/Jenkinsci/simple-pull-request-job-plugin\n\nReferences\n\nProject repository\n\nProject page\n\nGitter chat\n\nBug Tracker\n\nDemo Repository\n\nPhase 2 Presentation video (July 12, 2018)\n\nPhase 2 Presentation Slides (July 12, 2018)","title":"Pipeline as YAML: Alpha release","tags":["gsoc2018","plugin","pipeline","yaml"],"authors":[]}},{"node":{"date":"2018-06-15T00:00:00.000Z","id":"099fdcfb-2f30-562a-9c7c-67ed48398003","slug":"/blog/2018/06/15/simple-pull-request-plugin/","strippedHtml":"About me\n\nI am Abhishek Gautam, 3rd year student from Visvesvaraya National Institute of\ntechnology, India, Nagpur. I was a member of ACM Chapter and Google student developer club of my\ncollege. I am passionate about automation.\n\nMentors\n\nOleg Nenashev (Org Admin)\n\nMartin d’Anjou\n\nKristin Whetstone\n\nJeff Knurek\n\nProject Summary\n\nThis is a GSoC 2018 project.\n\nThis project aims to develop a pull request Job Plugin. Users should be able to\nconfigure job type using YAML file placed in root directory of the\nGit repository being the subject of the pull request. The plugin should interact with various\nplatforms like Bitbucket, Github, Gitlab, etc whenever a pull request is created or updated.\n\nPlugin detects the presence of certain types of the report at conventional locations,\nand publish them automatically. If the reports are not present at conventional location,\ncan specify the location using the YAML file.\n\nBenefits to the community\n\nProject administrators will be able to handle builds for pull requests more easily.\n\nBuild specifications for pull request can be written in a concise declarative format.\n\nBuild reports will be automatically published to Github, Bitbucket, etc.\n\nBuild status updates will be sent to git servers automatically.\n\nUsers will not have to deal with pipeline code.\n\nIf there will be no merge conflicts or build failures, the PR can be merged into target branch.\n\nPrior work\n\nTravis YML Plugin :\nDesigned to run .travis.yml as Jenkins pipeline job.\nTravis-CI does not support external pull requests. Jenkins environment\nis different than Travis and does not always make sense to use configurations\ndefined for other environment in Jenkins. Also maintenance of this is slowed\ndown and last commit for this plugin was on 14 Nov 2016.\nClick here to check.\n\nCodeShip Plugin :\nThis plugin is designed to convert codeship \"steps.yaml\" and\n\"services.yaml\" to scripted pipeline code. This plugin has never been released.\n\nJenkins pipeline builder :\nThis is a external non-Java-based tool, which cannot be easily converted to a Jenkins plugin.\n\nDesign\n\nThis plugin will be developed on the top of the MultiBranch Pipeline plugin.\n\nFor now the plugin is bulding branches and Pull request both using Jenkinsfile.yaml,\nbut this plugin is inclined to use for pull requests. This will be fixed in next coding phase.\n\nThis plugin is following below steps for now:\n\nclone target repo\n\ncheckout to target branch\n\nfetch the source branch\n\nmerge source-branch\n\ncall user call user script to build the repo.\n\npush changes of pull request to target branch\n\npublish test reports\n\nPlugin will start above steps if and only if the pull request is\nmergeable, to avoid merge conflicts while merging the source branch to target\nbranch. Pull request’s payload contains information if the pull request changes\nare mergeable or not hence, the pull request is mergebale or not can also be\ndecided by the payload of webhook also.\n\nHow to run the Plugin\n\nSee How to run the demo\nand set credentials, owner and repository on your own and you will be good to go.\n\nExample branch-source configuration.\n\nPhase 1 features\n\nUsers are able to select the Jenkinsfile.yaml file as the source for the Pipeline configuration.\n\nGit Push step\n\nharvest results and reports (and post in the pull request)\n\njunit()\n\nfindbugs()\n\narchiveArtifacts()\n\nBasic interface to parse and get build specifications from YAML file.\n\nThings decided\n\nTo build the plugin on the top of multibranch pipeline plugin. As that plugin has implementation of\n\nNice interface to show different branch and pull requests build separately with use of suitable plugins like Github, Bitbucket.\n\nDetect trusted revisions in a repository.\n\nPublishing of build status to the repository.\n\nConvert the YAML configuration to declarative pipeline.\n\nUser will provide path to the script relative to the root directory of the repository\nwithout extension (.sh or .bat) in the YAML file. The plugin will generate pipeline script to detect the\nplatform and call .sh or .bat script.\n\nExample:\n  Path provided: ./scripts/hello\n  a. On UNIX machine “./scripts/hello.sh” will be called\n  b. On non-UNIX machine “./scripts/hello.bat” will be called.\n\nImplementations till now\n\nA first prototype of the plugin is ready. It supports all features of Multi-Branch Pipeline and offers the following features.\n\nBuild description is defined via YAML file stored within the SCM repo. This plugin\nwill depend on GitHub plugin, Bitbucket plugin, Gitlab plugin if users will be\nusing respective paltfroms for their repositories.\n\nBasic conversion of YAML to Declarative Pipeline: A class YamlToPipeline\nis written which will load the \"Jenkinsfile.yaml\" and make use of PipelineSnippetGenerator class\nto generate Declarative pipeline code.\n\nReporting of results.\n\nPlugin is using Yaml from target branch right now. (Maybe this needs some discussion, example:\nwhat if pull request contains changes in Jenkinsfile.yaml)\n\nGit Push step: To push the changes of pull request to the target branch. This is implemented\nusing git-plugin, PushCommand is used for this from git-plugin. credentialId,\nbranch name and repository url for intracting with Github, Bitbucket, etc\nwill be taken automatically from \"Branch-Source\" (Users have to fill thes\ndetails of branch source in job configuration UI). (You can see\nHow to run the demo)\n\nJenkinsfile.yaml example\n\nFor the phase 1 prototype demonstration, the following yaml file was used.\nNote that this format is subject to change in the next phases of the project,\nas we formalise the yaml format definition.\n\nagent:\n    dockerImage: maven:3.5.3-jdk-8\n    args: -v /tmp:/tmp\n\ntestResultPaths:\n    - target/surefire-reports/*.xml\n\nfindBugs: target/*.xml\n\nstages:\n    - name: First\n      scripts:\n        -   ./scripts/hello\n    - name: Build\n      scripts:\n        -   ./scripts/build\n    - name: Tests\n      scripts:\n        -   ./scripts/test\n\narchiveArtifacts:\n    - Jenkinsfile.yaml\n    - scripts/hello.sh\n\nFrom the yaml file shown above, the plugin generates the following pipeline code:\n\npipeline {\n  agent {\n    docker {\n      image 'maven:3.5.3-jdk-8'\n      args '-v /tmp:/tmp'\n      alwaysPull false\n      reuseNode false\n    }\n  }\n  stages {\n    stage('First') {\n      steps {\n        script {\n          if (isUnix()) {\n            sh './scripts/hello.sh'\n          } else {\n            bat './scripts/hello.bat'\n          }\n        }\n      }\n    }\n    stage('Build') {\n      steps {\n        script {\n          if (isUnix()) {\n            sh './scripts/build.sh'\n          } else {\n            bat './scripts/build.bat'\n          }\n        }pipeline\n      }\n      post {\n        success {\n          archiveArtifacts artifacts: '**/target/*.jar'\n          archiveArtifacts artifacts: 'Jenkinsfile.yaml'\n          archiveArtifacts artifacts: 'scripts/hello.sh'\n        }\n      }\n    }\n    stage('Tests') {\n      steps {\n        script {\n          if (isUnix()) {\n            sh './scripts/test.sh'\n          } else {\n            bat './scripts/test.bat'\n          }\n        }\n      }\n      post {\n        success {\n          junit 'target/surefire-reports/*.xml'\n        }\n        always {\n          findbugs pattern: 'target/*.xml'\n        }\n      }\n    }\n  }\n}\n\nPipeline view in Jenkins instance\n\nCoding Phase 2 plans\n\nDecide a proper YAML format to use for Jenkinsfile.yaml\n\nCreate Step Configurator for SPRP plugin. Jenkins-51637.\nThis will enable users to use Pipeline steps in Jenkinsfile.yaml.\n\nAutomatic indentation generation in the generated Pipeline SnipperGenerator class.\n\nWrite tests for the plugin.\n\nJira Epic\n\nHow to reach me\n\nEmail: gautamabhishek46@gmail.com\n\nGitter room: https://gitter.im/Jenkinsci/simple-pull-request-job-plugin\n\nReferences\n\nInitial proposal of the project\n\nProject repository\n\nProject page\n\nGitter chat\n\nBug Tracker\n\nDemo Repository\n\nPhase 1 Presentation video (June 14, 2018)\n\nPhase 1 Presentation Slides (June 14, 2018)","title":"GSoC Project Intro: Pipeline as YAML","tags":["gsoc2018","gsoc","plugin","pipeline","yaml"],"authors":[]}},{"node":{"date":"2018-04-25T00:00:00.000Z","id":"e34fdb6b-09c7-5772-a251-10cec0ccef26","slug":"/blog/2018/04/25/configuring-jenkins-pipeline-with-yaml-file/","strippedHtml":"A few years ago our CTO wrote about building a\nContinuous Integration server for Ruby On Rails using Jenkins and docker.\nThe solution has been our CI pipeline for the past years until we recently decided to\nmake an upgrade. Why?\n\nJenkins version was way out of date and it was getting difficult to\nupgrade\n\nWolox has grown significantly over the past years\nand we’ve been experiencing scaling issues\n\nVery few people knew how to fix any issues with the server\n\nConfiguring jobs was not an easy task and that made our project\nkickoff process slower\n\nMaking changes to the commands that each job runs was not easy and not\nmany people had permissions to do so. Wolox has a wide range of\nprojects, with a wide variety of languages which made this problem even\nbigger.\n\nTaking into account these problems, we started digging into the newest\nversion of Jenkins to see how we could improve our CI. We needed to\nbuild a new CI that could, at least, address the following:\n\nProjects must be built using Docker. Our projects depend on one or\nmultiple docker images to run (app, database, redis, etc)\n\nEasy to configure and replicate if necessary\n\nEasy to add a new project\n\nEasy to change the building steps. Everyone working on the project\nshould be able to change if they want to run npm install or yarn\ninstall.\n\nInstalling Jenkins and Docker\n\nInstalling Jenkins is straightforward. You can visit\nJenkins Installation page and choose the\noption that best suits your needs.\n\nHere are the steps we followed to install Jenkins in AWS:\n\nsudo rpm — import https://pkg.jenkins.io/debian/jenkins.io.key\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo\nsudo yum install java-1.8.0 -y\nsudo yum remove java-1.7.0-openjdk -y\nsudo yum install jenkins -y\nsudo yum update -y\nsudo yum install -y docker\n\nAutomatically adding projects from Github\n\nAdding projects automatically from Github can be achieved using the\nGitHub Branch Source Plugin.\nIt allows Jenkins to scan a GitHub organization\nfor projects that match certain rules and add them to Jenkins\nautomatically. The only constraint that all branches must meet in order\nto be added is that they contain a Jenkinsfile that explains how to\nbuild the project.\n\nEasy to change configuration\n\nNot so easy to change configuration\n\nOne of the biggest pains we had with our previous Jenkins was the\ndifficulty of changing the steps necessary to build the project. If you\nlooked at a project’s build steps, you would find something like this:\n\n#!/bin/bash +x\nset -e\n\n# Remove unnecessary files\necho -e \"\\033[34mRemoving unnecessary files...\\033[0m\"\nrm -f log/*.log &> /dev/null || true &> /dev/null\nrm -rf public/uploads/* &> /dev/null || true &> /dev/null\n\n# Build Project\necho -e \"\\033[34mBuilding Project...\\033[0m\"\ndocker-compose --project-name=${JOB_NAME} build\n\n# Prepare test database\nCOMMAND=\"bundle exec rake db:drop db:create db:migrate\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\ndocker-compose --project-name=${JOB_NAME} run  \\\n\t-e RAILS_ENV=test web $COMMAND\n\n# Run tests\nCOMMAND=\"bundle exec rspec spec\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\nunbuffer docker-compose --project-name=${JOB_NAME} run web $COMMAND\n\n# Run rubocop lint\nCOMMAND=\"bundle exec rubocop app spec -R --format simple\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\nunbuffer docker-compose --project-name=${JOB_NAME} run -e RUBYOPT=\"-Ku\" web $COMMAND\n\nAnd some post build steps that cleaned up the docker:\n\n#!/bin/bash +x\ndocker-compose --project-name=${JOB_NAME} stop &> /dev/null || true &> /dev/null\ndocker-compose --project-name=${JOB_NAME} rm --force &> /dev/null || true &> /dev/null\ndocker stop `docker ps -a -q -f status=exited` &> /dev/null || true &> /dev/null\ndocker rm -v `docker ps -a -q -f status=exited` &> /dev/null || true &> /dev/null\ndocker rmi `docker images --filter 'dangling=true' -q --no-trunc` &> /dev/null || true &> /dev/null\n\nAlthough these commands are not complex, changing any of them required\nsomeone with permissions to modify the job and an understanding ofwhat\nneeded to be done.\n\nJenkinsfile to the rescue…​ or not\n\nWith the current Jenkins version, we can take advantage of\nJenkins Pipeline and model our build\nflow in a file. This file is checked into the repository and, therefore,\nanyone with access to it can change the build steps. Yay!\n\nJenkins Pipeline even has support for:\n\nDocker and\nmultiple\nimages can be used for a build!\n\nSetting environment variables with withEnv and many other built -in\nfunctions that can be found\nhere.\n\nThis makes a perfect case for Wolox. We can have\nour build configuration in a file that’s checked into the repository and\ncan be changed by anyone with write access to it. However, a Jenkinsfile\nfor a simple rails project would look something like this:\n\n# sample Jenkinsfile. Might not compile\nnode {\n    checkout scm\n    withEnv(['MYTOOL_HOME=/usr/local/mytool']) {\n        docker.image(\"postgres:9.2\").withRun() { db ->\n            withEnv(['DB_USERNAME=postgres', 'DB_PASSWORD=', \"DB_HOST=db\", \"DB_PORT=5432\"]) {\n                docker.image(\"redis:X\").withRun() { redis ->\n                    withEnv([\"REDIS_URL=redis://redis\"]) {\n                        docker.build(imageName, \"--file .woloxci/Dockerfile .\").inside(\"--link ${db.id}:postgres --link ${redis.id}:redis\") {\n                            sh \"rake db:create\"\n                            sh \"rake db:migrate\"\n                            sh \"bundle exec rspec spec\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nThis file is not only difficult to read, but also difficult to change.\nIt’s quite easy to break things if you’re not familiar with Groovy and\neven easier if you know nothing about how Jenkins’ pipeline works.\nChanging or adding a new Docker image isn’t straightforward and might\nlead to confusion.\n\nConfiguring Jenkins Pipeline via YAML\n\nPersonally, I’ve always envied simple configuration files for CIs and\nthis time it was our chance to build CI that could be configured using a\nYAML file. After some analysis we concluded that a YAML like this one\nwould suffice:\n\nconfig:\n  dockerfile: .woloxci/Dockerfile\n  project_name: some-project-name\n\nservices:\n  - postgresql\n  - redis\n\nsteps:\n  analysis:\n    - bundle exec rubocop -R app spec --format simple\n    - bundle exec rubycritic --path ./analysis --minimum-score 80 --no-browser\n  setup_db:\n    - bundle exec rails db:create\n    - bundle exec rails db:schema:load\n  test:\n    - bundle exec rspec\n  security:\n    - bundle exec brakeman --exit-on-error\n  audit:\n    - bundle audit check --update\n\n\nenvironment:\n  RAILS_ENV: test\n  GIT_COMMITTER_NAME: a\n  GIT_COMMITTER_EMAIL: b\n  LANG: C.UTF-8\n\nIt outlines some basic configuration for the project, environment\nvariables that need to be present during the run, dependentservices, and\nour build steps.\n\nJenkinsfile + Shared Libraries = WoloxCI\n\nAfter investigating for a while about Jenkins and the pipeline, we found\nthat we could extend it with\nshared libraries.\nShared libraries are written in groovy and can be imported\ninto the pipeline and executed when necessary.\n\nIf you look carefully at this Jenkinsfile,\nwe see that the code is a chain of methods calls that receive a\nclosure, where we execute another method passing a new closure to it.\n\n# sample Jenkinsfile. Might not compile\nnode {\n    checkout scm\n    withEnv(['MYTOOL_HOME=/usr/local/mytool']) {\n        docker.image(\"postgres:9.2\").withRun() { db ->\n            withEnv(['DB_USERNAME=postgres', 'DB_PASSWORD=', \"DB_HOST=db\", \"DB_PORT=5432\"]) {\n                docker.image(\"redis:X\").withRun() { redis ->\n                    withEnv([\"REDIS_URL=redis://redis\"]) {\n                        docker.build(imageName, \"--file .woloxci/Dockerfile .\").inside(\"--link ${db.id}:postgres --link ${redis.id}:redis\") {\n                            sh \"rake db:create\"\n                            sh \"rake db:migrate\"\n                            sh \"bundle exec rspec spec\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nGroovy is flexible enough to allow this same declarative code to be\ncreated at runtime, making our dream of using a YAML to configure our\njob come true!\n\nIntroducing Wolox-CI\n\nThat’s how wolox-ci was born- our\nshared library for Jenkins!\n\nWith wolox-ci, our Jenkinsfile is now\nreduced to:\n\n@Library('wolox-ci') _\n\nnode {\n\n  checkout scm\n\n  woloxCi('.woloxci/config.yml');\n}\n\nNow it simply checks out the code and then calls wolox-ci. The library\nreads yaml file like this one\n\nconfig:\n  dockerfile: .woloxci/Dockerfile\n  project_name: some-project-name\n\nservices:\n  - postgresql\n  - redis\n\nsteps:\n  analysis:\n    - bundle exec rubocop -R app spec --format simple\n    - bundle exec rubycritic --path ./analysis --minimum-score 80 --no-browser\n  setup_db:\n    - bundle exec rails db:create\n    - bundle exec rails db:schema:load\n  test:\n    - bundle exec rspec\n  security:\n    - bundle exec brakeman --exit-on-error\n  audit:\n    - bundle audit check --update\n\n\nenvironment:\n  RAILS_ENV: test\n  GIT_COMMITTER_NAME: a\n  GIT_COMMITTER_EMAIL: b\n  LANG: C.UTF-8\n\nand builds the Jenkinsfile to get your job running on the fly.\n\nThe nice part about having a shared library is that we can extend and\nfix our library in a centralized way. Once we add new code, the library\nis automatically updated in Jenkins which will notify all of our jobs\nwith the update.\n\nSince we have projects in different languages we use Docker to build the\ntesting environment. WoloxCI assumes there is a Dockerfile to build and\nwill run all the specified commands inside the container.\n\nWoloxci config.yml\n\nConfig\n\nThe first part of the config.yml file specifies some basic\nconfiguration: project’s name and Dockerfile location. The Dockerfile is\nused to build the image where the commands will be run.\n\nServices\n\nThis section describes which services will be exposed to the container.\nOut of the box, WoloxCI has support for postgresql, mssql and\nredis. You can also specify the docker image version you want! It is\nnot hard to add a new service. You just need to add the corresponding\nfile at\n\nhttps://github.com/Wolox/wolox-ci/tree/development/vars\n\nand modify how the services are parsed\n\nhttps://github.com/Wolox/wolox-ci/blob/development/src/com/wolox/parser/ConfigParser.groovy#L76\n\nSteps\n\nThe listed commands in this section will run inside the Docker\ncontainer. As a result, you’ll see each of the steps on the Jenkins UI.\n\nEnvironment\n\nIf you need some environment variables during your build, you can\nspecify them here. Whatever variable you set will be available inside\nthe Docker container when your commands listed in the steps section\ndescribed above.\n\nWrapping up\n\nWoloxCI is still being tested with a not-so-small sample of our\nprojects. The possibility of changing the build steps through a YAML\nfile makes it accessible for everyone and that is a great improvement in\nour CI workflow.\n\nDocker gives us the possibility of easily changing the programming\nlanguage without making any changes to our Jenkins installation and\nJenkins’ Github Organization feature automatically adds new projects\nwhen a new repository with a Jenkinsfile is detected.\n\nAll of these improvements have reduced the time we spend maintaining\nJenkins significantly and give us the possibility of easily scaling\nwithout any extra configuration.\n\nThis library is working in our CI but it still can be improved.\nIf you would like to add features, feel free to\ncontribute!","title":"Configuring a Jenkins Pipeline using a YAML file","tags":["jenkins","pipelines","yaml","sharedlibrary"],"authors":[]}}]}},"pageContext":{"tag":"yaml","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}