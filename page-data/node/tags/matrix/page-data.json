{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/matrix",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2019-12-02T00:00:00.000Z","id":"85ad92d1-eb99-59b8-9bbf-3b4f6309d6df","slug":"/blog/2019/12/02/matrix-building-with-scripted-pipeline/","strippedHtml":"Table of Contents\n\nMatrix building with scripted pipeline\nScreenshot of matrix pipeline\nAdding static choices\nAdding dynamic choices\nFull pipeline example with dynamic choices\nBackground: How does it work?\nExposing a shared library pipeline step\nSummary\n\nWith the recent announcement about matrix building you can perform\nMatrix builds\nwith declarative pipeline.  However, if you must use scripted pipeline, then\nI’m going to cover how to matrix build platforms and tools using scripted\npipeline.  The examples in this post are modeled after the declarative pipeline\nmatrix examples.\n\nMatrix building with scripted pipeline\n\nThe following Jenkins scripted pipeline will build combinations across two\nmatrix axes.  However, adding more axes to the matrix is just as easy as adding\nanother entry to the Map matrix_axes.\n\nJenkinsfile\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\n@NonCPS\nList getMatrixAxes(Map matrix_axes) {\n    List axes = []\n    matrix_axes.each { axis, values ->\n        List axisList = []\n        values.each { value ->\n            axisList << [(axis): value]\n        }\n        axes !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\n// parallel task map\nMap tasks = [failFast: false]\n\nfor(int i = 0; i\"${k}=${v}\"\n    }\n    // let's say you have diverse agents among Windows, Mac and Linux all of\n    // which have proper labels for their platform and what browsers are\n    // available on those agents.\n    String nodeLabel = \"os:${axis['PLATFORM']} && browser:${axis['BROWSER']}\"\n    tasks[axisEnv.join(', ')] = { ->\n        node(nodeLabel) {\n            withEnv(axisEnv) {\n                stage(\"Build\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n                stage(\"Test\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n            }\n        }\n    }\n}\n\nstage(\"Matrix builds\") {\n    parallel(tasks)\n}\n\nMatrix axes contain the following combinations:\n\n[PLATFORM=linux, BROWSER=firefox]\n[PLATFORM=windows, BROWSER=firefox]\n[PLATFORM=mac, BROWSER=firefox]\n[PLATFORM=linux, BROWSER=chrome]\n[PLATFORM=windows, BROWSER=chrome]\n[PLATFORM=mac, BROWSER=chrome]\n[PLATFORM=windows, BROWSER=safari]\n[PLATFORM=mac, BROWSER=safari]\n[PLATFORM=windows, BROWSER=edge]\n\nIt is worth noting that Jenkins agent labels can contain a colon ( :).  So\nos:linux and browser:firefox are both valid agent labels.  The node\nexpression os:linux && browser:firefox will search for Jenkins agents which\nhave both labels.\n\nScreenshot of matrix pipeline\n\nThe following is a screenshot of the pipeline code above running in a sandbox\nJenkins environment.\n\nAdding static choices\n\nIt is useful for users to be able to customize building matrices when a build\nis triggered.  Adding static choices requires only a few changes to the above\nscript.  Static choices as in we hard code the question and matrix filters.\n\nJenkinsfile\n\n(response['PLATFORM'] == 'all' || response['PLATFORM'] == axis['PLATFORM']) &&\n    (response['BROWSER'] == 'all' || response['BROWSER'] == axis['BROWSER']) &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nThe pipeline code then renders the following choice dialog.\n\nWhen a user chooses the customized options, the pipeline reacts to the\nrequested options.\n\nAdding dynamic choices\n\nDynamic choices means the choice dialog for users to customize the build is\ngenerated from the Map matrix_axes rather than being something a pipeline\ndeveloper hard codes.\n\nFor user experience (UX), you’ll want your choices to automatically reflect the\nmatrix axis options you have available.  For example, let’s say you want to add\na new dimension for Java to the matrix.\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    JAVA: ['openjdk8', 'openjdk10', 'openjdk11'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\nTo support dynamic choices, your choice and matrix axis filter needs to be\nupdated to the following.\n\nchoice(\n                choices: ['all'] + options.sort(),\n                description: \"Choose a single ${key.toLowerCase()} or all to run tests.\",\n                name: key)\n        })\n}\n\n// filter the matrix axes since\n// Safari is not available on Linux and\n// Edge is only available on Windows\nList axes = getMatrixAxes(matrix_axes).findAll { axis ->\n    response.every { key, choice ->\n        choice == 'all' || choice == axis[key]\n    } &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nIt will dynamically generate choices based on available matrix axes and will\nautomatically filter if users customize it.  Here’s an example dialog and\nrendered choice when the pipeline executes.\n\nFull pipeline example with dynamic choices\n\nThe following script is the full pipeline example which contains dynamic\nchoices.\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    JAVA: ['openjdk8', 'openjdk10', 'openjdk11'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\n@NonCPS\nList getMatrixAxes(Map matrix_axes) {\n    List axes = []\n    matrix_axes.each { axis, values ->\n        List axisList = []\n        values.each { value ->\n            axisList << [(axis): value]\n        }\n        axes \nchoice(\n                choices: ['all'] + options.sort(),\n                description: \"Choose a single ${key.toLowerCase()} or all to run tests.\",\n                name: key)\n        })\n}\n\n// filter the matrix axes since\n// Safari is not available on Linux and\n// Edge is only available on Windows\nList axes = getMatrixAxes(matrix_axes).findAll { axis ->\n    response.every { key, choice ->\n        choice == 'all' || choice == axis[key]\n    } &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\n// parallel task map\nMap tasks = [failFast: false]\n\nfor(int i = 0; i\"${k}=${v}\"\n    }\n    // let's say you have diverse agents among Windows, Mac and Linux all of\n    // which have proper labels for their platform and what browsers are\n    // available on those agents.\n    String nodeLabel = \"os:${axis['PLATFORM']} && browser:${axis['BROWSER']}\"\n    tasks[axisEnv.join(', ')] = { ->\n        node(nodeLabel) {\n            withEnv(axisEnv) {\n                stage(\"Build\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n                stage(\"Test\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n            }\n        }\n    }\n}\n\nstage(\"Matrix builds\") {\n    parallel(tasks)\n}\n\nBackground: How does it work?\n\nThe trick is in axes.combinations()*.sum().  Groovy combinations are a quick\nand easy way to perform a\ncartesian product.\n\nHere’s a simpler example of how cartesian product works.  Take two simple lists\nand create combinations.\n\nList a = ['a', 'b', 'c']\nList b = [1, 2, 3]\n\n[a, b].combinations()\n\nThe result of [a, b].combinations() is the following.\n\n[\n    ['a', 1],\n    ['b', 1],\n    ['c', 1],\n    ['a', 2],\n    ['b', 2],\n    ['c', 2],\n    ['a', 3],\n    ['b', 3],\n    ['c', 3]\n]\n\nInstead of a, b, c and 1, 2, 3 let’s do the same example again but instead using matrix maps.\n\nList java = [[java: 8], [java: 10]]\nList os = [[os: 'linux'], [os: 'freebsd']]\n\n[java, os].combinations()\n\nThe result of [java, os].combinations() is the following.\n\n[\n    [ [java:8],  [os:linux]   ],\n    [ [java:10], [os:linux]   ],\n    [ [java:8],  [os:freebsd] ],\n    [ [java:10], [os:freebsd] ]\n]\n\nIn order for us to easily use this as a single map we must add the maps\ntogether to create a single map.  For example, adding\n[java: 8] + [os: 'linux'] will render a single hashmap\n[java: 8, os: 'linux'].  This means we need our list of lists of maps to\nbecome a simple list of maps so that we can use them effectively in pipelines.\n\nTo accomplish this we make use of the\nGroovy spread\noperator ( *. in axes.combinations()*.sum()).\n\nLet’s see the same java / os example again but with the spread operator being\nused.\n\nList java = [[java: 8], [java: 10]]\nList os = [[os: 'linux'], [os: 'freebsd']]\n\n[java, os].combinations()*.sum()\n\nThe result is the following.\n\n[\n    [ java: 8,  os: 'linux'],\n    [ java: 10, os: 'linux'],\n    [ java: 8,  os: 'freebsd'],\n    [ java: 10, os: 'freebsd']\n]\n\nWith the spread operator the end result of a list of maps which we can\neffectively use as matrix axes.  It also allows us to do neat matrix filtering\nwith the findAll {} Groovy List method.\n\nExposing a shared library pipeline step\n\nThe best user experience is to expose the above code as a shared library\npipeline step.  As an example, I have added\nvars/getMatrixAxes.groovy\nto Jervis.  This provides a flexible shared library step which you can copy\ninto your own shared pipeline libraries.\n\nThe step becomes easy to use in the following way with a simple one dimension matrix.\n\nJenkinsfile\n\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n]\n\nList axes = getMatrixAxes(matrix_axes)\n\n// alternately with a user prompt\n//List axes = getMatrixAxes(matrix_axes, user_prompt: true)\n\nHere’s a more complex example using a two dimensional matrix with filtering.\n\nJenkinsfile\n\n!(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nAnd again with a three dimensional matrix with filtering and prompting for user\ninput.\n\nJenkinsfile\n\n!(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nThe script approval is not necessary for\nShared Libraries.\n\nIf you don’t want to provide a shared step.  In order to expose matrix building\nto end-users, you must allow the following method approval in the script\napproval configuration.\n\nScript approval\n\nstaticMethod org.codehaus.groovy.runtime.DefaultGroovyMethods combinations java.util.Collection\n\nSummary\n\nWe covered how to perform matrix builds using scripted pipeline as well as how\nto prompt users for customizing the matrix build.  Additionally, an example was\nprovided where we exposed getting buildable matrix axes to users as an easy to\nuse Shared Library\nstep via vars/getMatrixAxes.groovy.  Using a shared library step is\ndefinitely the recommended way for admins to support users rather than trying\nto whitelist groovy methods.\n\nJervis shared pipeline library has supported matrix building since 2017 in Jenkins scripted pipelines.\n( see here and\nhere\nfor an example).","title":"Matrix building in scripted pipeline","tags":["matrix","pipeline","plugins","scripted"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#c8c8b8","images":{"fallback":{"src":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png","srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/914ee/sgleske.png 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/1c9ce/sgleske.png 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/acb7c/sgleske.png 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/ef6ff/sgleske.webp 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/8257c/sgleske.webp 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/6766a/sgleske.webp 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/22bfc/sgleske.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"samrocketman","html":"<div class=\"paragraph\">\n<p>A Senior Software Engineer at <a href=\"https://integralads.com/\">Integral Ad\nScience</a>, he develops a Jenkins solution to scale CI/CD onboarding for the\nentire company.  To aide in this cause he has been developing\n<a href=\"https://github.com/samrocketman/jervis/wiki\">Jervis: Jenkins as a service</a>\nwhich strongly focuses on onboarding people and not just technology or projects\ninto Jenkins.  When not at work he enjoys contributing to open source software,\nlike the Jenkins project, solely through volunteer time.</p>\n</div>","id":"sgleske","irc":null,"linkedin":null,"name":"Sam Gleske","slug":"/blog/author/sgleske","twitter":"sag47"}]}},{"node":{"date":"2019-11-22T00:00:00.000Z","id":"e5f5bc1a-7d2f-5807-8b41-7478e232a4f1","slug":"/blog/2019/11/22/welcome-to-the-matrix/","strippedHtml":"I often find myself needing to run the same actions on a bunch of different configurations.\nUp to now, that meant I had to make multiple copies of the same stages in my pipelines.\nWhen I needed to make changes, I had to make the same changes in multiple places throughout my pipeline.\nMaintaining even a small number of configuration was difficult for larger pipelines.\n\nDeclarative Pipeline 1.5.0-beta1 (now available from the\nJenkins Experimental Update site) adds a new matrix section that lets me specify a list stages once and then run that same list in parallel on multiple configurations.\nLet’s take a look!\n\nSingle configuration pipeline\n\nI’ll start with a simple pipeline with build and test stages.\nI’m using echo steps as placeholders for my build and test actions.\n\nJenkinsfile\n\npipeline {\n    agent none\n    stages {\n        stage('BuildAndTest') {\n            agent any\n            stages {\n                stage('Build') {\n                    steps {\n                        echo 'Do Build'\n                    }\n                }\n                stage('Test') {\n                    steps {\n                        echo 'Do Test'\n                    }\n                }\n            }\n        }\n    }\n}\n\nPipeline for multiple platforms and browsers\n\nI’d like to run my build and tests on a combination of platforms and browsers.\nThe new matrix directive lets me specify a set of axes.\nEach axis has a name and a list of one or more values.\nWhen the pipeline is run, Jenkins will take those and run my stages on all possible combinations of values from each axis.\nAll cells in a matrix run in parallel (limited only by the number of available agents).\nStages within each cell are run sequentially.\n\nMy matrix has two axes: PLATFORM and BROWSER.\nI have three values for PLATFORM and four values for BROWSER resulting in my stages being run with twelve different combinations.\nI’ve changed my echo steps to use the axis values for each cell.\n\nJenkinsfile\n\npipeline {\n    agent none\n    stages {\n        stage('BuildAndTest') {\n            matrix {\n                agent any\n                axes {\n                    axis {\n                        name 'PLATFORM'\n                        values 'linux', 'windows', 'mac'\n                    }\n                    axis {\n                        name 'BROWSER'\n                        values 'firefox', 'chrome', 'safari', 'edge'\n                    }\n                }\n                stages {\n                    stage('Build') {\n                        steps {\n                            echo \"Do Build for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                    stage('Test') {\n                        steps {\n                            echo \"Do Test for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nLog output (truncated)\n\n...\n[Pipeline] stage\n[Pipeline] { (BuildAndTest)\n[Pipeline] parallel\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'edge') (hide)\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'edge')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'edge')\n...\nDo Build for linux - safari\nDo Build for linux - firefox\nDo Build for windows - firefox\nDo Test for linux - firefox\nDo Build for mac - firefox\nDo Build for linux - chrome\nDo Test for windows - firefox\n...\n\nExcluding invalid combinations\n\nNow that I have my basic matrix created, I’ve noticed that I have some invalid combinations.\nMicrosoft Edge only runs on Windows and there isn’t a Linux version of Safari.\n\nI can remove invalid cells from my matrix using exclude directives. Each exclude has one or more axis directives with name and values.\nThe axis directives inside an exclude generate a set of combinations (similar to generating the matrix cells).\nThe matrix cells that match all the values from an exclude combination are removed from the matrix.\nIf I have more than one exclude directive, each are evaluated separately to remove cells.\n\nWhen dealing with a long lists of values to exclude, I can use notValues instead of values to specify axis values we don’t want excluded.\nYes, that’s a double negative, so it can get a little confusing.\nI try to use it only when I really need it.\n\nIn my sample pipeline below, I specifically exclude the linux, safari combination and I also exclude any platform that is not windows with the edge browser.\n\nThis pipeline uses two axes but there is no limit on the number of axis directives.\n\nAlso, in this pipeline each exclude specifies values for both axes, but that is not required.\nIf we wanted to run only \"linux\" cells, we could use the following exclude :\n\nexclude {\n    axis {\n        name 'PLATFORM'\n        notValues 'linux'\n    }\n}\n\npipeline {\n    agent none\n    stages {\n        stage('BuildAndTest') {\n            matrix {\n                agent any\n                axes {\n                    axis {\n                        name 'PLATFORM'\n                        values 'linux', 'windows', 'mac'\n                    }\n                    axis {\n                        name 'BROWSER'\n                        values 'firefox', 'chrome', 'safari', 'edge'\n                    }\n                }\n                excludes {\n                    exclude {\n                        axis {\n                            name 'PLATFORM'\n                            values 'linux'\n                        }\n                        axis {\n                            name 'BROWSER'\n                            values 'safari'\n                        }\n                    }\n                    exclude {\n                        axis {\n                            name 'PLATFORM'\n                            notValues 'windows'\n                        }\n                        axis {\n                            name 'BROWSER'\n                            values 'edge'\n                        }\n                    }\n                }\n                stages {\n                    stage('Build') {\n                        steps {\n                            echo \"Do Build for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                    stage('Test') {\n                        steps {\n                            echo \"Do Test for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nLog output (truncated)\n\n...\n[Pipeline] stage\n[Pipeline] { (BuildAndTest)\n[Pipeline] parallel\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'edge')\n...\nDo Build for linux - firefox\n...\n\nControlling cell behavior at runtime\n\nInside the matrix directive I can also add \"per-cell\" directives.\nThese are the same directives that I would add to a stage and they let me control the behavior of each cell in the matrix.\nThese directives can use the axis values from their cell as part of their inputs, allowing me to customize the behavior of each cell to match its axis values.\n\nOn my Jenkins server I have configured agents with labels that match the OS for each agent (\"linux-agent\", \"windows-agent\", and \"mac-agent\").\nTo run each cell in my matrix on the appropriate operating system, I configure the label for that cell using Groovy string templating.\n\nmatrix {\n    axes { ... }\n    excludes { ... }\n    agent {\n        label \"${PLATFORM}-agent\"\n    }\n    stages { ... }\n    // ...\n}\n\nOccasionally I run my pipeline manually from the Jenkins Web UI.\nWhen I do that, I’d like to be able to select just one platform to run.\nThe axis and exclude directives define the static set of cells that make up the matrix.\nThat set of combinations is generated before the start of the run, before any parameters are processed.\nWhat this means is that I can’t add or remove cells from a matrix after the job has started.\n\nThe \"per-cell\" directives, on the other hand, are evaluated at runtime.\nI can use the \"per-cell\" when directive inside matrix to control which cells in the matrix are executed.\nI’ll add a choice parameter with the list of platforms, and add conditions to the when directive, which will either let all platforms execute, or only execute cells that match my selected platform.\n\npipeline {\n    parameters {\n        choice(name: 'PLATFORM_FILTER', choices: ['all', 'linux', 'windows', 'mac'], description: 'Run on specific platform')\n    }\n    agent none\n    stages {\n        stage('BuildAndTest') {\n            matrix {\n                agent {\n                    label \"${PLATFORM}-agent\"\n                }\n                when { anyOf {\n                    expression { params.PLATFORM_FILTER == 'all' }\n                    expression { params.PLATFORM_FILTER == env.PLATFORM }\n                } }\n                axes {\n                    axis {\n                        name 'PLATFORM'\n                        values 'linux', 'windows', 'mac'\n                    }\n                    axis {\n                        name 'BROWSER'\n                        values 'firefox', 'chrome', 'safari', 'edge'\n                    }\n                }\n                excludes {\n                    exclude {\n                        axis {\n                            name 'PLATFORM'\n                            values 'linux'\n                        }\n                        axis {\n                            name 'BROWSER'\n                            values 'safari'\n                        }\n                    }\n                    exclude {\n                        axis {\n                            name 'PLATFORM'\n                            notValues 'windows'\n                        }\n                        axis {\n                            name 'BROWSER'\n                            values 'edge'\n                        }\n                    }\n                }\n                stages {\n                    stage('Build') {\n                        steps {\n                            echo \"Do Build for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                    stage('Test') {\n                        steps {\n                            echo \"Do Test for ${PLATFORM} - ${BROWSER}\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nIf I run this Pipeline from the Jenkins UI and set the PLATFORM_FILTER parameter to mac, I’ll get something like the output below:\n\nLog output (truncated - PLATFORM_FILTER = 'mac' )\n\n...\n[Pipeline] stage\n[Pipeline] { (BuildAndTest)\n[Pipeline] parallel\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'firefox')\n[Pipeline] { (Branch: Matrix - OS = 'linux', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'chrome')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'mac', BROWSER = 'safari')\n[Pipeline] { (Branch: Matrix - OS = 'windows', BROWSER = 'edge')\n...\nStage \"Matrix - OS = 'linux', BROWSER = 'chrome'\" skipped due to when conditional\nStage \"Matrix - OS = 'linux', BROWSER = 'firefox'\" skipped due to when conditional\n...\nDo Build for mac - firefox\nDo Build for mac - chrome\nDo Build for mac - safari\n...\nStage \"Matrix - OS = 'windows', BROWSER = 'chrome'\" skipped due to when conditional\nStage \"Matrix - OS = 'windows', BROWSER = 'edge'\" skipped due to when conditional\n...\nDo Test for mac - safari\nDo Test for mac - firefox\nDo Test for mac - chrome\n\nCome join me at DevOps World | Jenkins World 2019 for \" Declarative Pipeline 2019: Tips, Tricks and What’s Next \".\nI’ll go over what’s been added to Pipeline in the last year (including matrix) and discuss ideas about where pipeline should go next.\n\nConclusion\n\nIn this blog post, we’ve looked at how to use the matrix directive to make concise but powerful declarative pipelines.\nAn equivalent pipeline created without matrix would easily be several times larger, and much harder to understand and maintain.\n\nMatrix is now available from the experimental update center.\nIt will be released to the main update center as soon as we’re done putting the finishing touches on the documentation and online help.\n\nLinks\n\nJenkins Experimental Update Center\n\nUsing the Jenkins Experimental Update Center","title":"Welcome to the Matrix","tags":["pipeline","plugins","declarative","matrix"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#382818","images":{"fallback":{"src":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/19e71/lnewman.jpg","srcSet":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/77b35/lnewman.jpg 32w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/d4a57/lnewman.jpg 64w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/19e71/lnewman.jpg 128w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/68974/lnewman.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/ef6ff/lnewman.webp 32w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/8257c/lnewman.webp 64w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/6766a/lnewman.webp 128w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/22bfc/lnewman.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"bitwiseman","html":"<div class=\"paragraph\">\n<p>Liam started his software career as a tester, which might explain why he&#8217;s such a fan of CI/CD and Pipeline as Code.\nHe has spent the majority of his software engineering career implementing Continuous Integration systems at companies big and small.\nHe is a Jenkins project contributor and an expert in Jenkins Pipeline, both Scripted and Declarative.\nLiam currently works as a Jenkins Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\nWhen not at work, he enjoys testing gravity by doing Aikido.</p>\n</div>","id":"lnewman","irc":null,"linkedin":null,"name":"Liam Newman","slug":"/blog/author/lnewman","twitter":"bitwiseman"}]}}]}},"pageContext":{"tag":"matrix","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}