{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/cloudevents",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2021-08-02T00:00:00.000Z","id":"4b818957-350e-52f3-a687-d86ebc43405d","slug":"/blog/2021/08/02/cloudevents-plugin-phase-I/","strippedHtml":"The What, Why and How of Interoperability\n\nWith workloads and teams becoming more diverse and complex, there is an increasing need to automate various tasks in the CI/CD ecosystem of an application as a way to decrease complexity that can come with CI/CD.\n\nA more diverse team working across different aspects of the application requires a diverse suite of CI/CD tools too, to test and deliver to a wide range of users. More often than not, we need these tools to work together and exchange data to form an effective CI/CD pipeline. However, chaining multiple services together can very easily increase complexity.\n\nHow? Each of these services use a different \"language\" to communicate and represent the entity(an event) which occured inside that service. In order for another service to understand this \"language\", the service might need to develop customized clients and agents which specialize in understanding, traversing and taking-actions based on what was transmitted to it by the first service.\n\nOne can think of it as a translator who specializes in a language called ABC, and each service who wants to communicate with the service who uses ABC will have to employ this translator, or perhaps get another trained translator. And there is no guarantee that this translator will also help communicate with other services speaking a completely different language.\n\nWe can see how easily that can grow in cost and maintenance. A preferred way is to have a common language each of these services use and understand as a way to communicate amongst each other. This way, an event which is emitted using this common language will be available to any of the interested receiver without that receiver needing a special agent. This way of communication which uses a common/standard language also creates a way for agnostic communication where the sender or the receiver are sending and receiving data without creating a tight coupling between the two.\n\nCloudEvents specification is enabling that loosely-coupled, event-driven communication between services by enforcing a common language which defines how an event should be emitted and transferred between systems.\n\nCloudEvents and Jenkins\n\nA specification for describing event data in a common way\n\nConsistency\n\nConsistent across tools and services.\n\nAccessibility\n\nCommon event format means common libraries, tooling, and infrastructure for delivering event data across environments can be used to develop with CloudEvents.\n\nPortability\n\nEasily port event-data across tools, truly leveraging event-driven architecture.\n\nThe CloudEvents plugin for Jenkins is developed as an effort to make interoperability between Jenkins and CI/CD tools much easier. The CloudEvents plugin for Jenkins is a GSoC project, and with the help from an amazing team of mentors, this project is aimed at enhancing event-driven interoperability between cloud-native CI/CD tools, making it easier for developers to include Jenkins in their CI/CD pipelines.\n\nWith this plugin, Jenkins can send and receive CloudEvents-compliant events to and from a wide variety of CI/CD tools using CloudEvents as their event format. This plugin makes chaining Jenkins with multiple tools like Tekton, Keptn, Knative and more, very easy.\n\nGSoC Phase 1 - CloudEvents Plugin\n\nUsing CloudEvents plugin for Jenkins\n\nThis plugin allows Jenkins to be configured as a source and sink, which can emit and consume CloudEvents from a range of tools simultaneously.\n\nJenkins as a Source\n\nConfiguring Jenkins as a Source enables Jenkins to send CloudEvents to a CloudEvents sink. For Phase-I of this project, there is support for HTTP Sinks, however CloudEvents supports various protocol bindings. Moving forward, there will also be support for other protocol bindings supported by CloudEvents.\n\nTo use Jenkins as a Source, the following configuration is needed:\n\nClick on Manage Jenkins in the Root-Actions menu on the left.\n\nInside the Manage Jenkins UI, search for Configure System under System Configuration.\n\nIn the Configure System UI, scroll down to the CloudEvents plugin section, and this is where all the plugin configuration will be present. Here, you will have to enter the following information:\n\nSink Type (For now, HTTP Protocol Binding for CloudEvent and HTTP Sink is supported.)\n\nSink URL (URL of the Sink where you want the cloudevents sent.)\n\nEvents you want sent to the CloudEvents sink URL.\n\nStep 1: Manage Jenkins\n\nStep 2: Configure System\n\nStep 3: Configure CloudEvents Sink\n\nWith Jenkins as a Source configured, Jenkins will send a POST request to the configured sink right as the selected event occurs inside Jenkins. Each event has a different payload specific to the type of the event emitted.\n\nEvent Types, Payload and Metadata\n\nCloudEvents emitted by Jenkins follow the Binary-structure supported by CloudEvents, where the CloudEvents metadata is present inside the header, and the event-data is serialized as JSON, and present under request-body. This is the HTTP Protocol Binding for CloudEvents. Each protocol binding for CloudEvents follows a definition specific to the binding protocol.\n\nFor now, the following Jenkins events are supported in the CloudEvents Plugin-Jenkins as a Source:\n\nQueue Events\n\nQueue Entered Waiting\n\nQueue Left\n\nBuild Events\n\nJob Started\n\nJob Completed\n\nJob Finalized\n\nJob Failed\n\nJob Events\n\nJob Created\n\nJob Updated\n\nNode Events\n\nNode Online\n\nNode Offline\n\nFollowing is a table of the queue-entered waiting cloudevents metadata:\n\nEvent Metadata Headers Key\nEvent Metadata Headers Value\n\nce-specversion\n1.0\n\nce-type\norg.jenkinsci.queue.entered_waiting\n\nce-source\njob/test\n\nce-id\n123-456-789\n\nAll of these fields will be present inside the HTTP-request headers since the CloudEvents format used here is the Binary structure.\n\nHere’s also an example of event payload for the queue-entered event:\n\n{\n  \"ciUrl\": \"http://3.101.116.80/\",\n  \"displayName\": \"test2\",\n  \"entryTime\": 1626611053609,\n  \"exitTime\": null,\n  \"startedBy\": \"shruti chaturvedi\",\n  \"jenkinsQueueId\": 25,\n  \"status\": \"ENTERED_WAITING\",\n  \"duration\": 0,\n  \"queueCauses\": [\n    {\n    \"reasonForWaiting\": \"In the quiet period. Expires in 0 ms\",\n    \"type\": \"entered_waiting\"\n    }\n  ]\n}\n\nTry the Plugin\n\nThe plugin will soon be releasing as the CloudEvents Plugin under https://plugins.jenkins.io/!!\n\nHere’s the GitHub Repo of the Plugin: CloudEvents Plugin GitHub Repo\n\nDemo\n\nHere is a video of the CloudEvents plugin with SockEye demoed at CDF GSoC Midterm Demos. SockEye is an open-source tool which is designed as a way to visulaize cloudevents which are sent from a sink. In this demo, we will take a look at how Jenkins installed in a multi-node K8s environment work with the CloudEvents plugin as a Source, sending events over HTTP to the SockEye sink.\n\nNext Steps\n\nJenkins as a Sink to allow Jenkins to trigger various actions as cloudevents are received from other tools.\n\nEnabling filtering on CloudEvents metadata to only act upon a certain kind of events recieved.\n\nSupport for other protocol bindings in CloudEvents.\n\nFeedback\n\nWe would absolutely love to hear your suggestions and feedback. This will help us understand the various use-cases for the plugin, and iterate to support a variety of bindings and formats.\n\nFeel free to log an issue at the CloudEvents Plugin GitHub repository. We are on CDF slack under gsoc-2021-jenkins-cloudevents-plugin. You can also start a discussion on community.jenkins.io. I also love emails! Drop me one on: shrutichaturvedi16.sc@gmail.com","title":"CloudEvents Plugin for Jenkins: Interoperability between Jenkins and other CI/CD Tools","tags":["gsoc","gsoc2021","cloudevents","interoperability","cloud-native"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/bf8e1/ShrutiC-git.png","srcSet":"/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/914ee/ShrutiC-git.png 32w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/1c9ce/ShrutiC-git.png 64w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/bf8e1/ShrutiC-git.png 128w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/acb7c/ShrutiC-git.png 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/ef6ff/ShrutiC-git.webp 32w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/8257c/ShrutiC-git.webp 64w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/6766a/ShrutiC-git.webp 128w,\n/gatsby-jenkins-io/static/02bce5237e5a6152567788b0da82ce8e/22bfc/ShrutiC-git.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"ShrutiC-git","html":"<div class=\"paragraph\">\n<p>Shruti Chaturvedi is the <strong>Founding Engineer</strong> for Klara, a startup to revolutionalize the shopping experience for beauty products.\nShe is an <strong>Oracle Certified Cloud Practitioner</strong>, and is developing solutions on Cloud where CI/CD is her primary focus. She has worked with Jenkins as a User, and is very excited to contribute to Jenkins and be a part of the community.</p>\n</div>","id":"ShrutiC-git","irc":null,"linkedin":null,"name":"Shruti Chaturvedi","slug":"/blog/authors/shrutic-git","twitter":"shruti_tech"}]}}]}},"pageContext":{"tag":"cloudevents","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}