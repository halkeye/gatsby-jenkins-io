{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/tutorial/page/4",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2010-09-02T00:00:00.000Z","id":"9cbddb28-b3f3-50db-851e-8dc3b544dec7","slug":"/blog/2010/09/02/recent-label-and-matrix-project-improvement/","strippedHtml":"Today, I’d highlight two recent improvements to the label and matrix projects.\n\nWhen you have multiple agents in your Hudson build farm, you can use labels to classify agents by their capability/environment/architecture/etc. For example, your one agent might have “32bit” and “windows” label, while another one might have “linux”, “ubuntu”, and “64bit.” (with plugins like platform-labeler plugin, you can attach labels automatically, too.) Or if you do Selenium testing, you might add browser names as labels to indicate which agent has which browser available.\n\nWith such set up, you then specify that such and such jobs can be only run on such and such labels. For example, you might say your “test-foo” job requires the “windows” label, while your “compile-bar” job might require the “macos” label.\nStarting 1.372, Hudson now lets you use boolean expressions here, instead of just specifying one label as the requirement. For example, your “seleniumTest-zot” job can now say it requires “windows&&firefox” since it’s meant to run on Windows with Firefox. Or if your job requires a shell script, you might say “!windows” to indicate that it has to be run somewhere that’s not Windows.\n\nLabels are also often used in the context of the multi-configuration project (a.k.a. matrix project.) In a multi-configuration project, you specify what to execute to build your project, then specify a number of “axes” that represents the variable and their possible values to execute a build. There are several different kinds of axes (and this is of course extensible), and one of them is the label axis.\n\nFor example, say you have a test suite that you want to run on Windows, Linux, and Solaris, to make sure it works correctly under all these environments. In such a case, you define one label axis, and tell Hudson that you have three possible values “windows”, “linux”, and “solaris.” When you build this project, Hudson will run your build three times by finding appropriate agent that carries the specified label.\n\nIn 1.373, you can now specify multiple label axes. For example, you might have a C++ project that needs to be compiled on various platforms. In such a case, you can define one label axis to be “windows”, “linux”, “solaris”, and you can define another label axis to be “32bit” and “64bit”. This will generate 3x2=6 combinations to be executed.\n\nSometimes the exhaustive combinations do not make sense. In such a case, you can use a filter boolean expression to eliminate some values. You can also use the same mechanism to create a sparse matrix — that is, you tell Hudson to reduce the coverage to 33%, and Hudson will eliminate every 2 out of 3 combinations.\n\nFinally, I’d like to thank Sandia National Laboratories for sponsoring this work, which made it possible for InfraDNA to provide this feature to the community. People often think that contributing code is the only way to give back to the project, but sponsoring features like this is another great way to do it.","title":"Recent label and matrix project improvement","tags":["development","core","tutorial"],"authors":[]}},{"node":{"date":"2010-08-11T00:00:00.000Z","id":"f277d4c3-07e9-5f66-9263-d554ef23f136","slug":"/blog/2010/08/11/quiet-period-feature/","strippedHtml":"Commits often come in a burst. This seems to happen mainly for two reasons — people sometimes forget to commit some files, and in the tranquility of waiting for your SCM to finish a commit, people sometimes realize the problems in the commit and they quickly make follow-up changes. The conventional wisdom is that the CI server should wait for the burst to finish before attempting a build. This is said to reduce the chance of having broken build, and it is also sometimes useful in reducing the average turn-around time for builds that take longer.\n\nAs such, Hudson is capable of waiting for a commit burst to be over before it triggers a new build, and this feature is called \"quiet period.\" There are two parts in Hudson that interacts with the quiet period. One is the SCM polling behavior and the other is the queue.\n\nThe queue portion of the quiet period is straight-forward. When a build is scheduled into the queue with quiet period, the build will sit in the queue until the quiet period expires. If during this period, additional attempts are made to put the same build in the queue, the quiet period resets to its initial value. For example, if the quiet period is 5 minutes, and the build is put into the queue 9:00am and 9:03am, the actual build will only happen after 9:08am. Thus another way to think of the quiet period is that you are requiring a certain period of inactivity.\n\nThe above applies to all the mechanisms in Hudson that puts builds into the queue. This includes REST API call, CLI call, downstream triggers, and SCM pollings. So if you implement some kind of a \"push\" mechanism in your SCM to notify Hudson of a new commit, then you get the desired effect by just setting the quiet period in Hudson, and those push scripts don’t have to do anything tricky.\n\nIt is also possible for some of those to override the quiet period configured in the project. For example, when you click \"Build Now\" button in your browser, your browser is making a REST API call, but with the quiet period of zero. I used to run a \"push\" script that looks into a commit message and overrides the quiet period by taking advantages of this feature.\n\nThe other portion of the quiet period that often matters is the SCM polling behaviour. Up until Hudson 1.346, the way Hudson defined the SCM abstraction made it impossible for SCMs to correctly report newly detected commits since the last polling. Instead, it was only possible to report if the repository is newer than the workspace. As a result, if the polling interval is set shorter than the quiet period, the build stayed in the quiet period forever. This was tracked in HUDSON-2180.\n\nHudson 1.346 fixed this issue, and so if you are using a newer version of Hudson and SCM plugins that take advantage of this improvement, then everything works as expected. Otherwise, avoid setting quiet period longer than the polling interval.","title":"Quiet Period Feature","tags":["general","core","tutorial"],"authors":[]}},{"node":{"date":"2010-07-28T00:00:00.000Z","id":"a07fba72-78a8-535c-9379-13f2b06ac4db","slug":"/blog/2010/07/28/hosting-your-hudson-plugin-at-github/","strippedHtml":"For as long as Hudson’s had a plugin model and development community, we’ve provided source code and binary hosting through our Subversion repo at java.net. But what if you’re a plugin developer and you don’t want to use Subversion? Well, we have an alternative for your source code: host it with Hudson on GitHub.\n\nTo get this in place, send an email to dev@hudson.dev.java.net (or ask in the IRC channel) asking to get a repository created for your plugin at Github. Make sure to include the name of the plugin and your Github username (and the Github usernames of any other developers who’ll be pushing to your plugin’s repo). If your plugin is already in Github, include the URL for the existing repo so that we can fork it. One of the Hudson admins will create the repository (forking if appropriate) and add the user(s) to the list of users with push access to the Hudson-hosted repositories at Github. Once you hear back from them, you’ll be able to push code to the new repository.\n\nYou will need to make a few changes to your plugin’s POM, as compared to what works for a plugin POM in the java.net Subversion tree.\n\nFirst, add the following to the ++ section:\n\norg.apache.maven.plugins\nmaven-release-plugin\n2.0\n\norg.apache.maven.scm\nmaven-scm-provider-gitexe\n1.3\n\nThis is needed to make sure we’re overriding the parent POM’s SCM provider settings. Next, add the following to the ++ section:\n\norg.jvnet.wagon-svn\nwagon-svn\n1.9\n\nThis is needed because we’re still going to be using wagon-svn to deploy the artifacts in the release process. Lastly, add an ` section, within the ` section of the POM, like the following:\n\nscm:git:git://github.com/hudson/your-plugin-repo.git\nscm:git:git@github.com:hudson/your-plugin-repo.git\nhttps://github.com/hudson/your-plugin-repo\n\nAs with the first section, this is needed to override the default SCM settings in the parent POM. Make sure to change \"your-plugin-repo\" to your actual plugin repository name, of course! It’d also be a good idea to put a link to your Github repo on your plugin’s wiki page at the Hudson wiki, since the default source link will go to Subversion.\n\nNow, with these changes in place, committed and pushed to the master branch in your plugin’s repository, you should be able to run \"mvn release:prepare release:perform\" just as you would if the plugin were hosted in Subversion, with your plugin showing up in the Update Center within a few hours. Be sure that you’ve configured the login information for the java.net Maven repository, as detailed here - this is still needed for plugins hosted at and released from Github, since Hudson’s Maven repository still lives at java.net. If you run into any issues releasing your plugin from Github, first be sure to review the wiki page on plugin hosting, which addresses many of the issues you may encounter when running the Maven release plugin.\n\nIf you’re still stumped, feel free to email the Hudson developer list or ask in the IRC channel for help.","title":"Hosting your Hudson plugin at Github","tags":["development","meta","plugins","tutorial","jenkinsci"],"authors":[]}},{"node":{"date":"2010-07-08T00:00:00.000Z","id":"2261a8e4-1548-5ee0-99d2-1450dc19da3f","slug":"/blog/2010/07/08/a-python-love-story-virtualenv-and-hudson/","strippedHtml":"Over the past year Hudson has grown tremendously, both within the Java community and outside of it. Partially thanks to ( Titus Brown)'s PyCon 2010 Atlanta coverage of continuous integration for Python (which we’ve covered before), Hudson has made great strides within the Python community as well. In my experience, the majority of Python developers are not using Hudson to build anything, unless they have C extensions, but rather to test their packages, which presents its own set of specific requirements for jobs. Jobs for testing Python code need to be able to reliaby reproduce an environment with the same set of dependencies from one run to the next in order to provide consistent testing. Unlike their Java counterparts, Python developers cannot rely on a powerful system like Maven2 for enumerating build/test targets or defining their project’s dependencies in their jobs; fortunately, w e can have something close: virtualenv and pip. Virtualenv does exactly what you might expect it to, it creates a \"virtual environment\" with custom site-packages directory, and modified python executable. Using virtualenv you can create a staged environment to use for running unit and integration tests. Adding pip alongside that and you have a fantastic Python package manager/installer to use with the virtual environment. Below, I’ve outlined the steps required to use virtualenv and pip to automatically manage a custom environment for your Python jobs.\n\nThe Recipe\n\nFor this recipe to work, you should make sure that your agent machines all have virtualenv and pip installed and accessible from your agent agent’s $PATH. For Mac OS X users, sudo easy_install virtualenv should do the trick, Linux users should be able to run sudo [aptitude/yum/zypper] install python-virtualenv with your respective package manager. You will also need the SetEnv Plugin installed in Hudson.\n\nStep 1\n\nInside of the job’s configuration page ( http;//hudson/job/configure), we need to define an environment variable for the job. Using the SetEnv plugin, define a new $PATH : `PATH=.env/bin:$PATH\n\nWhat this will do is modify the $PATH environment variable for all of the \"Execute shell\" build steps in your job. As you might have guessed, we’re going to install the virtualenv in.env in the workspace root directory.\n\nStep 2\n\nTo set up the virtualenv, you want to add a build step of type \"Execute shell\" and paste the following commands into the text area:\n\nif [ -d \".env\" ]; then\n  echo \"**> virtualenv exists\"\nelse\n  echo \"**> creating virtualenv\"\n  virtualenv .env\nfi\n\nThis will create a virtualenv the first time the job runs on a particular agent, a virtualenv that will persist until the workspace is cleared. Since we’re going to install dependencies in the virtualenv, we want to keep it around between jobs to reduce the amount of network hits to download packages.\n\nStep 3\n\nWith our virtualenv and our $PATH properly set up, the job can now properly install dependencies into its virtualenv, this is where pip shines. A little known feature of pip allows you to define a \"requirements file\" which enumerates the packages to install. In my example project, I defined the following requirements in a file called pip-requires.txt\n\neventlet>=0.9.9\nnose>=0.11.3\nMySQL-python>=1.2.3c1\n\nIn my hypothetical example, I’ll need nose to run my tests, while eventlet and MySQL-python are required for my project to properly run. With the pip-requires.txt file in the root of my source repository, I can add an additional \"Execute shell\" build step that does the following:\n\npip install -r pip-requires.txt\n\nAssuming the $PATH environment variable was properly defined, this will use the virtualenv’s version of pip and it will install the packages defined in pip-requires.txt into the virtualenv! With the dependencies all properly installed in the virtualenv, I can now configure the remainder of my job to build my project and execute the tests. Pretty snazzy if you ask me!","title":"A Python Love Story: Virtualenv and Hudson","tags":["general","guest post","tutorial"],"authors":[]}},{"node":{"date":"2010-04-12T00:00:00.000Z","id":"2e9993c3-3c9d-5d86-9f68-2a23c7450ae0","slug":"/blog/2010/04/12/pre-tested-commits-with-git/","strippedHtml":"At the first Bay Area Hackathon in mid-2009, the topic du jour was \" pre-tested commits.\" As potential implementations of the concept were discussed over burgers from Brickhouse in downtown San Francisco, we realized as a group a few things: first, those burgers were delicious, but more importantly: pre-testing commits is very-SCM dependent and involves a lot of moving parts. One of the positive changes that came out shortly after the meet up was the support for \"Concurrent Builds\", allowing a job to be executed concurrently on different agents, a precursor to pre-tested commit support. Fervor for the pre-tested commit feature lowered as time went on, the feature being too dependent on the SCM itself was generally accepted as the reasoning behind the feature languishing.\n\nChances are the feature is in fact too large for Hudson to support alone. It requires Hudson, the SCM and likely a third tool to work in concert together to perform such a feat.\n\nWith Git, and the phenomenal code review tool Gerrit, and the Gerrit plugin by intrepid plugin developer, Jyrki Puttonen, pre-tested commits with Hudson, Git and Gerrit are possible.\nFor Git users more familiar with the distributed Git workflows, working with Gerrit should seem familiar. Gerrit has JGit, a Java implementation of Git embedded within it, along with an sshd stack, meaning Gerrit can masquerade as a \"regular\" Git remote repository. Developers can push and pull to the repository just as they can with any other Git repository (provided they have permissions of course). I won’t delve too much into using Gerrit specifically here, but the pre-tested workflow with Gerrit and Hudson would look something like this:\n\nDev creates a topic branch to work on a change\n\nCode is written (and hopefully tested) and committed locally\n\nDev pushes commit(s) to Gerrit\n\nHudson job (set to Poll SCM) picks up the patch, runs the job and marks it as \"+1 Verified\" or \"-1 Fails\"\n\nIf the job fails or is unstable, the change should be reworked or corrected (typically with git-rebase(1))\n\nIf Hudson says the change is good to go, it can be cherry-picked or pulled directly from Gerrit.\n\nFor example: image:https://web.archive.org/web/*/https://agentdero.cachefly.net/continuousblog/gerrit_patch.png\n\nTo learn more about Gerrit, check out the project page on Google Code; information on the Gerrit plugin can be found on the wiki.","title":"Pre-tested commits with Git","tags":["infrastructure","feedback","jobs","tutorial"],"authors":[]}},{"node":{"date":"2010-03-31T00:00:00.000Z","id":"5821dff5-0138-58b1-adcc-2a38da03f591","slug":"/blog/2010/03/31/screencast-python-on-hudson-part-1/","strippedHtml":"After Hudson got some major publicity at PyCon Atlanta 2010 I haven’t been as quick as I would have liked with Python-related posts and tutorials. I use Hudson to build and test a number of pure Python modules and C extensions across numerous Python versions (covering 2.4 - 3.1). For most beginners, or those simply looking to get started with Python on Hudson, starting with my job configurations is too much at once, so instead I wanted to start at the \"beginning\" so to speak.\n\nThe trouble with getting people started with Hudson, given how simple and visual it is to use, is that articles with sample configurations are not particularly useful; a screencast however is a good medium for visually walking somebody through Hudson. The screencast below ( also on YouTube) is the first in a series of screencasts I’ll be doing, not only for Python on Hudson, but for Hudson overall. It is just over four minutes long, and covers setting up a simple continuous integration job for the Eventlet library (which is hosted on Bitbucket)","title":"Screencast: Python on Hudson (Part 1)","tags":["general","jobs","news","screencast","tutorial"],"authors":[]}},{"node":{"date":"2010-02-17T00:00:00.000Z","id":"8c069e9b-d471-5bea-86b9-a057759e2c8c","slug":"/blog/2010/02/17/getting-started-building-android-apps-with-hudson/","strippedHtml":"In this post I’ll show a very basic tips on how to compile an Android project using Hudson. Specifically how  I use Hudson to create release versions of my apps.\n\nDebug vs Release\n\nI’m assuming that you are using Eclipse with the ADT plugin. During development you can test your app on the emulator or a device and resources like R.java and aidl files are compiled for you automatically by the plugin. When it’s time to release your app, you’ll need to go through some steps:\n\nYou must sign your app using a certificate\n\nYou must update your AndroidManifest.xml to remove the android:debuggable attribute\n\nReplace your Google Maps API debug key with the one belonging to your release certificate (if you are using a MapView)\n\nGenerate an apk package for the release and test it on a device or emulator\n\nIt would be nice to automate a few of these steps, and this is where Hudson comes in.\n\nAutomated builds: Ant\n\nFor automated builds the Android SDK uses Apache Ant, which Hudson has great support for. To generate a template build.xml you can use the android tool from the SDK using the following command:\n\nandroid create project -n template -t android-7 -p template -k dummy.pkg -a Dummy\n\nThe target is specified as \"android-7\" meaning that we are building for Android 2.1. For apps that use MapView we would use \"Google Inc.:Google APIs:7\". It is a good idea to always target the latest SDK. From this template project we’ll grab the build.properties and the build.xml and copy those to the Android project that we want to build. Edit build.xml and set the project name to your Android project name.\n\nThe local.properties file contains the path to the SDK root and shouldn’t be checked in to version control. For our use we’ll set the properties that are in that file on the Hudson job configuration page.\n\nRunning the build in Hudson\n\nThis part is easy: create a new freestyle job and let it be build with ant. The targets that we want to execute are clean release. Release will compile, package and sign your apk. Now to get this working right, some custom properties should be set (use the Advanced button).\n\nsdk.dir=/Users/hugo/Code/android-sdk-mac\ntarget=Google Inc.:Google APIs:7\nkey.store=certs/rd-release.keystore\nkey.alias=rainydays\nkey.store.password=thisisnotmypassword\nkey.alias.password=thisisnotmypassword\n\nThe sdk.dir should point to the Android SDK root on your Hudson node. In my case I’m running Hudson locally on my machine.  The target property refers to the SDK we want to use as mentioned earlier.  The key. properties are related to signing of the apk. My strategy is to have a separate key store and private key for each application that I develop. I also check that keystore in to SVN. I also archive the -release.apk artifact so that I can download the latest release apk directly from Hudson.  After completing these steps, you should be able to build your Android app with Hudson.\n\nUpdating the AndroidManifest for release\n\n…​But we’re not done yet :) Remember what I said about updating the AndroidManifest.xml? For that we need to edit the build.xml, which by default contains nothing more then a tag to pull in the Android SDK ant target definitions. For my Rainy Days application, I adjusted build.xml like this:\n\n...\n\nRemoving debug attribute from AndroidManifest.xml\n\nSetting release maps key\n\nWhat the above snippet does is removing the android:debuggable attribute from the AndroidManifest.xml and replacing the maps API key in res/layout/maplayout.xml with the correct key for release. The -package-resources target is pulled in from the Android android_rules.xml file.\n\nNow when Hudson builds my app I get a ready to release apk that I can install on my device or emulator, which is pretty nice.\n\nThere is are some issues with this approach however. As you might have noticed:\n\nReplacements are done in the workspace, we are not really building exactly what’s in svn\n\nEach new build should start out fresh for that reason, for example by using the svn revert option.\n\nAdditionally I can not yet tag the release version with the updated files, because the subversion tagging plugin doesn’t support this by design. This could be worked around by adding svn statements in the build.xml however.  For now I don’t really mind as I make minor changes to the resource files, but I’ll be looking at improving this situation.\n\nThings to add: unit testing, coverage…​\n\nOne thing that I’d really like to add is unit testing. This is a little bit more complicated though, since unit tests require a running emulator and a running emulator requires a gui. The Hudson Xvnc plugin could be very helpful here.\n\nThe Android build scripts for test projects already include EMMA output, it shouldn’t be to hard to use the Hudson plugin for that.\n\nWhen Hudson is running on a local machine, the Batch task plugin can automate installing the apk on a device to automate things further.\n\nSummary\n\nBuilding Android applications with Hudson is not that hard, since the builds are based on Ant. By hooking in to the standard Android build targets it’s easy to update files like AndroidManifest.xml which in turn makes sure the release process is controlled and predictable.\nAndroid unit tests depend on the emulator which is a little bit more challenging to set up, but Hudson already has some plugins available to make this easier.\n\nEditor’s Note: Hugo Visser is the developer of Rainy Days and Engine Watch for Android. You can\nfollow him on Twitter and on his blog.","title":"Getting started: Building Android apps with Hudson","tags":["general","guest post","jobs","tutorial"],"authors":[]}},{"node":{"date":"2010-02-10T00:00:00.000Z","id":"bf65fc5d-5128-5381-a704-e7da235ac78d","slug":"/blog/2010/02/10/keeping-your-configuration-and-data-in-subversion/","strippedHtml":"We all know that keeping important files in version control is critical, as it ensures problematic changes can be reverted and can serve as a backup mechanism as well. Code and resources are often kept in version control, but it can be easy to forget your continuous integration (CI) server itself! If a disk were to die or fall victim to a misplaced rm -rf, you could lose all the history and configuration associated with the jobs your CI server manages.\n\nIt’s pretty simple to create a repository, but it isn’t obvious which parts of your $HUDSON_HOME you’ll want to backup. You’ll also want to have some automation so new projects get added to the repository, and deleted ones get removed. Luckily we have a great tool to handle this: Hudson!\n\nWe have a Hudson job which runs nightly, performs the appropriate SVN commands, and checks in. The high-level overview of this job is basically:\n\nAdd any new jobs, users, plugin configurations, et cetera: svn add -q --parents.xml jobs/ /config.xml users/ /config.xml userContent/\n\nRemove anything from SVN that no longer exists (such as a deleted job): svn status | grep '!' | awk '{print $2;}' | xargs -r svn rm\n\nCheck it in! svn ci --non-interactive --username=mrhudson -m \"automated commit of Hudson configuration\"\nYou’ll want to make sure to use the --non-interactive option for any automated svn operations, as this ensures Subversion won’t hang asking a question but instead fail immediately. You may also need to provide your password with the --password option.\n\nTo make such a Hudson job, create a new job, tie it to the controller (since this is where the configuration files are), set it to build periodically (we use “@midnight”), and add an “Execute shell” build step. Here’s the full script we use, to put into the build step:\n\n# Change into your HUDSON_HOME.\ncd /opt/hudson\n# Add any new conf files, jobs, users, and content.\nsvn add -q --parents *.xml jobs/*/config.xml users/*/config.xml userContent/*\n# Ignore things in the root we don't care about.\necho -e \"warnlogn*.logn*.tmpn*.oldn*.bakn*.jarn*.json\" > myignores\nsvn propset svn:ignore -F myignores . && rm myignores\n# Ignore things in jobs/* we don't care about.\necho -e \"buildsnlast*nnext*n*.txtn*.lognworkspace*ncoberturanjavadocnhtmlreportsnncoverndoclinks\" > myignores\nsvn propset svn:ignore -F myignores jobs/* && rm myignores\n# Remove anything from SVN that no longer exists in Hudson.\nsvn status | grep '!' | awk '{print $2;}' | xargs -r svn rm\n# And finally, check in of course, showing status before and after for logging.\nsvn st && svn ci --non-interactive --username=mrhudson -m \"automated commit of Hudson configuration\" && svn st\n\nYou’ll notice this does some extra things like set the svn:ignores property to provide a relatively clean svn st which it shows before and after the commit for logging purposes. One thing this job doesn’t do is put the build results of your jobs in version control. Because historical build logs and artifacts will never change and are also potentially large, a periodic (daily or weekly) cp or rsync of the jobs directory will still give you restorability while keeping your repository lean.\n\nNow you can sleep well at night knowing that your CI server is safe and sound. If you are doing a similar thing with Hudson or another CI system, let us know about your solution!\n\nEditor’s Note: Mike Rooney is a Software Engineer at Genius.com, provider of real-time marketing automation software connecting marketing and sales. You can read more posts from Mike and other Geniuses at eng.genius.com","title":"Keeping your configuration and data in Subversion","tags":["development","guest post","jobs","just for fun","tutorial"],"authors":[]}}]}},"pageContext":{"tag":"tutorial","limit":8,"skip":24,"numPages":4,"currentPage":4}},
    "staticQueryHashes": ["3649515864"]}