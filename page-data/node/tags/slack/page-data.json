{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/slack",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2017-02-15T00:00:00.000Z","id":"76a4ff94-6194-5d56-a94c-3287ec832681","slug":"/blog/2017/02/15/declarative-notifications/","strippedHtml":"This is a guest post by Liam Newman,\nTechnical Evangelist at CloudBees.\n\nDeclare Your Pipelines!\nDeclarative Pipeline 1.0 is here!\nThis is the third post in a series showing some of the cool features of\nDeclarative Pipeline.\n\nIn the\nprevious post,\nwe converted a Scripted Pipeline to a Declarative Pipeline, adding descriptive stages\nand post sections.  In one of those post blocks, we included a placeholder for\nsending notifications.\n\nIn this blog post, we’ll repeat what I did in\n\" Sending Notifications in Pipeline\nbut this time in Declarative Pipeline.\nFirst we’ll integrate calls to notification services Slack, HipChat, and Email into our Pipeline.\nThen we’ll refactor those calls into a single Step in a Shared Library, which\nwe’ll reuse as needed, keeping our Jenkinsfile concise and understandable.\n\nSetup\n\nThe setup for this post is almost the same as\nmy previous Declarative Pipeline post.\nI’ve used a new branch in\nmy fork of the\nHermann project :\nblog/declarative/notifications .\nI’d already set up a Multibranch Pipeline and pointed it at my repository,\nso the new branch will be picked up and built automatically.\n\nI still have my notification targets (where we’ll send notifications) that I created for the\n\" Sending Notifications in Pipeline\" blog post.\nTake a look at that post to review how I setup the\nSlack,\nHipChat,\nand Email-ext\nplugins to use those channels.\n\nAdding Notifications\n\nWe’ll start from the same Pipeline we had at the end of the previous post.\n\nThis Pipeline works quite well, except it doesn’t print anything at the start of\nthe run, and that final always directive only prints a message to the console log.\nLet’s start by getting the notifications working like we did in the original post.\nWe’ll just copy-and-paste the three notification steps (with different parameters)\nto get the notifications working for started, success, and failure.\n\npipeline {\n  /* ... unchanged ... */\n  stages {\n    stage ('Start') {\n      steps {\n        // send build started notifications\n        slackSend (color: '#FFFF00', message: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n        // send to HipChat\n        hipchatSend (color: 'YELLOW', notify: true,\n            message: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n          )\n\n        // send to email\n        emailext (\n            subject: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n            body: \"\"\" STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n            recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n          )\n      }\n    }\n    /* ... unchanged ... */\n  }\n  post {\n    success {\n      slackSend (color: '#00FF00', message: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n      hipchatSend (color: 'GREEN', notify: true,\n          message: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n        )\n\n      emailext (\n          subject: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n          body: \"\"\" SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n          recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n        )\n    }\n\n    failure {\n      slackSend (color: '#FF0000', message: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n      hipchatSend (color: 'RED', notify: true,\n          message: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n        )\n\n      emailext (\n          subject: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n          body: \"\"\" FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n          recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n        )\n    }\n  }\n}\n\nMoving Notifications to Shared Library\n\nThis new Pipeline works and our Declarative Pipeline sends notifications; however,\nit is extremely ugly. In the original post using Scripted Pipeline,\nI defined a single method that I called at both the start and end of the pipeline.\nI’d like to do that here as well, but Declarative doesn’t support creating methods\nthat are accessible to multiple stages.\nFor this, we’ll need to turn to\nShared Libraries.\n\nShared Libraries, as the name suggests,\nlet Jenkins Pipelines share code instead of copying it to each new project.\nShared Libraries are not specific to Declarative; they were released in their\ncurrent form several months ago and were useful in Scripted Pipeline.\nDue to Declarative Pipeline’s lack of support for defining methods,\nShared Libraries take on a vital role.  They are the only supported way within\nDeclarative Pipeline to define methods or classes that we want to use in more than one stage.\n\nThe lack of support for defining methods that are accessible in multiple stages,\nis a known issue, with at least two JIRA tickets:\nJENKINS-41335 and\nJENKINS-41396.\nFor this series, I chose to stick to using features that are fully supported\nin Declarative Pipeline at this time.\nThe internet has plenty of hacked together solutions that happen to work today,\nbut I wanted to highlight current best practices and dependable solutions.\n\nSetting up a Shared Library\n\nI’ve created a simple shared library repository for this series of posts, called\njenkins-pipeline-shared.\nThe shared library functionality has too many configuration options to cover in one post.\nI’ve chosen to configure this library as a \"Global Pipeline Library,\"\naccessible from any project on my Jenkins controller.\nTo setup a \"Global Pipeline Library,\" I navigated to \"Manage Jenkins\" → \"Configure System\"\nin the Jenkins web UI.\nOnce there, under \"Global Pipeline Libraries\", I added a new library.\nI then set the name to bitwiseman-shared, pointed it at my repository,\nand set the default branch for the library to master,\nbut I’ll override that in my Jenkinsfile.\n\nMoving the Code to the Library\n\nAdding a Step to a library involves creating a file with the name of our Step,\nadding our code to a call() method inside that file,\nand replacing the appropriate code in our Jenkinsfile with the new Step calls.\nLibraries can be set to load \"implicitly,\"\nmaking their default branch automatically available to all Pipelines,\nor they can be loaded manually using a @Library annotation.\nThe branch for implicitly loaded libraries can also be overridden using the @Library annotation.\n\nThe minimal set of dependencies for sendNotifications means we can\nbasically copy-and-paste the code from the original blog post.\nWe’ll check this change into a branch in the library named\nblog/declarative/notifications, the same as my branch in the hermann repository.\nThis will let us make changes on the master branch later without breaking this example.\nWe’ll then use the @Library directive to tell Jenkins to use that branch’s version\nof the library with this Pipeline.\n\nJenkinsfile\n\n// Declarative //\n#!groovy\n@Library('bitwiseman-shared@blog/declarative/notifications') _ (1)\n\npipeline {\n  agent {\n    // Use docker container\n    docker {\n      image 'ruby:2.3'\n    }\n  }\n  options {\n    // Only keep the 10 most recent builds\n    buildDiscarder(logRotator(numToKeepStr:'10'))\n  }\n  stages {\n    stage ('Start') {\n      steps {\n        // send build started notifications\n        sendNotifications 'STARTED'\n      }\n    }\n    stage ('Install') {\n      steps {\n        // install required bundles\n        sh 'bundle install'\n      }\n    }\n    stage ('Build') {\n      steps {\n        // build\n        sh 'bundle exec rake build'\n      }\n\n      post {\n        success {\n          // Archive the built artifacts\n          archive includes: 'pkg/*.gem'\n        }\n      }\n    }\n    stage ('Test') {\n      steps {\n        // run tests with coverage\n        sh 'bundle exec rake spec'\n      }\n\n      post {\n        success {\n          // publish html\n          publishHTML target: [\n              allowMissing: false,\n              alwaysLinkToLastBuild: false,\n              keepAll: true,\n              reportDir: 'coverage',\n              reportFiles: 'index.html',\n              reportName: 'RCov Report'\n            ]\n        }\n      }\n    }\n  }\n  post {\n    always {\n      sendNotifications currentBuild.result\n    }\n  }\n}\n// Scripted //\n\n1\nThe _ here is intentional.\nJava/Groovy Annotations\nsuch as @Library must be applied to an element.\nThat is often a using statement, but that isn’t needed here so by convention we use an \\_.\n\nvars/sendNotifications.groovy\n\n#!/usr/bin/env groovy\n\n/**\n * Send notifications based on build status string\n */\ndef call(String buildStatus = 'STARTED') {\n  // build status of null means successful\n  buildStatus = buildStatus ?: 'SUCCESS'\n\n  // Default values\n  def colorName = 'RED'\n  def colorCode = '#FF0000'\n  def subject = \"${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\"\n  def summary = \"${subject} (${env.BUILD_URL})\"\n  def details = \"\"\" ${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\"\n\n  // Override default values based on build status\n  if (buildStatus == 'STARTED') {\n    color = 'YELLOW'\n    colorCode = '#FFFF00'\n  } else if (buildStatus == 'SUCCESS') {\n    color = 'GREEN'\n    colorCode = '#00FF00'\n  } else {\n    color = 'RED'\n    colorCode = '#FF0000'\n  }\n\n  // Send notifications\n  slackSend (color: colorCode, message: summary)\n\n  hipchatSend (color: color, notify: true, message: summary)\n\n  emailext (\n      to: 'bitwiseman@bitwiseman.com',\n      subject: subject,\n      body: details,\n      recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n    )\n}\n\nConclusion\n\nIn this post we added notifications to our Declarative Pipeline.\nWe wanted to move our repetitive notification code into a method;\nhowever, Declarative Pipeline prevented us from defining a method in our Jenkinsfile.\nInstead, with the help of the Shared Library feature,\nwe were able to define a sendNotifications Step that we could call from our Jenkinsfile.\nThis maintained the clarity of our Pipeline and will let us easily reuse this Step in other projects.\nI was pleased to see how little the resulting Pipeline differed from where we started.\nThe changes were restricted to the start and end of the file with no reformatting elsewhere.\n\nIn the next post, we’ll cover more about shared libraries and how to\nrun Sauce OnDemand with xUnit Reporting in Declarative Pipeline.\n\nLinks\n\nDeclarative Pipeline plugin\n\nDeclarative Pipeline Syntax Reference\n\nShared Library reference\n\nPipeline source for this post\n\nPipeline Shared Library source for this post","title":"Declarative Pipeline: Notifications and Shared Libraries","tags":["tutorial","pipeline","declarative","plugins","notifications","slack","hipchat","emailext"],"authors":[]}},{"node":{"date":"2016-07-18T00:00:00.000Z","id":"523da562-6777-53bd-978f-45ab4cb9092c","slug":"/blog/2016/07/18/pipeline-notifications/","strippedHtml":"This is a guest post by Liam Newman,\nTechnical Evangelist at CloudBees.\n\nRather than sitting and watching Jenkins for job status, I want Jenkins to send\nnotifications when events occur.  There are Jenkins plugins for\nSlack,\nHipChat,\nor even email\namong others.\n\nNote: Something is happening!\n\nI think we can all agree getting notified when events occur is preferable to\nhaving to constantly monitor them just in case.  I’m going to continue from\nwhere I left off in my\nprevious post with the\nhermann project.  I added a Jenkins\nPipeline with an HTML publisher for code coverage. This week, I’d like to make\nJenkins to notify me when builds start and when they succeed or fail.\n\nSetup and Configuration\n\nFirst, I select targets for my notifications. For this blog post, I’ll use sample\ntargets that I control.  I’ve created Slack and HipChat organizations called\n\"bitwiseman\", each with one member - me.  And for email I’m running a Ruby SMTP server called\nmailcatcher, that is perfect for local testing\nsuch as this.  Aside for these concessions, configuration would be much the\nsame in a non-demo situation.\n\nNext, I install and add server-wide configuration for the\nSlack,\nHipChat,\nand Email-ext\nplugins.  Slack and HipChat use API tokens - both products have integration\npoints on their side that generate tokens which I copy into my Jenkins\nconfiguration. Mailcatcher SMTP runs locally. I just point Jenkins\nat it.\n\nHere’s what the Jenkins configuration section for each of these looks like:\n\nOriginal Pipeline\n\nNow I can start adding notification steps. The same as\nlast week, I’ll use the\nJenkins Pipeline Snippet Generator\nto explore the step syntax for the notification plugins.\n\nHere’s the base pipeline before I start making changes:\n\nstage 'Build'\n\nnode {\n  // Checkout\n  checkout scm\n\n  // install required bundles\n  sh 'bundle install'\n\n  // build and run tests with coverage\n  sh 'bundle exec rake build spec'\n\n  // Archive the built artifacts\n  archive (includes: 'pkg/*.gem')\n\n  // publish html\n  // snippet generator doesn't include \"target:\"\n  // https://issues.jenkins.io/browse/JENKINS-29711.\n  publishHTML (target: [\n      allowMissing: false,\n      alwaysLinkToLastBuild: false,\n      keepAll: true,\n      reportDir: 'coverage',\n      reportFiles: 'index.html',\n      reportName: \"RCov Report\"\n    ])\n}\n\nThis pipeline expects to be run from a Jenkinsfile in SCM.\nTo copy and paste it directly into a Jenkins Pipeline job, replace the checkout scm step with\ngit 'https://github.com/reiseburo/hermann.git'.\n\nJob Started Notification\n\nFor the first change, I decide to add a \"Job Started\" notification.  The\nsnippet generator and then reformatting makes this straightforward:\n\nnode {\n\n  notifyStarted()\n\n  /* ... existing build steps ... */\n}\n\ndef notifyStarted() {\n  // send to Slack\n  slackSend (color: '#FFFF00', message: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n  // send to HipChat\n  hipchatSend (color: 'YELLOW', notify: true,\n      message: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n    )\n\n  // send to email\n  emailext (\n      subject: \"STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n      body: \"\"\" STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n      recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n    )\n}\n\nSince Pipeline is a Groovy-based DSL, I can use\nstring interpolation\nand variables to add exactly the details I want in my notification messages. When\nI run this I get the following notifications:\n\nJob Successful Notification\n\nThe next logical choice is to get notifications when a job succeeds.  I’ll\ncopy and paste based on the notifyStarted method for now and do some refactoring\nlater.\n\nnode {\n\n  notifyStarted()\n\n  /* ... existing build steps ... */\n\n  notifySuccessful()\n}\n\ndef notifyStarted() { /* .. */ }\n\ndef notifySuccessful() {\n  slackSend (color: '#00FF00', message: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n  hipchatSend (color: 'GREEN', notify: true,\n      message: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n    )\n\n  emailext (\n      subject: \"SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n      body: \"\"\" SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n      recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n    )\n}\n\nAgain, I get notifications, as expected.  This build is fast enough,\nsome of them are even on the screen at the same time:\n\nJob Failed Notification\n\nNext I want to add failure notification.  Here’s where we really start to see the power\nand expressiveness of Jenkins pipeline.  A Pipeline is a Groovy script, so as we’d\nexpect in any Groovy script, we can handle errors using try-catch blocks.\n\nnode {\n  try {\n    notifyStarted()\n\n    /* ... existing build steps ... */\n\n    notifySuccessful()\n  } catch (e) {\n    currentBuild.result = \"FAILED\"\n    notifyFailed()\n    throw e\n  }\n}\n\ndef notifyStarted() { /* .. */ }\n\ndef notifySuccessful() { /* .. */ }\n\ndef notifyFailed() {\n  slackSend (color: '#FF0000', message: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\")\n\n  hipchatSend (color: 'RED', notify: true,\n      message: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})\"\n    )\n\n  emailext (\n      subject: \"FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\",\n      body: \"\"\" FAILED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\",\n      recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n    )\n}\n\nCode Cleanup\n\nLastly, now that I have it all working, I’ll do some refactoring. I’ll unify\nall the notifications in one method and move the final success/failure notification\ninto a finally block.\n\nstage 'Build'\n\nnode {\n  try {\n    notifyBuild('STARTED')\n\n    /* ... existing build steps ... */\n\n  } catch (e) {\n    // If there was an exception thrown, the build failed\n    currentBuild.result = \"FAILED\"\n    throw e\n  } finally {\n    // Success or failure, always send notifications\n    notifyBuild(currentBuild.result)\n  }\n}\n\ndef notifyBuild(String buildStatus = 'STARTED') {\n  // build status of null means successful\n  buildStatus = buildStatus ?: 'SUCCESS'\n\n  // Default values\n  def colorName = 'RED'\n  def colorCode = '#FF0000'\n  def subject = \"${buildStatus}: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'\"\n  def summary = \"${subject} (${env.BUILD_URL})\"\n  def details = \"\"\" STARTED: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]':\nCheck console output at \" ${env.JOB_NAME} [${env.BUILD_NUMBER}]\"\"\"\"\n\n  // Override default values based on build status\n  if (buildStatus == 'STARTED') {\n    color = 'YELLOW'\n    colorCode = '#FFFF00'\n  } else if (buildStatus == 'SUCCESS') {\n    color = 'GREEN'\n    colorCode = '#00FF00'\n  } else {\n    color = 'RED'\n    colorCode = '#FF0000'\n  }\n\n  // Send notifications\n  slackSend (color: colorCode, message: summary)\n\n  hipchatSend (color: color, notify: true, message: summary)\n\n  emailext (\n      subject: subject,\n      body: details,\n      recipientProviders: [[$class: 'DevelopersRecipientProvider']]\n    )\n}\n\nYou have been notified!\n\nI now get notified twice per build on three different channels.  I’m not sure I\nneed to get notified this much for such a short build.  However, for a longer\nor complex CD pipeline, I might want exactly that.  If needed, I could even\nimprove this to handle other status strings and call it as needed throughout\nmy pipeline.\n\nLinks\n\nSlack Plugin\n\nHipChat Plugin\n\nEmail-ext Plugin\n\nJenkins Pipeline Snippet Generator","title":"Sending Notifications in Pipeline","tags":["tutorial","pipeline","plugins","notifications","slack","hipchat","emailext"],"authors":[]}}]}},"pageContext":{"tag":"slack","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}