{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/gsoc/page/3",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2020-08-09T00:00:00.000Z","id":"babe2cb7-b1f3-538d-a0da-40bd4f32b839","slug":"/blog/2020/08/09/custom-distribution-service-phase-2/","strippedHtml":"Hello everyone,\nIt is time to wrap up another successfull phase for the custom distribution service project,\nand we have incorporated most of the features that we had planned at the start of the phase.\nIt has been an immense learning curve for me and the entire team.\n\nTo understand what the project is about and the past progress, please refer to the phase one blogpost\nhere.\n\nFront-End\n\nFilters for Plugins\n\nIn the previous phase we implemented the ability to add plugins to the configuration,\nand the ability to search these plugins via a search bar.\nSometimes though we would like to filter these plugins based on their usage,\npopularity, stars etc. Hence we have added a certain set of filters to these plugins.\nWe support only four major filters for now. They are:\n\nTitle\n\nMost installed\n\nRelevance\n\nTrending\n\nFilter implementation\n\nThe major heavy lifting is done by the plugin api which takes in the necessary parameters\nand returns the relevant plugins in the form of a json object,\nhere is an example of the api call url: const url = https://plugins.jenkins.io/api/plugins?$params .\n\nFor details, see:\n\nFeature request #9\n\nPull Request #76\n\nCommunity Configurations\n\nOne major deliverable for the project was the ability for users to share the configurations developed by them, so that they can be used widely within the community.\nFor example we see quite a lot of jenkins configurations involve being run on AWS and kubernetes and so on. Therefore it would be really good for the community to have a place to find and run\nthese configurations right out of the box.\n\nDesign Decision\n\nThe major design decision taken here was whether to include the configurations inside\nthe repository or to have them in a completely new repository.\nLet us talk about both these approaches.\n\nHaving the configurations in the current repository:\n\nThis allows us to have all of the relevant configurations inside the repository itself,\nand so users would not have to go fetch this in different repositories.\nWe could have issues with the release cycle and dependencies since,\nit would have to happen along with the custom distribution service project releases.\n\nHaving the configurations in a different repository:\n\nThis allows us to manage all of the configurations and the relevant dependencies separately and easily,\nthus avoiding any release conflict with the current repository.\nHowever it would be a bit difficult if users were to not find this repository.\n\nDecision : We still cannot quite agree on what is the best method so for now,\nI have included the url from which the community configurations are picked up as a\nconfiguration variable in the.env file which can be configured later and\ntherefore it can be up to the user to configure. Another advantage of having it configurable,\nis that the user can decide to load configurations which are private to his organization as well.\n\nFor details, see:\n\nIssue #6161\n\nPull Request #73\n\nBack-End\n\nWar Generation\n\nThe ability to generate and download war files has finally been achieved,\nthe reason this feature took so long to complete is because we had some difficulty\nin implementing the war generation and its tests. However this has been completed\nand can now be tested successfully.\n\nThings to take care while generating war files\n\nIn its current state the war generation cannot include casc.yml or groovy files\nif they are included in the configuration they would have to be added externally.\nThere is an issue opened here.\nThe war file generation would yell at you if you tried to build a war file with a jcasc file configuration.\n\nFor details, see:\n\nIssue #60\n\nPull Request #68\n\nPull Request Creation\n\nThis feature was included in the design document that I created after my GSoC selection.\nIt involves the ability to create pull requests via the front-end of the service.\nThe User Story behind this feature was that If I want to share a configuration with the community and I do not quite know how to use github or I do not want to do it via the terminal.\nThis feature includes creation of a bot that handles the creation of pull requests in the repository.\nThis bot would have to be installed by the jenkins organization in this repository and the bot would handle the rest.\n\nFor details, see:\n\nIssue #59\n\nPull Request #72\n\nDisclaimer:\n\nThis feature has however been put on the back-burner for now because\nwe are focusing on getting the project to be self hosted and therefore\nwould like to implement this once we have a clear path for the project to be hosted by the jenkins-infra team.If you would like to participate in the discussion here are the links for the pull requests,\nPR 1 and link: PR 2, or you can even jump in our gitter channel.\n\nIf you have been following my posts,\nI mentioned in my second week blog post that pulling in the json file consisting of more than\n1600 plugins took a bit more time that my liking.\nWe managed to solve that issue using a caching mechanism,\nso now the files are pulled in the first time you start the service and downloaded in a temporary folder. The next time you want to view the plugin cards they are pulled in directly from the temp directory bam ! thereby reducing time.\n\nFor details see Pull Request #90\n\nFixes and improvements\n\nPort 8080\n\nPort 8080 now does have a message instead of a whitelabel error message which is present\nby default in the spring-boot tomcat server setup.\nTurns out it requires overriding a particular class, and inserting a custom message\n\nFor details, see:\n\nPull Request #92\n\nWar Generation\n\nTill now while you were generating the war file,\nif something went wrong during genration the service would not complain it would just swallow the error and throw back a corrupted war file,\nhowever now we have added an error support feature\nthat will alert you when something goes wrong, the error is not very informative as of now,\nbut we are working on making it more informative in the future.\n\nFor details, see:\n\nWar generation error handling #91\n\nAdd Github controller and jwt helper #66\n\nDockerfile\n\nOne of the major milestones of this phase was to have a project that can be self hosted,\nneedless to say we needed the dockerfile i.e docker-compose.yml to spin the project with a few commands.\nThe major issue we faced here was that there was a bit of a problem making the two containers talk to each other. Let me give you a little bit of context here.\nOur docker-compose is constructed using two separate dockerfiles one for the backend of the service and the other for the front-end.\nThe backend makes api calls to the front-end via the proxy url i.e localhost:8080.\nWe now had to change this since the network bridge between the two containers spoke to each other via the backend-server name i.e app-server.\nTo brige that gap we have this PR that ensured that the docker compose works flawlessly.\n\nFor details, see:\n\nPull Request #82\n\nHowever there is a minor draw-back of the above approach was now the entire\nproject just relied on the docker compose and could not run using the simple\ncombination of npm and maven since the proxy was different.\nIn order to fix this I decided to follow a multiple environment approach,\nwhere we have multiple environment files that pick up the correct proxy and insert it at build time,\nto elaborate further we have two environment files,\n(using the env-cmd library ).env and the docker.env and we insert,\nthe correct file depending on how you want to build the project.\nFor instance if you want to run it using the dockerfile the command that is run under the hood is something along these lines — npm --env-cmd -f docker.env start scripts.\n\nFor details, see:\n\nPull Request #88\n\nOther links\n\nGitter Channel Link\nGSoC Proposal\nDesign Document\nDaily Notes\nDemo","title":"Custom Distribution Service : Phase 2 Blogpost","tags":["service","distribution","cloud-native","gsoc","gsoc2020","packaging","platform-sig"],"authors":[{"avatar":null,"blog":null,"github":"sladyn98","html":"<div class=\"paragraph\">\n<p>Sladyn is a Computer Science student at Mumbai University, India.\nHe is participating in Community Bridge 2019 to provide development tools to JCasC plugin in the form of IDE integrations, schema architecture improvements and configuration extension points <a href=\"https://github.com/jenkinsci/configuration-as-code-plugin\">Configuration as Code Plugin</a>.</p>\n</div>","id":"sladyn98","irc":null,"linkedin":null,"name":"Sladyn Nunes","slug":"/blog/authors/sladyn98","twitter":"SladynN"}]}},{"node":{"date":"2020-08-03T00:00:00.000Z","id":"1a966f1b-f29c-510f-943e-ff264acdf7dd","slug":"/blog/2020/08/03/github-checks-api-plugin-coding-phase-2/","strippedHtml":"Another great coding phase for GitHub Checks API Project ends!\nIn this phase, we focused on consuming the checks API in two widely used plugins:\n\nWarnings NG Plugin\n\nCode Coverage API Plugin\n\nBesides the external usage, we have also split the general checks API from its GitHub implementation and released both of the plugins:\n\nChecks API Plugin\n\nGitHub Checks Plugin\n\nCoding Phase 2 Demo [starts from 25:20]\n\nWarning Checks\n\nThe newly released Warnings NG plugin 8.4.0 will use checks API to publish different check runs for different static analysis tools.\nWithout leaving GitHub, users are now able to see the analysis report they interested in.\n\nOn GitHub’s conversation tab for each PR, users will see summaries for those checks like the screenshot above. The summaries will include:\n\nThe status that indicates the quality gate\n\nThe name of the analysis tool used\n\nA short message that indicates statistics of new and total issues\n\nMore fine-grained statistics can be found in the Details page.\n\nAnother practical feature is the annotation for specific lines of code. Users can now review the code alone with the annotations.\n\nTry It\n\nIn Wanings NG plugin 8.4.0, the warning checks is set as a default feature only for GitHub.\nFor other SCM platforms, a NullPublisher will be used which does nothing.\nTherefore, you can get those checks for your own GitHub project just in a few steps:\n\nUpdate Warnings NG plugin to 8.4.0\n\nInstall GitHub Checks plugin on your Jenkins instance\n\nFollow the GitHub app authentication guide to configure the credentials for the multi-branch project or GitHub organization project you are going to use\n\nUse warnings-ng plugin in your Jenkinsfile for the project you configured in the last step, e.g.\n\nnode {\n    stage ('Checkout') {\n        checkout scm\n    }\n\n    stage ('Build and Static Analysis') {\n        sh 'mvn -V -e clean verify -Dmaven.test.failure.ignore'\n\n        recordIssues tools: [java(), javaDoc()], aggregatingResults: 'true', id: 'java', name: 'Java'\n        recordIssues tool: errorProne(), healthy: 1, unhealthy: 20\n        recordIssues tools: [checkStyle(pattern: 'target/checkstyle-result.xml'),\n            spotBugs(pattern: 'target/spotbugsXml.xml'),\n            pmdParser(pattern: 'target/pmd.xml'),\n            cpd(pattern: 'target/cpd.xml')],\n            qualityGates: [[threshold: 1, type: 'TOTAL', unstable: true]]\n    }\n}\n\nFor more about the pipeline usage of warnings-ng plugin, please see the official documentation.\n\nHowever, if you don’t want to publish the warnings to GitHub, you can either uninstall the GitHub Checks plugin or disable it by adding skipPublishingChecks: true.\n\nrecordIssues enabledForFailure: true, tools: [java(), javaDoc()], skipPublishingChecks: true\n\nCoverage Checks\n\nThe coverage checks are achieved by consuming the API in Code Coverage API plugin.\nFirst, in the conversation tab of a PR, users will be able to see the summary about the coverage difference compared to previous builds.\n\nThe Details page will contain some other things:\n\nLinks to the reference build, including the target branch build from the master branch and the last successful build from this branch\n\nCoverage healthy score (the default value is 100% if the threshold is not configured)\n\nCoverages and trends of different types in table format\n\nThe pull request for this feature will soon be merged and will be included in the next release of Coverage Checks API plugin. After that, you can use it by adding the below section to your pipeline script:\n\nnode {\n    stage ('Checkout') {\n        checkout scm\n    }\n\n    stage ('Line and Branch Coverage') {\n        publishCoverage adapters: [jacoco('**/*/jacoco.xml')], sourceFileResolver: sourceFiles('STORE_ALL_BUILD')\n    }\n}\n\nLike the warning checks, you can also disable the coverage checks by setting the field skipPublishingChecks, e.g.\n\npublishCoverage adapters: [jacoco('**/*/jacoco.xml')], sourceFileResolver: sourceFiles('STORE_ALL_BUILD'), skipPublishingChecks: true\n\nNext Phase\n\nIn the next phase, we will turn our attention back to Checks API Plugin and GitHub Checks Plugin and add the following features in future versions:\n\nPipeline Support\n\nUsers can publish checks directly in a pipeline script without requiring a consumer plugin that supports the checks.\n\nRe-run Request\n\nUsers can re-run Jenkins build through Checks API.\n\nLastly, it is exciting to inform that we are currently making the checks feature available on ci.jenkins.io for all plugins hosted in the jenkinsci GitHub organization, please see INFRA-2694 for more details.\n\nResources\n\nChecks API Plugin\n\nGitHub Checks Plugin\n\nProject Page\n\nGitter Channel","title":"GitHub Checks API Plugin Project - Coding Phase 2","tags":["github","api","plugins","developer","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg","srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/77b35/XiongKezhi.jpg 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/d4a57/XiongKezhi.jpg 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/68974/XiongKezhi.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/ef6ff/XiongKezhi.webp 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/8257c/XiongKezhi.webp 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/6766a/XiongKezhi.webp 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/22bfc/XiongKezhi.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"XiongKezhi","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 Student. Kezhi is an open source enthusiast who enjoys sharing ideas with other developers. He started contributing to Jenkins in March 2020. Currently, he is working on <a href=\"https://github.com/XiongKezhi/checks-api-plugin\">GitHub Checks API Plugin</a>.</p>\n</div>","id":"XiongKezhi","irc":null,"linkedin":"kezhi-xiong-44234a188","name":"Kezhi Xiong","slug":"/blog/authors/xiongkezhi","twitter":"AugustX_"}]}},{"node":{"date":"2020-07-29T00:00:00.000Z","id":"84676949-9b05-55b1-b843-435c0ff0696d","slug":"/blog/2020/07/29/git-performance-improvement-phase2/","strippedHtml":"The second phase of the Git Plugin Performance Improvement project has been great in terms of the progress we have achieved in implementing performance improvement insights\nderived from the phase one JMH micro-benchmark experiments.\n\nWhat we’ve learned so far in this project is that a git fetch is highly correlated to the size of the remote repository. In order to make fetch improvements in this plugin, our task was to find the difference in performance for the two available git implementations in the Git Plugin, git and JGit.\n\nOur major finding was that git performs much better than JGit when it comes to a large sized repository (>100 MiB). Interestingly, JGit performs better than git when size of the repository is less than 100 MiB.\n\nIn this phase, we were successful in coding this derived knowledge from the benchmarks into a new functionality called the\nGitToolChooser.\n\nGitToolChooser\n\nThis class aims to add the functionality of recommending a git implementation on the basis of the size of a repository which has a strong correlation to the performance of git fetch (from performance Benchmarks).\n\nIt utilizes two heuristics to calculate the size:\n\nUsing cached .git dir from multibranch projects to estimate the size of a repository\n\nProviding an extension point which, upon implementation, can use REST APIs exposed by git service providers like Github, GitLab, etc to fetch the size of the remote repository.\n\nWill it optimize your Jenkins instance?\nThat requires one of the following:\n\nyou have a multibranch project in your Jenkins instance, the plugin can use that to recommend the optimal git implementation\n\nyou have a branch Source Plugin installed in the Jenkins instance, the particular branch source plugin will recommend a git implementation using REST APIs provided by GitHub or GitLab respectively.\n\nThe architecture and code for this class is at: PR-931\n\nNote : This functionality is an upcoming feature in the subsequent Git Plugin release.\n\nJMH benchmarks in multiple environments\n\nThe benchmarks were being executed on Linux and macOS machines frequently but there was a need to check if the results gained from those benchmarks would hold true across more platforms to ensure that the solution (GitToolChooser) is generally platform-agnostic.\n\nTo test this hypothesis, we performed an experiment:\n\nRunning git fetch operation for a 400 MiB sized repository on:\n\nWindows\n\nFreeBSD 12\n\nppc64le\n\ns390x\n\nThe result of running this experiment is given below:\n\nObservations:\n\nppc64le and s390x are able to run the operation in almost half the time it takes for the Windows or FreeBSD 12 machine. This behavior may be attributed to the increased computational power of those machines.\n\nThe difference in performance between git and JGit remains constant across all platforms which is a positive sign for the GitToolChooser as its recommendation would be consistent across multiple devices and operating systems.\n\nRelease Plan 🚀\n\nJENKINS-49757 - Avoid double fetch from Git checkout step\nThis issue was fixed in phase one, avoids the second fetch in redundant cases.\nIt will be shipped with some benchmarks on the change in performance due to the removal of the second fetch.\n\nPR-574\n\nPR-904\n\nGitToolChooser\n\nPR-931\nThis pull request is under review, will be shipped in one of the subsequent Git Plugin releases.\n\nCurrent Challenges with GitToolChooser\n\nImplement the extension point to support GitHub Branch Source Plugin, Gitlab Branch Source Plugin and Gitea Plugin.\n\nThe current version of JGit doesn’t support LFS checkout and sparse checkout, need to make sure that the recommendation doesn’t break existing use cases.\n\nFuture Work\n\nIn phase three, we wish to:\n\nRelease a new version of the Git and Git Client Plugin with the features developed during the project\n\nContinue to explore more areas for performance improvement\n\nAdd a new git operation: git clone (Stretch Goal)\n\nReaching Out\n\nFeel free to reach out to us for any questions or feedback on the project’s Gitter Channel or the Jenkins\nDeveloper Mailing list.\n\nProject Page\n\nPhase 1 Blog Post","title":"Git Plugin Performance Improvement Phase-2 Progress","tags":["plugins","git","platform-sig","developer","performance","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#685848","images":{"fallback":{"src":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg","srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/77b35/rishabhbudhouliya.jpg 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/d4a57/rishabhbudhouliya.jpg 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/68974/rishabhbudhouliya.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/ef6ff/rishabhbudhouliya.webp 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/8257c/rishabhbudhouliya.webp 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/6766a/rishabhbudhouliya.webp 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/22bfc/rishabhbudhouliya.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"rishabhBudhouliya","html":"<div class=\"paragraph\">\n<p>GSoC 2020 student under the Jenkins project (Git Plugin Performance Improvements).\nAspiring to be better at Software Development and participate more in the open source\ncommunity.</p>\n</div>","id":"rishabhbudhouliya","irc":null,"linkedin":null,"name":"Rishabh Budhouliya","slug":"/blog/authors/rishabhbudhouliya","twitter":null}]}},{"node":{"date":"2020-07-27T00:00:00.000Z","id":"28af9b14-9cf1-5cb2-94df-b2869b9e73fc","slug":"/blog/2020/07/27/custom-distribution-service/","strippedHtml":"Hello,\nAfter an eventful community bonding period we finally entered into the coding phase. This blog post will summarize the work done till the midterm of the coding phases i.e. week 6. If some of the topics here require a more detailed explanation, I will write a separate blog post. These blogs posts will not have a very defined format but would cover all of the user stories or features implemented.\n\nProject Summary\n\nThe main idea behind the project is to build a customizable jenkins distribution service that could be used to build tailor-made jenkins distributions. The service would provide users with a simple interface to select the configurations they want to build the instance with eg: plugins, authorization matrices etc. Furthermore it would include a section for sharing community created distros so that users can find and download already built jenkins war/configuration files to use out of the box.\n\nQuick review\n\nPull Requests Opened\n38\n\nGithub Issues completed\n36\n\nDetails\n\nI have written separate blog posts for every week in GSoC and the intricate details for each of them can be found at their respective blog pages. I am including a summary for every phase supported with the respective links.\n\nCommunity Bonding\n\nThis year GSoC had a longer community bonding than any of the previous editions due to the Coronavirus pandemic and therefore this gave me a lot of time to explore, so I spent it by building a prototype for my project. I realised some of the blockages I might face early on, and therefore it gave me more clarity in terms of how I can proceed. I also spent this time preparing a design document which you can find here.\n\nCommunity Bonding Blog\n\nWeek 1\n\nIn week one, I spent time getting used to the tech stack I would be using, I was pretty familiar with Spring Boot but React was something I was going to be using for the first time, so I spent time studying more about it. I also got the project page ready, the issues I was going to tackle and the milestones that I had to achieve before the evaluation. I also spent a bit of time setting up the home page and a bit of front-end components.\n\nWeek 1 Blog\n\nWeek 2\n\nOnce we were done with the initial setup, it was time to work on the core of the project.\nIn the second week, I worked on generating the package configuration and the plugin list dummy display page setup.\nI also ran into issues with the Jenkinsfile so the majority of time was spent fixing it.\nFinally I managed to get around those problems.\nYou can read more about it in the Week 2 Blog post.\n\nWeek 2 Blog\n\nWeek 3\n\nThe last week was spent cleaning up most of the code and getting the remaining milestones in. This was probably the hardest part of phase 1 because it involved connecting the front and back end of the project.You can read more about it here.\n\nWeek 3\n\nMidterm Update\n\nThe second phase has been going on for the past 3 weeks and we have already accomplished a majority of the deliverables including community configurations, war downloading and filtering of plugins. More details about the mid term report can be found here.\n\nMidterm Update\n\nGetting the Code\n\nThe Custom Distribution Service was created from scratch during GSoC and can be found here on Github.\n\nOther links\n\nGSoC Proposal\nDesign Document\nDaily Notes\nDemo\n\nFeedback channel\n\nGitter Channel Link.","title":"Custom Distribution Service : Midterm Summary","tags":["service","distribution","cloud-native","gsoc","gsoc2020","packaging","platform-sig"],"authors":[{"avatar":null,"blog":null,"github":"sladyn98","html":"<div class=\"paragraph\">\n<p>Sladyn is a Computer Science student at Mumbai University, India.\nHe is participating in Community Bridge 2019 to provide development tools to JCasC plugin in the form of IDE integrations, schema architecture improvements and configuration extension points <a href=\"https://github.com/jenkinsci/configuration-as-code-plugin\">Configuration as Code Plugin</a>.</p>\n</div>","id":"sladyn98","irc":null,"linkedin":null,"name":"Sladyn Nunes","slug":"/blog/authors/sladyn98","twitter":"SladynN"}]}},{"node":{"date":"2020-07-27T00:00:00.000Z","id":"0b676e9e-8bca-5401-ad70-50c30452b445","slug":"/blog/2020/07/27/machine-learning-plugin-coding-phase2/","strippedHtml":"Welcome back folks!\n\nThis blog post is about my coding phase 2 in Jenkins Machine Learning Plugin for this GSoC 2020.\nAfter successfully passing the evaluation and demo in the phase 1, our team went ahead for facing the challenges in phase 2.\n\nSummary\n\nThis phase of coding was well spent by documentation and by fixing many bugs.\nAs the main feature of connecting to an IPython Kernel is done in phase 1, we were able to focus on fixing minor/major bugs and documenting for the users.\nAccording to the JENKINS-62927 issue, a Docker agent was built to facilitate users without concerning plugin dependencies in python.\nIn the act of deprecation of Python 2, we ported our plugin to support Python 3.\nWe have tested our plugin in Conda, venv and Windows environments.\nMachine learning plugin has successfully passed the end to end test. A feature for a code editor is needed for further discussion/analysis as we have done a simple editor that may be useful in other ways in the future. PR#35\n\nMain features of Machine Learning plugin\n\nRun Jupyter notebook, (Zeppelin) JSON and Python files\n\nRun Python code directly\n\nConvert Jupyter Notebooks to Python and JSON\n\nConfigure IPython kernel properties\n\nSupport to execute Notebooks/Python on Agent\n\nSupport for Windows and Linux\n\nUpcoming features\n\nExtract graph/map/images from the code\n\nSave artifacts according to the step name\n\nGenerate reports for corresponding build\n\nFuture improvements\n\nUsage of JupyterRestClient\n\nSupport for multiple language kernels\n\nNote : There is no commitment on future improvements during GSoC period\n\nDocker agent\n\nThe following Dockerfile can be used to build the Docker container as an agent for the Machine Learning plugin. This docker agent can be used to run  notebooks or python scripts.\n\nDockerfile\n\nFROM jenkins/agent:latest\n\nMAINTAINER Loghi\n\nUSER root\n\nRUN apt update && apt install --no-install-recommends python3 -y \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\nCOPY requirements.txt /requirements.txt\n\nRUN pip3 install --upgrade pip setuptools && \\\n    pip3 install --no-cache-dir -r /requirements.txt && \\\n    ln -sf /usr/bin/python3 /usr/bin/python && \\\n    ln -sf /usr/bin/pip3 /usr/bin/pip\n\nUSER jenkins\n\nPorted to Python 3\n\nAs discussed in the previous meeting, we concluded that the plugin should support Python 3 as Python 2.7+ has been deprecated since the beginning of 2020. Pull request for docker agent should be also ported to Python 3 support.\n\nJupyter Rest Client API\n\nThe Jupyter Notebook server API seemed to be promising that it can be also used to run notebooks and codes. There were 3 api implementations that were merged in the master. But we had to focus on what was proposed in the design document and had to finish all must-have issues/works. Jupyter REST client was left for future implementation. It is also a good start to contribute to the plugin from the community.\n\nFixed bugs for running in agent\n\nThere were a few bugs related to the file path of notebooks while building a job. The major problem was caused by the python dependencies needed to connect to a IPython kernel. All issues/bugs were fixed before the timeline given.\n\nR support as a future improvement\n\nThis is what we tried to give a glimpse of knowledge that this plugin can be extended for multi language support in the future. There was a conclusion that the kernel should be selected dynamically using extension of the script file(like eval_model.rb or train_model.r), instead of scripting the same code for each kernel.\n\nDocumentation and End to End testing\n\nA well explained documentation was published in the repository. A guided tutorial to run a notebook checked out from a git repo in an agent was included in the docs page. Mentors helped to test our plugin in both Linux and Windows.\n\nCode editor with rebuild feature\n\nCode editor was filtered as a nice to have feature in the design document. After grabbing the idea of Jenkinsfile replay editor, I could do the same for the code. At the same time, when we are getting the source code from git, it is not an elegant way of editing code in the original code. After the discussion, we had to leave the PR open that may have use cases in the future if needed.\n\nJenkins LTS update\n\nThe plugin has been updated to support Jenkins LTS 2.204.1 as 2.164.3 had some problems with installing pipeline supported API/plugin\n\nInstallation for experimental version\n\nEnable the experimental update center\n\nSearch for Machine Learning Plugin and check the box along it.\n\nClick on Install without restart\n\nThe plugin should now be installed on your system.\n\nResources\n\nCommunity Bonding blog post\n\nPhase 1 blog post\n\nGithub\n\nProject page\n\nDesign document","title":"Machine Learning Plugin project - Coding Phase 2 blog post","tags":["machinelearning","datascience","plugins","communitybonding","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/63ad2/loghijiaha.jpg","srcSet":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/9b030/loghijiaha.jpg 32w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/f38b5/loghijiaha.jpg 64w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/63ad2/loghijiaha.jpg 128w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/bcd2b/loghijiaha.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/ceea6/loghijiaha.webp 32w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/45b82/loghijiaha.webp 64w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/933cd/loghijiaha.webp 128w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/6c13d/loghijiaha.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":158}}},"blog":null,"github":"loghijiaha","html":"<div class=\"paragraph\">\n<p>Computer Science and Engineering Student at University of Moratuwa, Sri Lanka. He has been selected for Machine Learning plugin for Data Science in GSoC 2020 for Jenkins project. Hightly interested and contributing on open source projects.</p>\n</div>","id":"loghijiaha","irc":null,"linkedin":"loghi","name":"Loghi Perinpanayagam","slug":"/blog/authors/loghijiaha","twitter":"loghi5"}]}},{"node":{"date":"2020-07-24T00:00:00.000Z","id":"4bb5ba32-d613-5603-8d83-2dabce9481fa","slug":"/blog/2020/07/24/external-fingerprint-storage-phase-2/","strippedHtml":"As another great phase for the\nExternal Fingerprint Storage Project\ncomes to an end, we summarise the work done during this phase in this blog post.\nIt was an exciting and fruitful journey, just like the previous phase, and offered some great learning experience.\n\nTo understand what the project is about and the past progress, please refer to the\nphase 1 blog post.\n\nNew Stories Completed\n\nWe targeted four stories in this phase, namely fingerprint cleanup, fingerprint migration, refactoring the current\nimplementation to use descriptors, and improved testing of the Redis Fingerprint Storage Plugin.\nWe explain these stories in detail below.\n\nFingerprint Cleanup\n\nhttps://github.com/jenkinsci/jenkins/pull/4817\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/23\n\nThis story involved extending the FingerprintStorage API to allow external storage plugins to perform and configure\ntheir own fingerprint cleanup strategies.\nWe added the following functionalities to Jenkins core API:\n\nFingerprintStorage#iterateAndCleanupFingerprints(TaskListener taskListener)\n\nThis allows external fingerprint storage implementations to implement their own custom fingerprint cleanup.\nThe method is called periodically by Jenkins core.\n\nFingerprintStorage#cleanFingerprint(Fingerprint fingerprint, TaskListener taskListener)\n\nThis is a reference implementation which can be called by external storage plugins to clean up a fingerprint.\nIt is upto the plugin implementation to decide whether to use this method.\nThey may choose to write a custom implementation.\n\nWe consume these new API functionalities in the\nRedis Fingerprint Storage plugin.\nThe plugin uses cursors to traverse the fingerprints, updating the build information, and deleting the build-less\nfingerprints.\n\nEarlier, fingerprint cleanup was always run periodically and there was no way to turn it off.\nWe also added an option to allow the user to turn off fingerprint cleanup.\n\nThis was done because it may be the case that keeping redundant fingerprints in memory might be cheaper than the\ncleanup operation (especially in the case of external storages, which are cheaper these days).\n\nFingerprint Migration\n\nhttps://github.com/jenkinsci/jenkins/pull/4825\n\nEarlier, there was no support for fingerprints stored in the local storage.\nIn this phase, we introduce migration support for users.\nThe old fingerprints are now migrated to the new configured external storage whenever they are used (lazy migration).\nThis allows gradual migration of old fingerprints from local disk storage to the new external storage.\n\nRefactor FingerprintStorage to use descriptors\n\nhttps://github.com/jenkinsci/jenkins/pull/4834\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/36\n\nEarlier, whenever an external fingerprint storage plugin was installed, it was enabled by default.\nWe refactored the implementation to make use of Descriptor pattern so the fingerprint engine can now be selected\nas a dropdown from the Jenkins configuration page.\nThe dropdown is shown only when multiple fingerprint storage engines are configured on the system.\nRedis Fingerprint Storage Plugin was refactored\nto use this new implementation.\n\nStrengthened testing for the Redis Fingerprint Storage Plugin\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/33\n\nWe introduced new connection tests in the\nRedis Fingerprint Storage Plugin.\nThese tests allow testing of cases like slow connection, breakage of connection to Redis, etc.\nThese were implemented using the Toxiproxy module inside Testcontainers.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/31\n\nWe introduced test for Configuration-as-code (JCasC) compatibility with the plugin.\nThe documentation for configuring the plugin using JCasC was also added.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/39\n\nWe introduced a suite of authentication tests, to verify the proper working of the Redis authentication system.\nAuthentication uses the credentials plugin.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/32\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/36\n\nWe strengthened our web UI testing to ensure that the configuration page for the plugin works properly as planned.\n\nOther miscellaneous tasks\n\nPlease refer to the Jira Epic for this phase.\n\nReleases 🚀\n\nChanges in the Jenkins core (except migration) were released in Jenkins 2.248.\n\nWe drafted 1.0-rc-1\nrelease for the Redis Fingerprint Storage Plugin\nto deliver the changes.\nThis was an increment from the alpha release\nwe had drafted at the end of the previous phase.\nThe plugin is now available at https://plugins.jenkins.io/redis-fingerprint-storage/!\n\nTrying out the new features!\n\nThe latest release for the plugin can be downloaded from the update center, instructions for which can be\nfound in the README\nof the plugin.\nWe appreciate you trying out the plugin, and welcome any suggestions, feature requests, bug reports, etc.\n\nAcknowledgements\n\nThe Redis Fingerprint Storage plugin is built and maintained by the Google Summer of Code (GSoC) Team for\nExternal Fingerprint Storage for\nJenkins. Special thanks to Oleg Nenashev,\nAndrey Falko, Mike Cirioli,\nTim Jacomb, and the entire Jenkins community for all the contribution to this project.\n\nFuture Work\n\nSome of the topics we aim to tackle in the next phase include a new reference implementation (possibly backed\nby PostgreSQL), tracing, etc.\n\nReaching Out\n\nFeel free to reach out to us for any questions, feedback, etc. on the project’s Gitter Channel or the Jenkins\nDeveloper Mailing list.\nWe use Jenkins Jira to track issues.\nFeel free to file issues under redis-fingerprint-storage-plugin component.\n\nOther Links\n\nRedis Fingerprint Storage Plugin\n\nIssue Tracker for Phase 2\n\njep:226[]\n\nGitter Channel\n\nProject Page\n\nPhase 1 Blog Post","title":"External Fingerprint Storage Phase-2 Updates","tags":["plugins","fingerprint","cloud-native","external-storage","developer","redis","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#281818","images":{"fallback":{"src":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/19e71/stellargo.jpg","srcSet":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/77b35/stellargo.jpg 32w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/d4a57/stellargo.jpg 64w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/19e71/stellargo.jpg 128w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/ef6ff/stellargo.webp 32w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/8257c/stellargo.webp 64w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/6766a/stellargo.webp 128w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":"https://medium.com/@sumitsarinofficial","github":"stellargo","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 student. Sumit is an engineering student (senior) at Netaji Subhas Institute of Technology, University of Delhi. He started his journey of contributing to Jenkins in December 2019. His tiny contribution revolved around the Jenkins Fingerprint engine. He is currently working on building <a href=\"https://www.jenkins.io/projects/gsoc/2020/projects/external-fingerprint-storage\">External Fingerprint Storage for Jenkins</a>.</p>\n</div>","id":"stellargo","irc":null,"linkedin":"sumit-sarin","name":"Sumit Sarin","slug":"/blog/authors/stellargo","twitter":null}]}},{"node":{"date":"2020-07-09T00:00:00.000Z","id":"615c1ac2-c3da-5001-be28-908ac6008d94","slug":"/blog/2020/07/09/git-performance-improvement-phase1/","strippedHtml":"Git Plugin Performance Improvement is a Google Summer of Code 2020 project.\nIt aims to improve the performance of the git plugin, which provides fundamental git functionalities.\n\nInternally, the plugin provides these functionalities using two implementations: command line git and JGit (pure java implementation).\n\nCLI git is the default implementation for the plugin, a user can switch to JGit if needed\n\nThe project is divided into two parallel stages:\n\nStage 1 : Create benchmarks which evaluate the execution time of a git operation provided by CLI git and JGit using JMH, a micro benchmarking test harness.\n\nStage 2 : Implement the insights gained from the analysis into the plugin to improve the overall performance of the plugin.\n\nThe project also aims to fix any existing performance bottlenecks within the plugin as well.\n\nBenchmarks\n\nThe benchmarks are written using JMH. It was introduced in a GSoC 2019 project to Jenkins.\n\nJMH is provided within the plugin through the Jenkins Unit Test Harness POM dependency.\n\nThe JMH benchmarks are created and run within the git client plugin\n\nDuring phase-1, we have created benchmarks for two operations: \"git fetch\" and \"git ls-remote\"\n\nResults and Analysis\n\nThe benchmark analysis for git fetch:\n\nGit fetch results\n\nThe performance of git fetch (average execution time/op) is strongly correlated to the size of a repository\n\nThere exists an inflection point on the scale of repository size after which the nature of JGit performance changes (it starts to degrade)\n\nAfter running multiple benchmarks, it is safe to say that for a large sized repository CLI-git would be a better choice of implementation.\n\nWe can use this insight to implement a feature which avoids JGit when it comes to large repositories.\n\nPlease refer to PR-521 for an elaborate explanation on these results\n\nNote: Repository size means du -h .git\n\nFixing redundant fetch issue\n\nThe git plugin performs two fetch operations instead of one while performing a fresh checkout of a remote git repository.\n\nTo fix this issue, we had to safely remove the second fetch keeping multiple use-cases in mind. The fix itself was not difficult to code, but to do that safely without breaking any existing use-case was a challenging task.\n\nFurther Plan\n\nAfter consolidating a benchmarking strategy during Phase 1, the next steps will be:\n\nProvide functionality to the git plugin, which enables it to estimate the size of the repository without cloning it.\n\nBroaden the scope of benchmarking strategy\n\nConsider parameters like number of branches, references and commit history to find a relation with the performance of a git operation\n\nThe git plugin depends on other plugins like Credentials which might require benchmarking the plugin itself and the effects of these external dependencies on the plugin’s performance\n\nFocus on other use-cases of the plugin\n\nFor phase-1, I focused on the checkout step and the operations involved with it\n\nFor the next phase, the focus will shift to other areas like Multibranch pipelines or Organisation Folders\n\nHow can you help?\n\nIf you have reached this far of the blog, you might be interested in the project.\n\nTo help, you can\n\nReview the benchmarks in the benchmarks module\n\nAnalyse the benchmarks results available on ci.jenkins.io [soon]\n\nCome visit our Gitter channel: https://gitter.im/jenkinsci/git-plugin","title":"Git Plugin Performance Improvement: Phase-1","tags":["plugins","git","platform-sig","developer","performance","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#685848","images":{"fallback":{"src":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg","srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/77b35/rishabhbudhouliya.jpg 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/d4a57/rishabhbudhouliya.jpg 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/68974/rishabhbudhouliya.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/ef6ff/rishabhbudhouliya.webp 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/8257c/rishabhbudhouliya.webp 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/6766a/rishabhbudhouliya.webp 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/22bfc/rishabhbudhouliya.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"rishabhBudhouliya","html":"<div class=\"paragraph\">\n<p>GSoC 2020 student under the Jenkins project (Git Plugin Performance Improvements).\nAspiring to be better at Software Development and participate more in the open source\ncommunity.</p>\n</div>","id":"rishabhbudhouliya","irc":null,"linkedin":null,"name":"Rishabh Budhouliya","slug":"/blog/authors/rishabhbudhouliya","twitter":null}]}},{"node":{"date":"2020-07-09T00:00:00.000Z","id":"f26945c7-7d59-55b5-84e1-9d4e82638d84","slug":"/blog/2020/07/09/github-checks-api-plugin-coding-phase-1/","strippedHtml":"This blog post is about our coding phase 1 progress on GSoC project: GitHub Checks API Plugin.\n\nThe GitHub Checks API is a highly customized way to integrate CI tools to make reports for pull-requests (PRs).\nIt allows users to see CI reports on GitHub pages directly.\n\nFigure 1. GitHub Check Run Screenshot from GitHub Docs\n\nWhat’s more exciting is that it can leave annotations on specific lines of code, just as the comments people left while reviewing.\n\nFigure 2. Check Run Annotation Screenshot from GitHub Docs\n\nWhile on Jenkins' side, the source code view provided by Warnings Next Generation Plugin does pretty much the same thing.\n\nFigure 3. Source Code View from Warnings Next Generation Plugin\n\nUtilizing such features through GitHub Checks API, it would make Jenkins more convenient to GitHub users.\n\nFeatures from Coding Phase 1\n\nIn the past month, our team was mostly working on the general checks API and an implementation for GitHub checks API.\n\nGitHub Checks API Plugin Demo [starts from 50:15]\n\nGeneral Checks API\n\nAlthough the general checks API is developed based on the semantic meaning of GitHub Checks API, we still want to prepare it for similar concepts on other platforms like Commit Status API from GitLab.\nContributions for implementations on these platforms will be welcomed in the future.\n\nGitHub Checks API Implementation\n\nOur work on supporting GitHub Checks API is mostly done by now.\nBesides, we implemented a consumer to automatically create a check run that simply indicates the current stage of a Jenkins build.\nAfter the release, Jenkins developers (especially publisher plugin ones) can create their own GitHub checks for a GitHub branch source project by consuming our API.\n\nExample: To create a check run like:\n\nConsumers need to use our API in this way:\n\nChecksDetails details = new ChecksDetailsBuilder()\n        .withName(\"Jenkins\")\n        .withStatus(ChecksStatus.COMPLETED)\n        .withDetailsURL(\"https://ci.jenkins.io\")\n        .withStartedAt(LocalDateTime.now(ZoneOffset.UTC))\n        .withCompletedAt(LocalDateTime.now(ZoneOffset.UTC))\n        .withConclusion(ChecksConclusion.SUCCESS)\n        .withOutput(new ChecksOutputBuilder()\n                .withTitle(\"Jenkins Check\")\n                .withSummary(\"# A Successful Build\")\n                .withText(\"## 0 Failures\")\n                .withAnnotations(Arrays.asList(\n                        new ChecksAnnotationBuilder()\n                                .withPath(\"Jenkinsfile\")\n                                .withLine(1)\n                                .withAnnotationLevel(ChecksAnnotationLevel.NOTICE)\n                                .withMessage(\"say hello to Jenkins\")\n                                .withStartColumn(0)\n                                .withEndColumn(20)\n                                .withTitle(\"Hello Jenkins\")\n                                .withRawDetails(\"a simple echo command\")\n                                .build(),\n                        new ChecksAnnotationBuilder()\n                                .withPath(\"Jenkinsfile\")\n                                .withLine(2)\n                                .withAnnotationLevel(ChecksAnnotationLevel.WARNING)\n                                .withMessage(\"say hello to GitHub Checks API\")\n                                .withStartColumn(0)\n                                .withEndColumn(30)\n                                .withTitle(\"Hello GitHub Checks API\")\n                                .withRawDetails(\"a simple echo command\")\n                                .build()))\n                .build())\n        .withActions(Collections.singletonList(\n                new ChecksAction(\"formatting\", \"format code\", \"#0\")))\n        .build();\n\nChecksPublisher publisher = ChecksPublisherFactory.fromRun(run);\npublisher.publish(details);\n\nFuture Works\n\nThe next step is integrating our API into Warnings Next Generation Plugin and Code Coverage API Plugin consume our API.\nAfter that, pipeline support will be added: users can publish checks directly in a pipeline script without requiring a consumer plugin that support the checks.\n\nResources\n\nGitHub Repository\n\nProject Page\n\nGitter Channel\n\nReferences\n\nGitHub Doc: Creating CI tests with the Checks API\n\nWarnings Next Generation Plugin: Source Code View","title":"GitHub Checks API Plugin Project - Coding Phase 1","tags":["github","api","plugins","developer","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg","srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/77b35/XiongKezhi.jpg 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/d4a57/XiongKezhi.jpg 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/68974/XiongKezhi.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/ef6ff/XiongKezhi.webp 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/8257c/XiongKezhi.webp 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/6766a/XiongKezhi.webp 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/22bfc/XiongKezhi.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"XiongKezhi","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 Student. Kezhi is an open source enthusiast who enjoys sharing ideas with other developers. He started contributing to Jenkins in March 2020. Currently, he is working on <a href=\"https://github.com/XiongKezhi/checks-api-plugin\">GitHub Checks API Plugin</a>.</p>\n</div>","id":"XiongKezhi","irc":null,"linkedin":"kezhi-xiong-44234a188","name":"Kezhi Xiong","slug":"/blog/authors/xiongkezhi","twitter":"AugustX_"}]}}]}},"pageContext":{"tag":"gsoc","limit":8,"skip":16,"numPages":9,"currentPage":3}},
    "staticQueryHashes": ["3649515864"]}