{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/plugins/page/2",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2020-07-29T00:00:00.000Z","id":"84676949-9b05-55b1-b843-435c0ff0696d","slug":"/blog/2020/07/29/git-performance-improvement-phase2/","strippedHtml":"The second phase of the Git Plugin Performance Improvement project has been great in terms of the progress we have achieved in implementing performance improvement insights\nderived from the phase one JMH micro-benchmark experiments.\n\nWhat we’ve learned so far in this project is that a git fetch is highly correlated to the size of the remote repository. In order to make fetch improvements in this plugin, our task was to find the difference in performance for the two available git implementations in the Git Plugin, git and JGit.\n\nOur major finding was that git performs much better than JGit when it comes to a large sized repository (>100 MiB). Interestingly, JGit performs better than git when size of the repository is less than 100 MiB.\n\nIn this phase, we were successful in coding this derived knowledge from the benchmarks into a new functionality called the\nGitToolChooser.\n\nGitToolChooser\n\nThis class aims to add the functionality of recommending a git implementation on the basis of the size of a repository which has a strong correlation to the performance of git fetch (from performance Benchmarks).\n\nIt utilizes two heuristics to calculate the size:\n\nUsing cached .git dir from multibranch projects to estimate the size of a repository\n\nProviding an extension point which, upon implementation, can use REST APIs exposed by git service providers like Github, GitLab, etc to fetch the size of the remote repository.\n\nWill it optimize your Jenkins instance?\nThat requires one of the following:\n\nyou have a multibranch project in your Jenkins instance, the plugin can use that to recommend the optimal git implementation\n\nyou have a branch Source Plugin installed in the Jenkins instance, the particular branch source plugin will recommend a git implementation using REST APIs provided by GitHub or GitLab respectively.\n\nThe architecture and code for this class is at: PR-931\n\nNote : This functionality is an upcoming feature in the subsequent Git Plugin release.\n\nJMH benchmarks in multiple environments\n\nThe benchmarks were being executed on Linux and macOS machines frequently but there was a need to check if the results gained from those benchmarks would hold true across more platforms to ensure that the solution (GitToolChooser) is generally platform-agnostic.\n\nTo test this hypothesis, we performed an experiment:\n\nRunning git fetch operation for a 400 MiB sized repository on:\n\nWindows\n\nFreeBSD 12\n\nppc64le\n\ns390x\n\nThe result of running this experiment is given below:\n\nObservations:\n\nppc64le and s390x are able to run the operation in almost half the time it takes for the Windows or FreeBSD 12 machine. This behavior may be attributed to the increased computational power of those machines.\n\nThe difference in performance between git and JGit remains constant across all platforms which is a positive sign for the GitToolChooser as its recommendation would be consistent across multiple devices and operating systems.\n\nRelease Plan 🚀\n\nJENKINS-49757 - Avoid double fetch from Git checkout step\nThis issue was fixed in phase one, avoids the second fetch in redundant cases.\nIt will be shipped with some benchmarks on the change in performance due to the removal of the second fetch.\n\nPR-574\n\nPR-904\n\nGitToolChooser\n\nPR-931\nThis pull request is under review, will be shipped in one of the subsequent Git Plugin releases.\n\nCurrent Challenges with GitToolChooser\n\nImplement the extension point to support GitHub Branch Source Plugin, Gitlab Branch Source Plugin and Gitea Plugin.\n\nThe current version of JGit doesn’t support LFS checkout and sparse checkout, need to make sure that the recommendation doesn’t break existing use cases.\n\nFuture Work\n\nIn phase three, we wish to:\n\nRelease a new version of the Git and Git Client Plugin with the features developed during the project\n\nContinue to explore more areas for performance improvement\n\nAdd a new git operation: git clone (Stretch Goal)\n\nReaching Out\n\nFeel free to reach out to us for any questions or feedback on the project’s Gitter Channel or the Jenkins\nDeveloper Mailing list.\n\nProject Page\n\nPhase 1 Blog Post","title":"Git Plugin Performance Improvement Phase-2 Progress","tags":["plugins","git","platform-sig","developer","performance","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"rishabhBudhouliya","html":"<div class=\"paragraph\">\n<p>GSoC 2020 student under the Jenkins project (Git Plugin Performance Improvements).\nAspiring to be better at Software Development and participate more in the open source\ncommunity.</p>\n</div>","id":"rishabhbudhouliya","irc":null,"linkedin":null,"name":"Rishabh Budhouliya","slug":"blog/author/rishabhbudhouliya","twitter":null}]}},{"node":{"date":"2020-07-27T00:00:00.000Z","id":"0b676e9e-8bca-5401-ad70-50c30452b445","slug":"/blog/2020/07/27/machine-learning-plugin-coding-phase2/","strippedHtml":"Welcome back folks!\n\nThis blog post is about my coding phase 2 in Jenkins Machine Learning Plugin for this GSoC 2020.\nAfter successfully passing the evaluation and demo in the phase 1, our team went ahead for facing the challenges in phase 2.\n\nSummary\n\nThis phase of coding was well spent by documentation and by fixing many bugs.\nAs the main feature of connecting to an IPython Kernel is done in phase 1, we were able to focus on fixing minor/major bugs and documenting for the users.\nAccording to the JENKINS-62927 issue, a Docker agent was built to facilitate users without concerning plugin dependencies in python.\nIn the act of deprecation of Python 2, we ported our plugin to support Python 3.\nWe have tested our plugin in Conda, venv and Windows environments.\nMachine learning plugin has successfully passed the end to end test. A feature for a code editor is needed for further discussion/analysis as we have done a simple editor that may be useful in other ways in the future. PR#35\n\nMain features of Machine Learning plugin\n\nRun Jupyter notebook, (Zeppelin) JSON and Python files\n\nRun Python code directly\n\nConvert Jupyter Notebooks to Python and JSON\n\nConfigure IPython kernel properties\n\nSupport to execute Notebooks/Python on Agent\n\nSupport for Windows and Linux\n\nUpcoming features\n\nExtract graph/map/images from the code\n\nSave artifacts according to the step name\n\nGenerate reports for corresponding build\n\nFuture improvements\n\nUsage of JupyterRestClient\n\nSupport for multiple language kernels\n\nNote : There is no commitment on future improvements during GSoC period\n\nDocker agent\n\nThe following Dockerfile can be used to build the Docker container as an agent for the Machine Learning plugin. This docker agent can be used to run  notebooks or python scripts.\n\nDockerfile\n\nFROM jenkins/agent:latest\n\nMAINTAINER Loghi\n\nUSER root\n\nRUN apt update && apt install --no-install-recommends python3 -y \\\n    python3-pip \\\n    && rm -rf /var/lib/apt/lists/*\n\nCOPY requirements.txt /requirements.txt\n\nRUN pip3 install --upgrade pip setuptools && \\\n    pip3 install --no-cache-dir -r /requirements.txt && \\\n    ln -sf /usr/bin/python3 /usr/bin/python && \\\n    ln -sf /usr/bin/pip3 /usr/bin/pip\n\nUSER jenkins\n\nPorted to Python 3\n\nAs discussed in the previous meeting, we concluded that the plugin should support Python 3 as Python 2.7+ has been deprecated since the beginning of 2020. Pull request for docker agent should be also ported to Python 3 support.\n\nJupyter Rest Client API\n\nThe Jupyter Notebook server API seemed to be promising that it can be also used to run notebooks and codes. There were 3 api implementations that were merged in the master. But we had to focus on what was proposed in the design document and had to finish all must-have issues/works. Jupyter REST client was left for future implementation. It is also a good start to contribute to the plugin from the community.\n\nFixed bugs for running in agent\n\nThere were a few bugs related to the file path of notebooks while building a job. The major problem was caused by the python dependencies needed to connect to a IPython kernel. All issues/bugs were fixed before the timeline given.\n\nR support as a future improvement\n\nThis is what we tried to give a glimpse of knowledge that this plugin can be extended for multi language support in the future. There was a conclusion that the kernel should be selected dynamically using extension of the script file(like eval_model.rb or train_model.r), instead of scripting the same code for each kernel.\n\nDocumentation and End to End testing\n\nA well explained documentation was published in the repository. A guided tutorial to run a notebook checked out from a git repo in an agent was included in the docs page. Mentors helped to test our plugin in both Linux and Windows.\n\nCode editor with rebuild feature\n\nCode editor was filtered as a nice to have feature in the design document. After grabbing the idea of Jenkinsfile replay editor, I could do the same for the code. At the same time, when we are getting the source code from git, it is not an elegant way of editing code in the original code. After the discussion, we had to leave the PR open that may have use cases in the future if needed.\n\nJenkins LTS update\n\nThe plugin has been updated to support Jenkins LTS 2.204.1 as 2.164.3 had some problems with installing pipeline supported API/plugin\n\nInstallation for experimental version\n\nEnable the experimental update center\n\nSearch for Machine Learning Plugin and check the box along it.\n\nClick on Install without restart\n\nThe plugin should now be installed on your system.\n\nResources\n\nCommunity Bonding blog post\n\nPhase 1 blog post\n\nGithub\n\nProject page\n\nDesign document","title":"Machine Learning Plugin project - Coding Phase 2 blog post","tags":["machinelearning","datascience","plugins","communitybonding","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"loghijiaha","html":"<div class=\"paragraph\">\n<p>Computer Science and Engineering Student at University of Moratuwa, Sri Lanka. He has been selected for Machine Learning plugin for Data Science in GSoC 2020 for Jenkins project. Hightly interested and contributing on open source projects.</p>\n</div>","id":"loghijiaha","irc":null,"linkedin":"loghi","name":"Loghi Perinpanayagam","slug":"blog/author/loghijiaha","twitter":"loghi5"}]}},{"node":{"date":"2020-07-24T00:00:00.000Z","id":"4bb5ba32-d613-5603-8d83-2dabce9481fa","slug":"/blog/2020/07/24/external-fingerprint-storage-phase-2/","strippedHtml":"As another great phase for the\nExternal Fingerprint Storage Project\ncomes to an end, we summarise the work done during this phase in this blog post.\nIt was an exciting and fruitful journey, just like the previous phase, and offered some great learning experience.\n\nTo understand what the project is about and the past progress, please refer to the\nphase 1 blog post.\n\nNew Stories Completed\n\nWe targeted four stories in this phase, namely fingerprint cleanup, fingerprint migration, refactoring the current\nimplementation to use descriptors, and improved testing of the Redis Fingerprint Storage Plugin.\nWe explain these stories in detail below.\n\nFingerprint Cleanup\n\nhttps://github.com/jenkinsci/jenkins/pull/4817\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/23\n\nThis story involved extending the FingerprintStorage API to allow external storage plugins to perform and configure\ntheir own fingerprint cleanup strategies.\nWe added the following functionalities to Jenkins core API:\n\nFingerprintStorage#iterateAndCleanupFingerprints(TaskListener taskListener)\n\nThis allows external fingerprint storage implementations to implement their own custom fingerprint cleanup.\nThe method is called periodically by Jenkins core.\n\nFingerprintStorage#cleanFingerprint(Fingerprint fingerprint, TaskListener taskListener)\n\nThis is a reference implementation which can be called by external storage plugins to clean up a fingerprint.\nIt is upto the plugin implementation to decide whether to use this method.\nThey may choose to write a custom implementation.\n\nWe consume these new API functionalities in the\nRedis Fingerprint Storage plugin.\nThe plugin uses cursors to traverse the fingerprints, updating the build information, and deleting the build-less\nfingerprints.\n\nEarlier, fingerprint cleanup was always run periodically and there was no way to turn it off.\nWe also added an option to allow the user to turn off fingerprint cleanup.\n\nThis was done because it may be the case that keeping redundant fingerprints in memory might be cheaper than the\ncleanup operation (especially in the case of external storages, which are cheaper these days).\n\nFingerprint Migration\n\nhttps://github.com/jenkinsci/jenkins/pull/4825\n\nEarlier, there was no support for fingerprints stored in the local storage.\nIn this phase, we introduce migration support for users.\nThe old fingerprints are now migrated to the new configured external storage whenever they are used (lazy migration).\nThis allows gradual migration of old fingerprints from local disk storage to the new external storage.\n\nRefactor FingerprintStorage to use descriptors\n\nhttps://github.com/jenkinsci/jenkins/pull/4834\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/36\n\nEarlier, whenever an external fingerprint storage plugin was installed, it was enabled by default.\nWe refactored the implementation to make use of Descriptor pattern so the fingerprint engine can now be selected\nas a dropdown from the Jenkins configuration page.\nThe dropdown is shown only when multiple fingerprint storage engines are configured on the system.\nRedis Fingerprint Storage Plugin was refactored\nto use this new implementation.\n\nStrengthened testing for the Redis Fingerprint Storage Plugin\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/33\n\nWe introduced new connection tests in the\nRedis Fingerprint Storage Plugin.\nThese tests allow testing of cases like slow connection, breakage of connection to Redis, etc.\nThese were implemented using the Toxiproxy module inside Testcontainers.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/31\n\nWe introduced test for Configuration-as-code (JCasC) compatibility with the plugin.\nThe documentation for configuring the plugin using JCasC was also added.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/39\n\nWe introduced a suite of authentication tests, to verify the proper working of the Redis authentication system.\nAuthentication uses the credentials plugin.\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/32\n\nhttps://github.com/jenkinsci/redis-fingerprint-storage-plugin/pull/36\n\nWe strengthened our web UI testing to ensure that the configuration page for the plugin works properly as planned.\n\nOther miscellaneous tasks\n\nPlease refer to the Jira Epic for this phase.\n\nReleases 🚀\n\nChanges in the Jenkins core (except migration) were released in Jenkins 2.248.\n\nWe drafted 1.0-rc-1\nrelease for the Redis Fingerprint Storage Plugin\nto deliver the changes.\nThis was an increment from the alpha release\nwe had drafted at the end of the previous phase.\nThe plugin is now available at https://plugins.jenkins.io/redis-fingerprint-storage/!\n\nTrying out the new features!\n\nThe latest release for the plugin can be downloaded from the update center, instructions for which can be\nfound in the README\nof the plugin.\nWe appreciate you trying out the plugin, and welcome any suggestions, feature requests, bug reports, etc.\n\nAcknowledgements\n\nThe Redis Fingerprint Storage plugin is built and maintained by the Google Summer of Code (GSoC) Team for\nExternal Fingerprint Storage for\nJenkins. Special thanks to Oleg Nenashev,\nAndrey Falko, Mike Cirioli,\nTim Jacomb, and the entire Jenkins community for all the contribution to this project.\n\nFuture Work\n\nSome of the topics we aim to tackle in the next phase include a new reference implementation (possibly backed\nby PostgreSQL), tracing, etc.\n\nReaching Out\n\nFeel free to reach out to us for any questions, feedback, etc. on the project’s Gitter Channel or the Jenkins\nDeveloper Mailing list.\nWe use Jenkins Jira to track issues.\nFeel free to file issues under redis-fingerprint-storage-plugin component.\n\nOther Links\n\nRedis Fingerprint Storage Plugin\n\nIssue Tracker for Phase 2\n\njep:226[]\n\nGitter Channel\n\nProject Page\n\nPhase 1 Blog Post","title":"External Fingerprint Storage Phase-2 Updates","tags":["plugins","fingerprint","cloud-native","external-storage","developer","redis","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":"https://medium.com/@sumitsarinofficial","github":"stellargo","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 student. Sumit is an engineering student (senior) at Netaji Subhas Institute of Technology, University of Delhi. He started his journey of contributing to Jenkins in December 2019. His tiny contribution revolved around the Jenkins Fingerprint engine. He is currently working on building <a href=\"https://www.jenkins.io/projects/gsoc/2020/projects/external-fingerprint-storage\">External Fingerprint Storage for Jenkins</a>.</p>\n</div>","id":"stellargo","irc":null,"linkedin":"sumit-sarin","name":"Sumit Sarin","slug":"blog/author/stellargo","twitter":null}]}},{"node":{"date":"2020-07-09T00:00:00.000Z","id":"615c1ac2-c3da-5001-be28-908ac6008d94","slug":"/blog/2020/07/09/git-performance-improvement-phase1/","strippedHtml":"Git Plugin Performance Improvement is a Google Summer of Code 2020 project.\nIt aims to improve the performance of the git plugin, which provides fundamental git functionalities.\n\nInternally, the plugin provides these functionalities using two implementations: command line git and JGit (pure java implementation).\n\nCLI git is the default implementation for the plugin, a user can switch to JGit if needed\n\nThe project is divided into two parallel stages:\n\nStage 1 : Create benchmarks which evaluate the execution time of a git operation provided by CLI git and JGit using JMH, a micro benchmarking test harness.\n\nStage 2 : Implement the insights gained from the analysis into the plugin to improve the overall performance of the plugin.\n\nThe project also aims to fix any existing performance bottlenecks within the plugin as well.\n\nBenchmarks\n\nThe benchmarks are written using JMH. It was introduced in a GSoC 2019 project to Jenkins.\n\nJMH is provided within the plugin through the Jenkins Unit Test Harness POM dependency.\n\nThe JMH benchmarks are created and run within the git client plugin\n\nDuring phase-1, we have created benchmarks for two operations: \"git fetch\" and \"git ls-remote\"\n\nResults and Analysis\n\nThe benchmark analysis for git fetch:\n\nGit fetch results\n\nThe performance of git fetch (average execution time/op) is strongly correlated to the size of a repository\n\nThere exists an inflection point on the scale of repository size after which the nature of JGit performance changes (it starts to degrade)\n\nAfter running multiple benchmarks, it is safe to say that for a large sized repository CLI-git would be a better choice of implementation.\n\nWe can use this insight to implement a feature which avoids JGit when it comes to large repositories.\n\nPlease refer to PR-521 for an elaborate explanation on these results\n\nNote: Repository size means du -h .git\n\nFixing redundant fetch issue\n\nThe git plugin performs two fetch operations instead of one while performing a fresh checkout of a remote git repository.\n\nTo fix this issue, we had to safely remove the second fetch keeping multiple use-cases in mind. The fix itself was not difficult to code, but to do that safely without breaking any existing use-case was a challenging task.\n\nFurther Plan\n\nAfter consolidating a benchmarking strategy during Phase 1, the next steps will be:\n\nProvide functionality to the git plugin, which enables it to estimate the size of the repository without cloning it.\n\nBroaden the scope of benchmarking strategy\n\nConsider parameters like number of branches, references and commit history to find a relation with the performance of a git operation\n\nThe git plugin depends on other plugins like Credentials which might require benchmarking the plugin itself and the effects of these external dependencies on the plugin’s performance\n\nFocus on other use-cases of the plugin\n\nFor phase-1, I focused on the checkout step and the operations involved with it\n\nFor the next phase, the focus will shift to other areas like Multibranch pipelines or Organisation Folders\n\nHow can you help?\n\nIf you have reached this far of the blog, you might be interested in the project.\n\nTo help, you can\n\nReview the benchmarks in the benchmarks module\n\nAnalyse the benchmarks results available on ci.jenkins.io [soon]\n\nCome visit our Gitter channel: https://gitter.im/jenkinsci/git-plugin","title":"Git Plugin Performance Improvement: Phase-1","tags":["plugins","git","platform-sig","developer","performance","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"rishabhBudhouliya","html":"<div class=\"paragraph\">\n<p>GSoC 2020 student under the Jenkins project (Git Plugin Performance Improvements).\nAspiring to be better at Software Development and participate more in the open source\ncommunity.</p>\n</div>","id":"rishabhbudhouliya","irc":null,"linkedin":null,"name":"Rishabh Budhouliya","slug":"blog/author/rishabhbudhouliya","twitter":null}]}},{"node":{"date":"2020-07-09T00:00:00.000Z","id":"f26945c7-7d59-55b5-84e1-9d4e82638d84","slug":"/blog/2020/07/09/github-checks-api-plugin-coding-phase-1/","strippedHtml":"This blog post is about our coding phase 1 progress on GSoC project: GitHub Checks API Plugin.\n\nThe GitHub Checks API is a highly customized way to integrate CI tools to make reports for pull-requests (PRs).\nIt allows users to see CI reports on GitHub pages directly.\n\nFigure 1. GitHub Check Run Screenshot from GitHub Docs\n\nWhat’s more exciting is that it can leave annotations on specific lines of code, just as the comments people left while reviewing.\n\nFigure 2. Check Run Annotation Screenshot from GitHub Docs\n\nWhile on Jenkins' side, the source code view provided by Warnings Next Generation Plugin does pretty much the same thing.\n\nFigure 3. Source Code View from Warnings Next Generation Plugin\n\nUtilizing such features through GitHub Checks API, it would make Jenkins more convenient to GitHub users.\n\nFeatures from Coding Phase 1\n\nIn the past month, our team was mostly working on the general checks API and an implementation for GitHub checks API.\n\nGitHub Checks API Plugin Demo [starts from 50:15]\n\nGeneral Checks API\n\nAlthough the general checks API is developed based on the semantic meaning of GitHub Checks API, we still want to prepare it for similar concepts on other platforms like Commit Status API from GitLab.\nContributions for implementations on these platforms will be welcomed in the future.\n\nGitHub Checks API Implementation\n\nOur work on supporting GitHub Checks API is mostly done by now.\nBesides, we implemented a consumer to automatically create a check run that simply indicates the current stage of a Jenkins build.\nAfter the release, Jenkins developers (especially publisher plugin ones) can create their own GitHub checks for a GitHub branch source project by consuming our API.\n\nExample: To create a check run like:\n\nConsumers need to use our API in this way:\n\nChecksDetails details = new ChecksDetailsBuilder()\n        .withName(\"Jenkins\")\n        .withStatus(ChecksStatus.COMPLETED)\n        .withDetailsURL(\"https://ci.jenkins.io\")\n        .withStartedAt(LocalDateTime.now(ZoneOffset.UTC))\n        .withCompletedAt(LocalDateTime.now(ZoneOffset.UTC))\n        .withConclusion(ChecksConclusion.SUCCESS)\n        .withOutput(new ChecksOutputBuilder()\n                .withTitle(\"Jenkins Check\")\n                .withSummary(\"# A Successful Build\")\n                .withText(\"## 0 Failures\")\n                .withAnnotations(Arrays.asList(\n                        new ChecksAnnotationBuilder()\n                                .withPath(\"Jenkinsfile\")\n                                .withLine(1)\n                                .withAnnotationLevel(ChecksAnnotationLevel.NOTICE)\n                                .withMessage(\"say hello to Jenkins\")\n                                .withStartColumn(0)\n                                .withEndColumn(20)\n                                .withTitle(\"Hello Jenkins\")\n                                .withRawDetails(\"a simple echo command\")\n                                .build(),\n                        new ChecksAnnotationBuilder()\n                                .withPath(\"Jenkinsfile\")\n                                .withLine(2)\n                                .withAnnotationLevel(ChecksAnnotationLevel.WARNING)\n                                .withMessage(\"say hello to GitHub Checks API\")\n                                .withStartColumn(0)\n                                .withEndColumn(30)\n                                .withTitle(\"Hello GitHub Checks API\")\n                                .withRawDetails(\"a simple echo command\")\n                                .build()))\n                .build())\n        .withActions(Collections.singletonList(\n                new ChecksAction(\"formatting\", \"format code\", \"#0\")))\n        .build();\n\nChecksPublisher publisher = ChecksPublisherFactory.fromRun(run);\npublisher.publish(details);\n\nFuture Works\n\nThe next step is integrating our API into Warnings Next Generation Plugin and Code Coverage API Plugin consume our API.\nAfter that, pipeline support will be added: users can publish checks directly in a pipeline script without requiring a consumer plugin that support the checks.\n\nResources\n\nGitHub Repository\n\nProject Page\n\nGitter Channel\n\nReferences\n\nGitHub Doc: Creating CI tests with the Checks API\n\nWarnings Next Generation Plugin: Source Code View","title":"GitHub Checks API Plugin Project - Coding Phase 1","tags":["github","api","plugins","developer","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"XiongKezhi","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 Student. Kezhi is an open source enthusiast who enjoys sharing ideas with other developers. He started contributing to Jenkins in March 2020. Currently, he is working on <a href=\"https://github.com/XiongKezhi/checks-api-plugin\">GitHub Checks API Plugin</a>.</p>\n</div>","id":"XiongKezhi","irc":null,"linkedin":"kezhi-xiong-44234a188","name":"Kezhi Xiong","slug":"blog/author/xiongkezhi","twitter":"AugustX_"}]}},{"node":{"date":"2020-06-30T00:00:00.000Z","id":"9a5f343b-e83f-526e-aab4-05c8c88ea996","slug":"/blog/2020/06/30/machine-learning-plugin-coding-phase1/","strippedHtml":"Welcome back !\n\nThis blog post is briefing my coding phase 1 in Jenkins Machine Learning Plugin for this GSoC 2020.\n\nAfter a fresh introduction of community bonding, On June 1st, coding of GSoC had started officially with phase 1. At this point, every GSoC student should be expected to have a rigid plan with their entire project. With the guidance of mentors I was able to complete a design document and timeline which can be slightly adjustable during the coding. The coding phase was more about coding and discussion.\n\nQuick review\n\nPull Requests\n21\n\nJira Issues\n11\n\nMajor Tasks\n3\n\nCompleted\n3\n\nIn progress\n0\n\nWeek 1\n\nI have to ensure that I have a solid architecture for implementing the core of this plugin such that perhaps I or future community will be able to develop R and Julia kernels for this plugin. Factory method design patterns are suitable when users need different types of products ( Python, R and Julia) without knowing much about the internal infrastructure ( Manager of these interpreters ).\n\nAll the base classes were implemented this week.\n\nDesign the Kernel connectors\n\nInitiate the interpreter\n\nClose the connection\n\nAdd simple tests\n\nUpdate pom.xml\n\nMore than these changes, repo was updated with pull request template and licence header. Readme was extended a little at the end of the week.\n\nIssues and Challenges\n\nGit rebase and squash\n\nTests invokes ipython client in the server failed during the CI build\n\nWeek 2\n\nWith the help of a design document, I had a plan to do the configurations globally and using the Abstract Folder property I could save the configuration and retrieve for the job configuartion. I used to reference some other well developed plugin for the structure of code. That helped me a lot while I was coding. Our first official contributor has popped out his pull request.\n\nForm validations and helper html will be a great help in the user point of view as well as developers. A minor bug was fixed with the guidance of mentors by writing tests with ‘Jenkins WebClient`. Until the end of the week, builder class of the plugin has been implemented with lots of research and discussion. Finally,  Test connection was added to the global configuration page to start the connection and test it. A single issue that blocked me using py4j authentication about zeppelin-python was reported in Jira.\n\nServer Configuration\n\nIssues and challenges\n\nBackend depends on Apache zeppelin-python API to connect IPython\n\nFind relevant extension points to extend the plugin\n\nWeek 3\n\nEarlier in this week, we were trying to merge our IPython builder PR without any memory leaks or bugs that will cause the system to be devastating while running this plugin. Later, this whole week I was implementing a file parser that could copy the necessary files and had the ability to accomplish the file conversion.\n\nSupported file types\n\nPython (.py)\n\nJSON (Zeppelin notebooks format)\n\nIPython builder was able to run Jupyter Notebooks and Zeppelin formatted JSON files at the end of the 3rd week. Minor issues were fixed in the code. We used ANSI color plugin to fix the abnormal view of error messages produced by the ipython kernel.\n\nCopying and converting Jupyter Notebook\n\nIssues and Challenges\n\nPython error messages could not be displayed in rich format\nIf a job is running at user level, but if the python code access file/file path which is not authorized to the user, it returns a permission denied message.\nWhile running on agent, notebook has to be written/copied to agent workspace\nArtifacts should be maintained/reachable from controller after build.\n\nWeek 4\n\nAs all the major tasks has done, the demo preparation and plan for a experimental release was carried during the last week. There were lots of research on how to connect to a existing kernel in remote. Demo and presentation were prepared along the week.\n\nIssues and Challenges\n\nReleasing the first version was bit late\n\nKnowledge transfer\n\nHow to debug the code through IntelliJ\n\nEdit configuration → Add new Configuration → Maven\n\nCommand line → type hpi:run\n\nClick the debug icon on the toolbar or go to Run menu then Debug\n\nHow to setup to test the plugin\n\nSetup JDK 8 and Maven 3.5.*\n\nCreate a directory $ mkdir machine-learning-plugin\n\nCreate a virtual environment $ virtualenv venv\n\nActivate your virtual environment $ source venv/bin/activate\n\nRun $ which python to ensure your python path\n\n$ git clone https://github.com/jenkinsci/machine-learning-plugin.git\n\nRun $ mvn clean install from the machine-learning-plugin directory\n\nRun $ mvn hpi:run to start Jenkins with the plugin\n\nSet up the builder with localhost and other parameters\n\nCreate a job\n\nWrite python code like print(“plugin works”)\n\nBuild the job\n\nIssues and bugs\n\nJENKINS-62528 Issues on Jenkins build in the plugin repository\n\nJENKINS-62621 Global configuration for IPython servers\n\nJENKINS-62649 Implementation of IPython Builder\n\nJENKINS-62711 File parser to copy source files to workspace\n\nJENKINS-62733 Python errors are not displayed properly in console log\n\nJENKINS-62735 Send/Receive necessary files from controller/agent to agent/controller\n\nJENKINS-62593 Improve the documentation\n\nJENKINS-62742 Increase Test coverage\n\nResources and Links\n\nGithub\n\nProject page\n\nDesign document","title":"Machine Learning Plugin project - coding phase 1 blog post","tags":["machinelearning","datascience","plugins","communitybonding","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"loghijiaha","html":"<div class=\"paragraph\">\n<p>Computer Science and Engineering Student at University of Moratuwa, Sri Lanka. He has been selected for Machine Learning plugin for Data Science in GSoC 2020 for Jenkins project. Hightly interested and contributing on open source projects.</p>\n</div>","id":"loghijiaha","irc":null,"linkedin":"loghi","name":"Loghi Perinpanayagam","slug":"blog/author/loghijiaha","twitter":"loghi5"}]}},{"node":{"date":"2020-06-27T00:00:00.000Z","id":"a288c37b-abcd-5bdc-8b5b-012344f2934c","slug":"/blog/2020/06/27/external-fingerprint-storage/","strippedHtml":"Externalizing fingerprint storage for Jenkins is a  Google Summer of Code 2020 project.\nWe are working on building a pluggable storage engine for fingerprints (see jep:226[]).\n\nFile fingerprinting is a way to track which version of a file is being used by a job/build, making dependency tracking easy. The fingerprint engine of Jenkins can track usages of artifacts, credentials, files, etc. within the system. Currently, it does this by maintaining a local XML-based database which leads to dependence on the physical disk of the Jenkins controller.\n\nAllowing fingerprint storage to be moved to external storages decreases the dependence of Jenkins instances on the physical disk space and also allows for tracking the flow of fingerprints across instances of Jenkins connected to the same external storage.\n\nAdvantages of using external storage drivers:\n\nRemove dependence on Jenkins controller disk storage\n\nCan configure pay-as-you-use cloud storages\n\nEasy Backup Management\n\nBetter Reliability and Availability\n\nFingerprints can be tracked across Jenkins instances\n\nAlong with this API, we are also working on a reference implementation in the form of a plugin, powered by Redis.\n\nAs phase 1 of this project comes to an end, this blog post serves as a summary of the progress we made to the entire Jenkins community.\n\nCurrent State\n\nThe new API introduced in Jenkins core is under review. Once merged, it will offer developers to extend it to build external fingerprint storage plugins.\n\nThe Redis Fingerprint Storage Plugin is alpha release ready. We would immensely appreciate any feedback.\n\nExternal Fingerprint Storage Demo\n\nIntroducing the new API for plugin developers\n\nWith PR-4731, we introduce a new fingerprint storage API, allowing configuring custom storage engines.\nWe exposed the following methods in the new FingerprintStorage class:\n\nvoid save()\n\nSaves the given Fingerprint in the storage.\n\nFingerprint load(String id)\n\nReturns the Fingerprint with the given unique ID. The unique ID for a fingerprint is defined by Fingerprint#getHashString().\n\nvoid delete(String id)\n\nDeletes the Fingerprint with the given unique ID.\n\nboolean isReady()\n\nReturns true if there is some data in the fingerprint database corresponding to the particular Jenkins instance.\n\nIntroducing Redis Fingerprint Storage Plugin\n\nRedis Fingerprint Storage Plugin uses the new External Fingerprint Storage API to store the fingerprints in a Redis instance.\n\nInstallation:\n\nThe alpha release (version 0.1-alpha-1) for the plugin was drafted, and can be installed using the experimental update center.\n\nFollow along the following steps after running Jenkins to download and install the plugin:\n\nSelect Manage Jenkins\n\nSelect Manage Plugins\n\nGo to Advanced tab\n\nConfigure the Update Site URL as: https://updates.jenkins.io/experimental/update-center.json\n\nClick on Submit, and then press the Check Now button.\n\nGo to Available tab.\n\nSearch for Redis Fingerprint Storage Plugin and check the box along it.\n\nClick on Install without restart\n\nThe plugin should now be installed on your system.\n\nUsage\n\nOnce the plugin has been installed, you can configure the Redis server details by following the steps below:\n\nSelect Manage Jenkins\n\nSelect Configure System\n\nScroll to the section Redis Fingerprint Storage Configuration and fill in the required details:\n\nHost - Enter hostname where Redis is running\n\nPort - Specify the port on which Redis is running\n\nSSL - Click if SSL is enabled\n\nDatabase - Redis supports integer indexed databases, which can be specified here.\n\nConnection Timeout - Set the connection timeout duration in milliseconds.\n\nSocked Timeout - Set the socket timeout duration in milliseconds.\n\nCredentials - Configure authentication using username and password to the Redis instance.\n\nEnabled - Check this to enable the plugin (Note: This is likely to be removed very soon, and will be enabled by default.)\n\nUse the Test Redis Connection to verify that the details are correct and Jenkins is able to connect to the Redis instance.\n\nPress the Save button.\n\nNow, all the fingerprints produced by this Jenkins instance should be saved in the configured Redis server!\n\nFuture Work\n\nSome of the topics we aim to tackle in the next phases include extending the API, fingerprint cleanup, migrations (internal→external, external→internal, external→external), tracing, ORM, implementing the saveable listener, etc.\n\nAcknowledgements\n\nThe Redis Fingerprint Storage plugin is built and maintained by the Google Summer of Code (GSoC) Team for\nExternal Fingerprint Storage for Jenkins.\n\nSpecial thanks to Oleg Nenashev, Andrey Falko, Mike Cirioli, Jesse Glick, and the entire Jenkins community for all the contribution to this project.\n\nReaching Out\n\nFeel free to reach out to us for any questions, feedback, etc. on the project’s Gitter Channel or the Jenkins Developer Mailing list\n\nWe use Jenkins Jira to track issues.\nFeel free to file issues under redis-fingerprint-storage-plugin component.\n\nOther Links\n\nPhase 1 demo\n\nPresentation slides\n\nRedis Fingerprint Storage Plugin\n\nIssue Tracker for Phase 1\n\njep:226[]\n\nGitter Channel\n\nProject Page","title":"External Fingerprint Storage Phase-1 Updates","tags":["plugins","fingerprint","cloud-native","external-storage","developer","redis","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":"https://medium.com/@sumitsarinofficial","github":"stellargo","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 student. Sumit is an engineering student (senior) at Netaji Subhas Institute of Technology, University of Delhi. He started his journey of contributing to Jenkins in December 2019. His tiny contribution revolved around the Jenkins Fingerprint engine. He is currently working on building <a href=\"https://www.jenkins.io/projects/gsoc/2020/projects/external-fingerprint-storage\">External Fingerprint Storage for Jenkins</a>.</p>\n</div>","id":"stellargo","irc":null,"linkedin":"sumit-sarin","name":"Sumit Sarin","slug":"blog/author/stellargo","twitter":null}]}},{"node":{"date":"2020-06-03T00:00:00.000Z","id":"d34ea0a7-91c1-5a7d-b78e-94d7cfb9e85b","slug":"/blog/2020/06/03/machine-learning-plugin-community-bonding/","strippedHtml":"Hello everyone !\n\nThis is one of the Jenkins project in GSoC 2020. We are working this new Machine Learning Plugin for this GSoC 2020.\nThis is my story about the community bonding of GSoC 2020. I am happy to share my journey with you.\n\nIntroducing Myself and my Fantastic 4 Mentors\n\nI am Loghi Perinpanayagam from University of Moratuwa. I was selected for GSoC 2020 for Machine Learning Plugin in Jenkins. I am glad to introduce my mentors to this project. I was assigned with four mentors who are really enthusiastic to help me on kicking off this summer of code.\n\nStudent\n\nLoghi Perinpanayagam\n\nMentors\n\nBruno P. Kinoshita\n\nIoannis Moutsatsos\n\nMarky Jackson\n\nShivay Lamba\n\nHow was my preparation last year ?\n\nI learned about this open source program in my second year. But atleast I tried last year on a different organization’s project that was related to Data Visualization Recommendation for Data Science. But the problem was I did not contribute as much as this year and was too late in the application process. As usual Machine learning related projects have a lot of competition compared to other projects. I prepared on learning Data visualization in Machine Learning and existing Models for the recommendation system. Finally I wrote a proposal with the SeqToSeq model without much knowledge on neural networks at that time. And I did not communicate much through the dedicated slack channel.  That may be one of the reasons for the failure. But the main reason was my latency for GSoC 2019.\n\nHow did I hurdle GSoC 2020 ?\n\nSince the time I realized how open source is needed and helpful for the community, I have been passionate about contributing to open source projects. At the instance, I finished my internship in Bangalore, India in 2019, I immediately focused on participating in GSoC. This is my last year (2020) as a student of my BSc Computer Science life, I wanted to get selected this year as a student.\n\nThere was a guidance seminar organized by our department, I got to know that Jenkins had opened their project ideas. That was an extremely impressive beginning of my GSoC 2020 journey. I walked through all the draft and accepted projects in the Jenkins.io page. As I am already interested in Machine Learning and I am familiar with Java, I picked the most impressive idea for me that does not have an initial repo. That means I wanted to use my knowledge to think and research a lot with this project. But I had to contribute and want to know about the infrastructure of Jenkins codebase. Because that makes the selection panel easy to pick up the student for the project.  Then I repeatedly searched to contribute to Jenkins. I found issues that were easy for me to work from the git plugin and git client plugin. I started to contribute some test issues on git plugin and git client plugin. After I got a clear knowledge on how a plugin works in Jenkins, I started working on the POC with the hint provided in the project idea page. Actually, that was fun to code.\n\nMentors have helped many students during the application process. I was able to do a working POC that had a minimum capability to do the task of the project. Finally mentors opened for proposal submission. I hurried to prepare a draft proposal. After I got reviews from mentors, I started to improve the proposal. At the end of the proposal submission, I was able to deliver a good proposal for this project. As I was curious about this plugin, I dug into more on how to integrate Jupyter notebook with this plugin. I published an medium article as a result of my research during the acceptance waiting period.\n\nResults released\n\nThe result was going to be announced on 4th May, I believed in my project proposal and POC and I got selected for this GSoC 2020. Whoa ! That was a goosebumping moment in my entire life. The feeling was like Something I achieved. As a result of my hard work, I deserved that.\nFor example, I spent 7 days continuously making the POC work without any collision between maven artifacts.\n\nCommunity Bonding\n\nAfter the release of results, I was preparing myself for the community bonding. There are lots of interactions happening between me and mentors than before.I had to update my project page and my profile in Jenkins.io. We had our first meeting with lots of excitement and love on 10th of May. Mentors and I introduced ourselves even though we know each other. We discussed the high level view of GSoC and I asked some questions that I had in my mind. As my plugin was a new repository, most of the discussion was related to the repository and its name. I had  to find a name for the new plugin. We had regular conversations about the blogpost and presentations at the end.\n\nIn the second meeting, We discussed the process for hosting a new plugin in Jenkins, tracking issues with JIRA, blog posts and high level road map for the project. And I suggested some interesting plugin names but they were not matching to the goal of the project, mentors told me to try other names which perfectly describe the project. I was advised to read all the research guidelines and plugin naming conventions. We discussed how code reviews will be done and source code management through the git. After this meeting, our meeting has shifted to the official Jenkins Zoom account.\n\nOur third meeting was quite serious about our project planning. I had been preparing my design document for the project with the help of mentors before the meeting day. Hence I got lots of reviews and useful examples for my future work on phase 1. At this point, we decided with the plugin name Machine Learning Plugin which was accepted by all mentors and I created the repo and requested a Jira ticket for the plugin hosting request. We were planning to remind the Jira ticket within the next 3 days. Mentors want me to make sure I updated the Jenkins GSoC page before the community period ends. Lots of discussion carried about the design document that I had been preparing last week before the meeting. Some important points from the meeting notes follows :\n\nDefine features in the design document\n\nDiagrams for the operations\n\nHow plugin works in distributed environment\n\nCode editor library\n\nRequirements for the first Plugin release\n\nBlog post draft document\n\nToDo works for me for next week\n\nTherefore, I had to work hard after this meeting, this made me involved in the project more. I have to put my huge effort to make this opportunity golden. Our team has the willingness to complete this project and will definitely help the Data Science community with this plugin.\nKudos to my team for the amazing work so far!!!\n\nThis was my entire journey until now. Hope you enjoyed it and hope you learned the mistakes I made last year and corrected in this summer.\nThanks for reading, and Stay tuned I will be uploading blog posts for those of you interested.\n\nResources and Links\n\nProject page\n\nDesign document","title":"Machine Learning Plugin project - community bonding blog post","tags":["machinelearning","datascience","plugins","communitybonding","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"loghijiaha","html":"<div class=\"paragraph\">\n<p>Computer Science and Engineering Student at University of Moratuwa, Sri Lanka. He has been selected for Machine Learning plugin for Data Science in GSoC 2020 for Jenkins project. Hightly interested and contributing on open source projects.</p>\n</div>","id":"loghijiaha","irc":null,"linkedin":"loghi","name":"Loghi Perinpanayagam","slug":"blog/author/loghijiaha","twitter":"loghi5"}]}}]}},"pageContext":{"tag":"plugins","limit":8,"skip":8,"numPages":14,"currentPage":2}},
    "staticQueryHashes": ["3649515864"]}