{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/plugins/page/4",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2019-08-16T00:00:00.000Z","id":"765c4285-c91b-5554-af65-6b25fe8433c3","slug":"/blog/2019/08/16/folder-auth-plugin/","strippedHtml":"During my Google Summer of Code Project,\nI have created the brand new Folder Auth Plugin for easily\nmanaging permissions to projects organized in folders from the Folders plugin.\nThis new plugin is designed for fast permission checks with easy-to-manage roles.\nThe 1.0 version of the plugin has just been released and can be downloaded\nfrom your Jenkins' Update center.\n\nThis plugin was inspired by the Role Strategy Plugin\nand brings about performance improvements and makes managing roles much easier.\nThe plugin was developed to overcome performance limitations of the Role Strategy\nplugin on a large number of roles. At the same time, the plugin addresses one\nof the most popular ways of organizing projects in Jenkins, through folders.\nThe plugin also has a new UI with more improvements to come in the future.\n\nThe plugin supports three types of roles which are applicable at different places\nin Jenkins.\n\nGlobal Roles: applicable everywhere in Jenkins\n\nAgent Roles: restrict permissions for multiple agents connected to your instance\n\nFolder Roles: applicable to multiple jobs organized inside folders\n\nPerformance Improvements over Role Strategy Plugin\n\nThis plugin, unlike the Role Strategy plugin, does not use regular expressions\nfor finding matching projects and agents giving us performance improvements\nand makes administrators' lives easier. To reduce the number of roles required\nto be managed, permissions given to a folder through a folder role get inherited\nto all of its children. This is useful for giving access to multiple projects\nthrough a single role. Similarly, an agent role can be applied to multiple agents\nand assigned to multiple users.\n\nThis plugin is designed to outperform Role Strategy Plugin in permission\nchecks. The improvements were measured using the\nmicro-benchmark framework\nI had created during the first phase of my GSoC project.\nBenchmarks for identical configurations for both plugin show that the\npermissions check are up to 934x faster for 500 global roles when compared to\nthe global roles from the Role Strategy 2.13, which in itself contains several\nperformance improvements. Comparing folder roles with Role Strategy’s project\nroles, a permission check for access to a job almost 15x faster for 250 projects\norganized in two-level deep folders on an instance with 150 users. You can see\nthe benchmarks and the result comparisons\nhere.\n\nJenkins Configuration as Code Support\n\nThe plugin supports Jenkins Configuration-as-Code so you can configure permissions\nwithout going through the Web UI. A YAML configuration looks like this:\n\njenkins:\n  authorizationStrategy:\n    folderBased:\n      globalRoles:\n        - name: \"admin\"\n          permissions:\n            - id: \"hudson.model.Hudson.Administer\"\n              # ...\n          sids:\n            - \"admin\"\n        - name: \"read\"\n          permissions:\n            - id: \"hudson.model.Hudson.Read\"\n          sids:\n            - \"user1\"\n      folderRoles:\n        - folders:\n            - \"root\"\n          name: \"viewRoot\"\n          permissions:\n            - id: \"hudson.model.Item.Read\"\n          sids:\n            - \"user1\"\n      agentRoles:\n        - agents:\n            - \"agent1\"\n          name: \"agentRole1\"\n          permissions:\n            - id: \"hudson.model.Computer.Configure\"\n            - id: \"hudson.model.Computer.Disconnect\"\n          sids:\n            - \"user1\"\n\nREST APIs with Swagger support\n\nThe plugin provides REST APIs for managing roles with OpenAPI specifications\nthrough Swagger.json. You can check out the Swagger API on\nSwaggerHub.\nSwaggerHub provides stubs in multiple languages which can be downloaded and\nused to interact with the plugin. You can also see some sample requests from\nthe command line using curl.\n\nWhat’s next\n\nIn the (not-too-distant) future, I would like to work on improving the UI and\nmake the plugin easier to work with. I would also like to work on improving the\nAPIs, documentation and more optimizations for improving the plugin’s performance.\n\nLinks and Feedback\n\nI would love to hear your comments and suggestions. Please feel free to reach\nout to me through either the\nRole Strategy Plugin Gitter chat or through\nJenkins Developer Mailing list.\n\nPresentation slides for second phase evaluations\n\nDocumentation for the Folder Auth Plugin\n\nDemo of the Folder Authorization plugin","title":"Introducing new Folder Authorization Plugin","tags":["plugins","security","performance","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"AbhyudayaSharma","html":"<div class=\"paragraph\">\n<p>Abhyudaya is a Computer Science student at Shiv Nadar University, India.\nHe is participating in Google Summer of Code 2019 to improve the performance\nof the <a href=\"https://github.com/jenkinsci/role-strategy-plugin\">Role Strategy Plugin</a>.</p>\n</div>","id":"abhyudayasharma","irc":null,"linkedin":null,"name":"Abhyudaya Sharma","slug":"blog/author/abhyudayasharma","twitter":null}]}},{"node":{"date":"2019-07-30T00:00:00.000Z","id":"9f72bb8f-5b81-55ef-8ffc-f58fb42841f2","slug":"/blog/2019/07/30/plugin-management-tool-phase2-updates/","strippedHtml":"At end of the first GSoC phase, I\nannounced\nthe first alpha release of the CLI tool and library that will help centralize\nplugin management and make plugin tooling easier.\n\nPhase 2 has mainly been focused on improving upon the initial CLI and library written\nin Coding Phase 1. In particular, we’ve been focusing on getting the tool ready to\nincorporate into the Jenkins Docker Image to replace the\ninstall-plugins.sh bash script\nto download plugins.  This work included parsing improvements so that blank lines and comments in the\nplugins.txt file are filtered out, allowing update centers and the plugin download\ndirectory to be set via environment variables or CLI Options, creating Windows\ncompatible defaults, and fixing a bug in which dependencies for specific\nplugin versions were not always getting resolved correctly.\n\nIn parallel to getting the tool ready for Jenkins Docker integration, Phase 2 saw\nthe addition of several new features.\n\nYaml Input\n\nIn addition to specifying the plugins they want to download via the --plugins\nCLI option or through a .txt file, users can now use a Jenkins yaml file with a\nplugins root element.\n\nSay goodbye to the days of specifying incremental\nplugins like incrementals;org.jenkins-ci.plugins.workflow;2.20-rc530.b4f7f7869384 -\n  you can enter the artifactId, groupId, and version to specify an incremental plugin.\n\nMaking the Download Process More Transparent\n\nPreviously, the plugin download process was not very transparent to users - it was\ndifficult to know the final set of plugins that would be downloaded after pulling in\nall the dependencies.  Instead of determing the set of plugins that will be downloaded\nat the time of download, users now have the option to see the full set of plugins\nand their versions that will be downloaded in advance. With the --list CLI\noption, users can see all currently downloaded and bundled plugins, the set of all\nplugins that will be downloaded, and the effective plugin set - the set of all\nplugins that are already downloaded or will be downloaded.\n\nViewing Information About plugins\n\nNow that you know which plugins will be downloaded, wouldn’t it be nice to know\nif these are the latest versions or if any of the versions you want to install have\nsecurity warnings?  You can do that now too.\n\nNext Steps and Additional Information\n\nThe updates mentioned in this blog will be released soon so you can try them out.\nThe focus of Phase 3 will be to continue to iterate upon and improve the library\nand CLI. We hope to release a first version and submit a pull request to Jenkins Docker soon.\nThanks to everyone who has already tried it out and given feedback! I will also be\npresenting my work at DevOps World\nin San Francisco in a few weeks.  You can use the code PREVIEW for a discounted registration\n($799 instead of $1,499).\n\nFeel free to reach out through\nthe Plugin Installation Manager CLI Tool Gitter chat or through\nthe Jenkins Developer Mailing list. I would love to get your questions, comments, and feedback!\nWe have meetings Tuesdays and Thursdays at 6PM UTC.\n\nPhase 2 Presentation Slides\n\nPhase 2 Recorded Demo\n\nJira Issue Search\n\nRepository","title":"Plugin Management Library and CLI Tool Phase 2 GSoC Updates","tags":["plugins","pluginmanagement","platform-sig","cli","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"stopalopa","html":"<div class=\"paragraph\">\n<p>Natasha is a Master&#8217;s student at Penn State University. She was accepted to Google Summer of Code 2019 for a project on creating <a href=\"https://jenkins.io/projects/gsoc/2019/plugin-installation-manager-tool-cli/\">a plugin management tool</a>.\nIn her spare time she enjoys spending time outdoors, listening to podcasts and cuddling with her cat.</p>\n</div>","id":"stopalopa","irc":null,"linkedin":null,"name":"Natasha Stopa","slug":"blog/author/stopalopa","twitter":"stopamine"}]}},{"node":{"date":"2019-07-21T00:00:00.000Z","id":"e7a046ff-9ae1-585e-826a-dc8f41a2ab04","slug":"/blog/2019/07/21/Jenkins-code-coverage-diff-for-pull-request/","strippedHtml":"Hello.\n\nAs you may know, during the last year GSoC Mr. Shenyu Zheng was working on the Jenkins Code Coverage API Plugin. With Mr. Zheng we made a change so the plugin now is able to check the difference in code coverage between pull requests and target branches.\n\nIn lots of projects it is a common practice to track if unit tests code coverage doesn’t decrease. So, with this plugin, you may skip separate services that track code coverage and have this feature right in your favorite CI system.\n\nHow it works\n\nWhen you build a PR in Jenkins, using plugins like Github or Bitbucket Branch Source, that use SCM API Plugin, your PR knows what target branch commit it is based on. (The commit may change because of Discover pull requests from origin strategies). To calculate the diff, when you publish your coverage from PR, it looks for the target branch build for the commit that your PR was based on. If it finds the build on the target branch, it looks for any published code coverage for this target branch build. In case the build has it, the plugin calculates the percentage diff for the line coverage and shows it on the pull request build page. Also, it gives you a link to the target branch build that was used for the comparison.\n\nThat it how it looks like:\n\nDecreased coverage\n\nIncreased coverage\n\nHow to enable code coverage diff for pull requests\n\nTo enable this behavior you need to publish your code coverage with the calculateDiffForChangeRequests flag equals true, like this:\n.Jenkinsfile\n\nnode(...) {\n  ...\n  // Here we are using the istanbulCoberturaAdapter\n  publishCoverage adapters: [istanbulCoberturaAdapter('cobertura-coverage.xml')],\n    sourceFileResolver: sourceFiles('NEVER_STORE'),\n    calculateDiffForChangeRequests: true\n\n  ...\n}\n\nLinks and Feedback\n\nIf you have some questions about this behavior, please ask me in email.\n\nYou are free to contribute to this plugin to make it better for everyone. There are a lot of interesting features that can be added and issues that can be solved. Also, you can write some new plugins for other code coverage formats that use the Code Coverage API plugin as a base.\n\nHere is the repo of the plugin - Code Coverage API Plugin\n\nThank you.","title":"Jenkins code coverage diff in pull requests","tags":["plugins","codecoverage"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"tempora-mutantur","html":"<div class=\"paragraph\">\n<p>Software developer from Minsk, Belarus.</p>\n</div>","id":"asavanchuk","irc":null,"linkedin":null,"name":"Aliaksei Savanchuk","slug":"blog/author/asavanchuk","twitter":null}]}},{"node":{"date":"2019-07-15T00:00:00.000Z","id":"41025c8c-be64-5725-9360-c21fc24cca93","slug":"/blog/2019/07/15/pipeline-config-history-plugin/","strippedHtml":"Pipelines are the efficient and modern way how to create jobs in Jenkins.\nTo recognize pipeline changes quickly and easily, we developed the Pipeline Configuration History plugin.\nThis plugin detects changes of pipelines and provides the user an option to view changes between two builds (diffs) of pipeline configurations visibly and traceably.\n\nHow everything started\n\nIt all started 10 years ago — with classical job types (e.g. Freestyle, Maven, etc.).\nEvery once in a while users contacted us because their jobs failed to build overnight.\nWhy did the job fail?\nWas the failure related to a job configuration change?\nThe users' typical answer was: \"We didn’t change anything!\", but is that really true?\nWe thought about this and decided to develop a plugin that helped us solve this problem.\nThis was the idea and the beginning of Job Configuration History.\n\nNow it was possible to view changes of job configurations (like other branches, JDK versions, etc.) and more often the reason for breaking builds were changes of job configurations.\n\nOver the years the plugin got developed and is still under development.\nNew functions were added, that not only view job configurations, but also changes of global and agent configurations.\nIt is also possible to recover old configuration versions.\nToday the plugin has more than 30,000 installations.\nFor many years JobConfigHistory relieves our daily work — with more than 3,000 Jenkins jobs!\nThen there was a new type of job: Pipelines.\n\nPipelines - something new was needed\n\nPipeline jobs are fundamentally different than classical job types .\nWhile classic job types are configured via the Jenkins GUI, Pipeline jobs are configured as code.\nEvery pipeline job indeed gets created via the Jenkins GUI, however that is not necessarily where the pipeline configuration is located.\nPipelines can be configured:\n\nDirectly in the Jenkins job as script.\nThe code gets inserted directly in the job configuration page.\n\nAs Jenkinsfile in the source code management system (SCM): The pipeline configuration is defined in a text file (Jenkinsfile) in the SCM.\nIn the job itself only the path to the repository of the Jenkinsfile is configured.\nDuring the build the Jenkinsfile gets checked out from the SCM and processed.\n\nAs a shared library: A part of the pipeline configuration gets moved to separate files that can be used by several jobs.\nThese files are also saved in the SCM.\nEven so a Jenkinsfile is still needed (or a pipeline script in the job).\n\nWith every save operation of the job configuration, JobConfigHistory creates a copy of the actual job configuration if something has changed.\nThat only works for pipeline jobs if the pipeline configuration is inserted in the job configuration page as script.\nChanges in the Jenkinsfile or the shared libraries are not detected by JobConfigHistory.\nYou have to use the SCM system to view changes of the Jenkinsfile or the shared libraries.\nIt is complex and time intensive to find a correlation between the time of a build and a change to the Jenkinsfile or shared library.\n\nThis new problem is much more than JobConfigHistory.  A new solution was needed to detect pipeline changes and show these changes in Jenkins.\nSo we developed Pipeline Configuration History.\n\nDuring every pipeline run the Jenkinsfile and related shared libraries are saved in the builds directory of the job.\nPipeline Configuration History saves changes of the pipeline files between the last run and the previous run as history events.\nTherefore when a pipeline job ceases to build successfully, you can check if something has changed on any used pipeline file.\nYou can also see the build where changes occurred.\n\nBecause a pipeline configuration can consist of several files where changes could have occurred, only files with changes between two builds are shown in the diff.\nThat makes the whole thing more compact and effective:\n\nBut sometimes you may want to show more than the differences between pipeline files.  You may want to see which pipeline files are in use or the content of those files when they were used.\nSo it’s possible to view all files and their content.\nIf required you can download them as well:\n\nConclusion\n\nWe use Pipeline Configuration History successfully in production. It has helped us from the very first day as we solved problems that occurred due to pipeline configuration changes.\nPipeline Configuration History won’t replace Job Configuration History.\nThe plugins have different use cases.\nMany times small changes on job or pipeline configurations also have big impacts.\nBecause of the correlation in time between changes of job or pipeline configurations and different build behavior, it is now possible to substantially reduce the time and effort to analyze build failures.\nThe Job Configuration History and Pipeline Configuration History plugins let us help our users in consulting and in solving issues.  We resolve problems much faster through easy access to the configuration history of jobs.  These plugins are essential for our daily work.","title":"Introducing the Pipeline Configuration History Plugin","tags":["pipeline","plugins"],"authors":[{"avatar":null,"blog":null,"github":"Jochen-A-Fuerbacher","html":"<div class=\"paragraph\">\n<p>Jochen is a software developer for development infrastructure at 1&amp;1 Telecommunication.\nHe has been working with Jenkins for many years and develops some Jenkins plugins.</p>\n</div>","id":"jochenafuerbacher","irc":null,"linkedin":null,"name":"Jochen A. Fürbacher","slug":"blog/author/jochenafuerbacher","twitter":null},{"avatar":null,"blog":null,"github":"stefanbrausch","html":"<div class=\"paragraph\">\n<p>Stefan is a software developer for development infrastructure at 1&amp;1 Telecommunication.\nHe has been working with Jenkins for many years and develops some Jenkins plugins.</p>\n</div>","id":"stefanbrausch","irc":null,"linkedin":null,"name":"Stefan Brausch","slug":"blog/author/stefanbrausch","twitter":null},{"avatar":null,"blog":null,"github":"RobinRSchulz","html":"<div class=\"paragraph\">\n<p>Robin is a software developer for development infrastructure at 1&amp;1 Telecommunication.\nHe has been working with Jenkins for many years and develops some Jenkins plugins.</p>\n</div>","id":"robinrschulz","irc":null,"linkedin":null,"name":"Robin Schulz","slug":"blog/author/robinrschulz","twitter":null}]}},{"node":{"date":"2019-07-09T00:00:00.000Z","id":"e038d6ca-3dd1-5904-9bf3-e30e4baa0a9c","slug":"/blog/2019/07/09/Phase1-Updates-On-Working-Hours-Plugin/","strippedHtml":"The Working Hour Plugin provides an interface to set up a schedule of allowable build days and times.  Jobs that run outside of configured working hours are held until the next allowable build time.\n\nFor the first code phase at Google Summer of Code, I’ve been working on Working Hours Project, which needed improvements on usability.\n\nRather than classical Jelly pages, React seems to be more prefered when we want to design a much customized UI with a huge amount of libraries we could use, especially the open source components such as date pickers.\n\nBut we have to face a challenge of the integration of React and Jenkins, which I’m currently working on.\n\nAchievements For The First Code Phase\n\nFor the first code phase, we are focusing on the UI improvements, we’ve achieved following major improvements:\n\nA standalone webapp which could be then integrated.\n\nSlider for choosing a time range.\n\nMore fields when setting a excluded date.\n\nPresets for choosing a excluded date.\n\nA Jenkins styling UI.\n\nHow We Integrate React Into Jenkins\n\nA solution doc for integration could be found at\nhttps://drive.google.com/open?id=1JLRCDg9JNBWR0Dfq8w3pTI9mrl6i9JU29pBoH6bO0J8\n\nAt first, we found BlueOcean is a great example for using React in Jenkins, but yet it’s not a choice for common development with plugins. So we need to find out another way to integrate.\n\nHere are the steps to do the integration:\n\nA mount point in your jelly file, usually it’s a element with a unique id.\n\nWrite your React Application, but need to set the mount point to the id you set above.\n\nCopy the output after you build the Project into the plugin’s webapp dir.\n\nAdd your files using a script tag in your jelly file.\n\nOnce we are using React, the traditional jelly request won’t be available anymore, another way to process requests will be using stapler. You can define a process function like below.\n[source, java]\n\npublic HttpResponse doDynamic(StaplerRequest request) {\n        if (config == null) {\n            config = ExtensionList.lookup(WorkingHoursPlugin.class).get(0);\n        }\n        String restOfPath = request.getRestOfPath();\n        String[] pathTokens = restOfPath.split(\"/\");\n        List params = new ArrayList<>();\n        switch (params.get(0)) {\n            case \"list-excluded-dates\":\n                return listExcludedDate(request);\n            case \"set-excluded-dates\":\n                return setExcludedDates(request);\n            case \"list-time-ranges\":\n                return listTimeRanges(request);\n            case \"set-time-ranges\":\n                return setTimeRanges(request);\n        }\n    }\n\nRun Our Application\n\nIf you would like to take a look at our plugin, you can go to the repo\nworking-hours-plugin\n\nJust follow the README file, then you could run a copy of your working hours plugin.\n\nScreenshots\n\nThe current plugin’s outlook is a bit simple and the plugin is a bit unconvinient for use.\n\nOne of the problems is that if we want to input a excluded date, it’ll be a string in a constant format like 15/9/2019, but the new UI choosed React so we could use a datepicker to improve this.\n\nCurrent Plugin\n\nNew (Time Ranges)\n\nNew (Exclude Dates)\n\nHelpful links\n\nIf you have any questions or advices, we are glad to hear from you.\n\nSeveral useful links are listed below:\n\nDevelop Repo\n\nMain Repo\n\nDesign Doc\n\nDoc for React Integration Solution\n\nGitter Chat\n\nSlides for Phase 1 Demo\n\nVideo Recording for Phase 1","title":"GSOC Phase 1 Updates On Working Hours Plugin","tags":["react","plugins","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"ShenJack","html":"<div class=\"paragraph\">\n<p>Shen is a student from Beijing Forestry University. One of the students accepted to GSoC 2019.</p>\n</div>","id":"jackshen","irc":null,"linkedin":null,"name":"Jack Shen","slug":"blog/author/jackshen","twitter":null}]}},{"node":{"date":"2019-07-02T00:00:00.000Z","id":"535f2380-6f41-5360-bb77-129bf606e195","slug":"/blog/2019/07/02/plugin-management-tool-alpha-release/","strippedHtml":"\"Everybody is re-inventing the wheel, partially implementing the \"details\" of plugin management (signed metadata, artifacts checksums, plugins detached from core,…​).\nIt becomes obvious Jenkins should provide adequate tooling for plugin installation outside a live Jenkins instance.\" jira:JENKINS-53767[]\n\nMy Google Summer of Code project\ntries to solve this problem by creating a library that will unify plugin management logic across the different implementations\nof Jenkins and providing a CLI tool that will make it easy for users to download plugins and view plugin information before Jenkins even starts.\nI’m excited to share that we just released an alpha version that you can check out here!\n\nGSoC Phase 1 Update\n\nWhile I looked into pulling the Plugin Manager out of Jenkins core,\nthis ended up being a challenging first step due to the complexity and number of dependencies.  We instead decided to start by converting the\ninstall-plugins.sh bash script in Jenkins Docker to Java.\nThere are several issues with the install-plugins.sh script - namely, that it is a bash script and has limited extensibility.\nFurthermore, it does not retrieve all of the most-up-to-date update center metadata.\n\nAlpha Release Details\n\nMimicking what was done in the install-plugins.sh script from the official Jenkins Docker image, the new plugin management library takes in a list of plugins, their versions,\nand/or urls from which to download the plugins, and downloads the requested plugins and their dependencies. The plugins are downloaded from the update center\nto a specified directory, and can then be loaded into Jenkins. Currently, the plugins to be downloaded can be specified via a plugins.txt file and/or the -plugins cli option, but we plan to further expand the input formats that can be accepted.\nCustom version specifiers for different update centers are also supported.\n\nThe library will first check if any of the requested plugins are currently either installed in the user-specified download location or user-specified Jenkins war file.\nAlready installed plugins will be ignored or upgraded if a higher version is requested or required as a dependency.  After determining the plugin download URL, the library\nwill download the plugins and resolve and download their dependencies.\n\nThis is just the beginning: the plugin manager library and cli tool are very much still a work in progress.\nFor the most up-to-date information on CLI options and how to run the tool, see the repository README.md.\nMore robust input parsing, support for security warnings and available updates, Docker integration, and additional features coming soon!\n\nLinks and Feedback\n\nFeel free to reach out through\nthe Plugin Installation Manager CLI Tool Gitter chat or through\nthe Jenkins Developer Mailing list. I would love to get your questions, comments, and feedback!\nWe have meetings Tuesdays and Thursdays at 6PM UTC.\n\nPhase 1 Presentation Slides\n\nPhase 1 Recorded Demo\n\nJira Issue Search\n\nRepository","title":"Plugin Management Library and CLI Tool Alpha Release","tags":["plugins","pluginmanagement","platform-sig","cli","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"stopalopa","html":"<div class=\"paragraph\">\n<p>Natasha is a Master&#8217;s student at Penn State University. She was accepted to Google Summer of Code 2019 for a project on creating <a href=\"https://jenkins.io/projects/gsoc/2019/plugin-installation-manager-tool-cli/\">a plugin management tool</a>.\nIn her spare time she enjoys spending time outdoors, listening to podcasts and cuddling with her cat.</p>\n</div>","id":"stopalopa","irc":null,"linkedin":null,"name":"Natasha Stopa","slug":"blog/author/stopalopa","twitter":"stopamine"}]}},{"node":{"date":"2019-06-29T00:00:00.000Z","id":"7b06e02e-ca3c-5b58-8850-3e214fd8268e","slug":"/blog/2019/06/29/phase-1-multibranch-pipeline-support-for-gitlab/","strippedHtml":"This is one of the Jenkins project in GSoC 2019. We are working on adding support\nfor Multi-branch\nPipeline Jobs and Folder Organisation in GitLab. The plan is to create the following\nplugins:\n\nGitLab API Plugin - Wraps GitLab Java APIs.\n\nGitLab Branch Source Plugin - Contains two packages:\n\nio.jenkins.plugins.gitlabserverconfig - Manages server configuration and web hooks management.\nIdeally should reside inside another plugin with name GitLab Plugin. In future, this package should\nbe moved into a new plugin.\n\nio.jenkins.plugins.gitlabbranchsource - Adds GitLab Branch Source for Multi-branch Pipeline Jobs (including\nMerge Requests) and Folder organisation.\n\nPresent State\n\nFreeStyle Job and Pipeline(Single Branch) Job are fully supported.\n\nMulti-branch Pipeline Job is partially supported (no MRs detection).\n\nGitLab Folder Organisation is not supported.\n\nGoals of this project\n\nImplement a lightweight GitLab Plugin that depends on GitLab API Plugin.\n\nFollow convention of 3 separate plugins i.e. GitLab Plugin, GitLab API Plugin, GitLab Branch Source Plugin.\n\nImplement GitLab Branch Source Plugin with support for Multi-branch Pipeline Jobs.\n\nSupport new Jenkins features such as\nJenkins Code as Configuration (JCasC),\nIncremental Tools.\n\nClear & Efficient design.\n\nSupport new SCM Trait APIs.\n\nSupport Java 8 and above.\n\nBuilding the plugin\n\nNo binaries are available for this plugin as the plugin is in the very early alpha stage, and not ready for the general\npublic quite yet.  If you want to jump in early, you can try building it yourself from source.\n\nInstallation:\n\nCheckout source code to your local machine:\n\ngit clone https://github.com/baymac/gitlab-branch-source-plugin.git\n\ncd gitlab-branch-source-plugin\n\nInstall the plugin:\n\nmvn clean install\n\nmvn clean install -DskipTests # to skip tests\n\nRun the plugin:\n\nmvn hpi:run # runs a Jenkins instance at localhost:8080\n\nmvn hpi:run -Djetty.port= # to run on your desired port number\n\nIf you want to test it with your Jenkins server, after mvn clean install follow these steps in your Jenkins instance:\n\nSelect Manage Jenkins\n\nSelect Manage Plugins\n\nSelect Advanced tab\n\nIn Upload Plugin section, select Choose file\n\nSelect $ /target/gitlab-branch-source.hpi\n\nSelect Upload\n\nSelect Install without restart\n\nUsage\n\nAssuming plugin installation has done been already.\n\nSetting up GitLab Server Configuration on Jenkins\n\nOn jenkins, select Manage Jenkins\n\nSelect Configure System\n\nScroll down to find the GitLab section\n\nSelect Add GitLab Server | Select GitLab Server\n\nNow you will now see the GitLab Server Configuration options.\n\nThere are 4 fields that needs to be configured:\n\nName - Plugin automatically generates an unique server name for you. User may want to configure this field\nto suit their needs but should make sure it is sufficiently unique. We recommend to keep it as it is.\n\nServer URL - Contains the URL to your GitLab Server. By default it is set to \"https://gitlab.com\". User can\nmodify it to enter their GitLab Server URL e.g. https://gitlab.gnome.org/, http://gitlab.example.com:7990. etc.\n\nCredentials - Contains a list of credentials entries that are of type GitLab Personal Access Token. When\nno credential has been added it shows \"-none-\". User can add a credential by clicking \"Add\" button.\n\nWeb Hook - This field is a checkbox. If you want the plugin to setup a webhook on your GitLab project(s)\nrelated jobs, check this box. The plugin listens to a URL for the concerned GitLab project(s) and when an event\noccurs in the GitLab Server, the server sends an event trigger to the URL where the web hook is setup. If you\nwant continuous integration (or continuous delivery) on your GitLab project then you may want to automatically\nset it up.\n\nAdding a Personal Access Token Credentials (To automatically generate Personal Access Token see\nnext section):\n\nUser is required to add a GitLab Personal Access Token type credentials entry to securely persist the token\ninside Jenkins.\n\nGenerate a Personal Access Token on your GitLab Server:\n\nSelect profile dropdown menu from top-right corner\n\nSelect Settings\n\nSelect Access Token from left column\n\nEnter a name | Set Scope to api, read_user, read_repository\n\nSelect Create Personal Access Token\n\nCopy the token generated\n\nReturn to Jenkins | Select Add in Credentials field | Select Jenkins\n\nSet Kind to GitLab Personal Access Token\n\nEnter Token\n\nEnter a unique id in ID\n\nEnter a human readable description\n\nSelect Add\n\nTesting connection:\n\nSelect your desired token in the Credentials dropdown\n\nSelect Test Connection\n\nIt should return something like Credentials verified for user\n\nSelect Apply (at the bottom)\n\nGitLab Server is now setup on Jenkins\n\nCreating Personal Access Token within Jenkins\n\nAlternatively, users can generate a GitLab Personal Access Token within Jenkins itself and automatically add the\nGitLab Personal Access Token credentials to Jenkins server credentials.\n\nSelect Advanced at the bottom of GitLab Section\n\nSelect Manage Additional GitLab Actions\n\nSelect Convert login and password to token\n\nSet the GitLab Server URL\n\nThere are 2 options to generate token;\n\nFrom credentials - To select an already persisting Username Password Credentials or add an Username Password\ncredential to persist it.\n\nFrom login and password - If this is a one time thing then you can directly enter you credentials to the text boxes\nand the username/password credential is not persisted.\n\nAfter setting your username/password credential, select Create token credentials.\n\nThe token creator will create a Personal Access Token in your GitLab Server for the given user with the\nrequired scope and also create a credentials for the same inside Jenkins server. You can go back to the GitLab Server\nConfiguration to select the new credentials generated (select \"-none-\" first then new credentials will appear). For\nsecurity reasons this token is not revealed as plain text rather returns an id. It is a 128-bit long UUID-4 string\n(36 characters).\n\nConfiguration as Code\n\nNo need for messing around in the UI. Jenkins Configuration as Code (JCasC) or simply Configuration as Code Plugin\nallows you to configure Jenkins via a yaml file. If you are a first time user, you can learn more about JCasC\nhere.\n\nAdd configuration YAML:\n\nThere are multiple ways to load JCasC yaml file to configure Jenkins:\n\nJCasC by default searches for a file with the name jenkins.yaml in $JENKINS_ROOT.\n\nThe JCasC looks for an environment variable CASC_JENKINS_CONFIG which contains the path\nfor the configuration yaml file.\n\nA path to a folder containing a set of config files e.g. /var/jenkins_home/casc_configs.\n\nA full path to a single file e.g. /var/jenkins_home/casc_configs/jenkins.yaml.\n\nA URL pointing to a file served on the web e.g. /jenkins.yaml\" class=\"bare\">https:// /jenkins.yaml .\n\nYou can also set the configuration yaml path in the UI. Go to /configuration-as-code.\nEnter path or URL to jenkins.yaml and select Apply New Configuration.\n\nAn example of configuring GitLab server via jenkins.yaml :\n\ncredentials:\n  system:\n    domainCredentials:\n      - credentials:\n          - gitlabPersonalAccessToken:\n              scope: SYSTEM\n              id: \"i<3GitLab\"\n              token: \"XfsqZvVtAx5YCph5bq3r\" # gitlab personal access token\n\nunclassified:\n  gitLabServers:\n    servers:\n      - credentialsId: \"i<3GitLab\"\n        manageHooks: true\n        name: \"gitlab.com\"\n        serverUrl: \"https://gitlab.com\"\n\nFor better security, see handling secrets\nsection in JCasC\ndocumentation.\n\nFuture Scope of work\n\nThe second phase of GSoC will be utilized to develop GitLab Branch Source. The new feature is a work in progress, but\nthe codebase is unstable and requires lot of bugfixes. Some features like Multibranch Pipeline Jobs are functioning\nproperly. More about it at the end of second phase.\n\nIssue Tracking\n\nThis project uses Jenkins JIRA to track issues. You can file issues under\ngitlab-branch-source-plugin component.\n\nAcknowledgements\n\nThis plugin is built and maintained by the Google Summer of Code (GSoC) Team for\nMulti-branch Pipeline\nSupport for GitLab. A lot of inspiration was drawn from GitLab Plugin, Gitea Plugin and GitHub Plugin.\n\nOur team consists of: baymac, LinuxSuRen,\nMarky, Joseph,\nJustin, Jeff.\n\nWith support from: Oleg, Greg,\nOwen.\n\nAlso thanks to entire Jenkins community for contributing with technical expertise and inspiration.\n\nLinks\n\nPhase 1 demo\n\nPresentation slides\n\nGitLab API Plugin\n\nGitLab Branch Source Plugin\n\nGitLab API Plugin Wiki\n\nIssue Tracker for Phase 1\n\nBlog","title":"Multi-branch Pipeline Jobs Support for GitLab SCM","tags":["gitlab","plugins","pipeline","credentials","developer","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"baymac","html":"<div class=\"paragraph\">\n<p>GSoC 2019 student under Jenkins project. Maintainer of GitLab Branch Source Plugin. Software Developer at Udaan, India.</p>\n</div>","id":"baymac","irc":null,"linkedin":"parichay.barpanda","name":"Parichay Barpanda","slug":"blog/author/baymac","twitter":"baymac04"}]}},{"node":{"date":"2019-06-21T00:00:00.000Z","id":"b06db1a3-a822-5949-960f-cb7f3e69c3da","slug":"/blog/2019/06/21/performance-testing-jenkins/","strippedHtml":"I have been working on improving the performance of the Role Strategy Plugin as a part of my Google Summer of Code project.\nSince there was no existing way to measure performance and do benchmarks on Jenkins Plugins,\nmy work for the first phase of the project was to create a framework for running\nbenchmarks in Jenkins plugins with a Jenkins instance available. To make our job a bit easier,\nwe chose Java Microbenchmark Harness for running these benchmarks. This\nallows us to reliably measure performance of our time-critical functions and will help make Jenkins perform faster\nfor everyone.\n\nThe micro-benchmarking framework was recently released in the Jenkins Unit Test Harness 2.50.\nThe blog post below shows how to run benchmarks in your plugins.\n\nIntroduction\n\nThe framework runs works by starting a temporary Jenkins instance for each fork of the JMH benchmark,\njust like JenkinsRule from Jenkins Test Harness. Benchmarks are run directly from your JUnit Tests which allows\nyou to fail builds on the fly and easily run benchmarks from your IDE, just like unit tests. You can easily\nconfigure your benchmarks by either using your Java methods, or by using Jenkins Configuration-as-Code plugin\nand passing the path to your YAML file.\n\nTo run benchmarks from your plugins, you need to do the following:\n\nbump up the minimum required Jenkins version to 2.60.3 or above\n\nbump Plugin-POM to a version ≥ 3.46 or manually upgrade to Jenkins Test Harness ≥ 2.51.\n\nNow, to run the benchmarks, you need to have a benchmark runner that contains a @Test so it can run\nlike a JUnit test. From inside a test method, you can use the OptionsBuilder provided by JMH to\nconfigure your benchmarks. For example:\n\npublic class BenchmarkRunner {\n    @Test\n    public void runJmhBenchmarks() throws Exception {\n        ChainedOptionsBuilder options = new OptionsBuilder()\n                .mode(Mode.AverageTime)\n                .forks(2)\n                .result(\"jmh-report.json\");\n\n        // Automatically detect benchmark classes annotated with @JmhBenchmark\n        new BenchmarkFinder(getClass()).findBenchmarks(options);\n        new Runner(options.build()).run();\n    }\n}\n\nSample benchmarks\n\nNow, you can write your first benchmark:\n\nWithout any special setup\n\n@JmhBenchmark\npublic class JmhStateBenchmark {\n    public static class MyState extends JmhBenchmarkState {\n    }\n\n    @Benchmark\n    public void benchmark(MyState state) {\n        // benchmark code goes here\n        state.getJenkins().setSystemMessage(\"Hello world\");\n    }\n}\n\nUsing Configuration as Code\n\nTo use configuration as code, apart from the dependencies above you also need to add the following\nto your pom.xml :\n\nio.jenkins\nconfiguration-as-code\n1.21\ntrue\n\nio.jenkins\nconfiguration-as-code\n1.21\ntests\ntest\n\nNow configuring a benchmark is as simple as providing path to your YAML file and specifying the class\ncontaining the benchmark state.\n\n@JmhBenchmark\npublic class SampleBenchmark {\n    public static class MyState extends CascJmhBenchmarkState {\n        @NonNull\n        @Override\n        protected String getResourcePath() {\n            return \"config.yml\";\n        }\n\n        @NonNull\n        @Override\n        protected Class getEnclosingClass() {\n            return SampleBenchmark.class;\n        }\n    }\n\n    @Benchmark\n    public void benchmark(MyState state) {\n        Jenkins jenkins = state.getJenkins(); // jenkins is configured and ready to be benchmarked.\n        // your benchmark code goes here...\n    }\n}\n\nMore Samples\n\nAs a part of this project, a few benchmarks have been created in the Role Strategy Plugin which show\nconfiguring the instances for various situations. You can find them\nhere.\n\nRunning Benchmarks\n\nRunning benchmarks from Maven\n\nTo easily run benchmarks from Maven, a Maven profile to run the benchmarks has been created\nand is available starting Plugin-POM version 3.45. You can then run your benchmarks from the\ncommand line using mvn test -Dbenchmark.\n\nRunning benchmarks on ci.jenkins.io\n\nIf you have your plugins hosted on ci.jenkins.io, you can easily run benchmarks directly from your Jenkinsfile\nby using the runBenchmarks() method after the buildPlugin() step in your which is now available in\nJenkins Pipeline library.\nThis function also accepts the path to your generated JMH benchmark reports as an optional\nparameter and archives the benchmark results. Running benchmarks in pull request builds allows you to constantly\nmonitor the performance implications of a given change. For example, the Jenkinsfile from Role Strategy Plugin:\n\nbuildPlugin()\nrunBenchmarks('jmh-report.json')\n\nVisualizing benchmark results\n\nBenchmark reports generated (in JSON) can be visualized using the either the JMH Report Plugin\nor by passing the benchmark reports to the JMH visualizer web service. As an example, here is\na visualized report of some benchmarks from the Role Strategy Plugin:\n\nThese improvements seen above were obtained through a small pull request\nto the plugin and shows how even seemingly small changes can bring major performance improvements. Microbenchmarks\nhelp to find these hot-spots and estimate the impact of changes.\n\nSome tips and tricks\n\nSince BenchmarkRunner class name in the example above does not qualify as a test according to Maven surefire plugin’s\nnaming conventions, the benchmarks will not interfere with your JUnit tests.\n\nBenchmark methods need to be annotated by @Benchmark for JMH to detect them.\n\nClasses containing benchmarks are found automatically by the BenchmarkFinder\nwhen annotated with @JmhBenchmark.\n\nA reference to the Jenkins instance is available through either JmhBenchmarkState#getJenkins() or through\nJenkins.getInstance() like you would otherwise do.\n\nJmhBenchmarkState provides setup() and tearDown() methods which can be overridden to configure the\nJenkins instance according to your benchmark’s requirements.\n\nThe benchmark builds on ci.jenkins.io are currently throttled because of the limited availability of highmem nodes.\n\nThe benchmark framework was made available in Jenkins Test Harness 2.50, it is recommended to use version 2.51 as it includes some bug fixes.\n\nLinks and Feedback\n\nIf you have any feedback, comments or questions, please feel free to reach out to me through either\nthe Role Strategy Plugin Gitter chat or through\nthe Jenkins Developer Mailing list.\n\nPresentation slides\n\nDemo at Platform SIG meeting\n\nDocumentation for the micro-benchmark framework:\n\nWriting benchmarks (Jenkins Test Harness)\n\nPreconfiguring benchmarks using JCasC\n\nRunning benchmarks using Plugin POM profile\n\nBuild Step for running benchmarks on ci.jenkins.io","title":"Micro-benchmarking Framework for Jenkins Plugins","tags":["jmh","plugins","benchmark","performance","developer","gsoc","gsoc2019"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"AbhyudayaSharma","html":"<div class=\"paragraph\">\n<p>Abhyudaya is a Computer Science student at Shiv Nadar University, India.\nHe is participating in Google Summer of Code 2019 to improve the performance\nof the <a href=\"https://github.com/jenkinsci/role-strategy-plugin\">Role Strategy Plugin</a>.</p>\n</div>","id":"abhyudayasharma","irc":null,"linkedin":null,"name":"Abhyudaya Sharma","slug":"blog/author/abhyudayasharma","twitter":null}]}}]}},"pageContext":{"tag":"plugins","limit":8,"skip":24,"numPages":14,"currentPage":4}},
    "staticQueryHashes": ["3649515864"]}