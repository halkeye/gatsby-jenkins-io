{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/plugins",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2021-08-23T00:00:00.000Z","id":"b598f8c2-ebc7-5a4d-9b91-8a9ea0e5e989","slug":"/blog/2021/08/23/jenkins-operator-security-work-report/","strippedHtml":"Background\n\nJenkins custom resources on a Kubernetes cluster are deployed using declarative YAML configuration files; hence some of the plugins declared in these files may contain security warnings.\nSo there is no way for the user to know other than manually checking for each on the site.\nThis project aims to add an extra step of validation before creating/updating a new Jenkins Custom Resource.\n\nDeliverables\n\nThis project aims to add a validating admission webhook to the Jenkins Operator for Kubernetes to detect potential security vulnerabilities in the plugins before the object is created.\n\nDependencies\n\nWebhooks communicate to the API server over HTTPS and use TLS. Thus, Jetstack/cert-manager is used to provision TLS certificates and establish connection between Kubernetes API and webhook.\n\nImplementaion\n\nOperator-SDK takes care of creating a new webhook and appending it to the manager and creating handlers.\nTls certificates are managed using cert-manager.\n\nValidation Logic:\n\nProposed Implementations: Iterate through the list of plugins to be installed and fetch warnings for each plugin from the plugin center API and check if the version of that plugin has any of those warnings.\n\nCaveats: Webhooks add latency to an API request, hence they should evaluate as quickly as possible thus having max allowed timeout of 30s. In the earlier approach I was fetching the security warnings from the plugin site API in the validator interface itself, and since network operations are slow, it was causing a timeout in the case of validating a larger number of plugins or when the Internet connection was not good.\n\nUpdated Implementaion: Instead of fetching information for each plugin, the information about all the plugins is downloaded and cached at the start of the operator and updated periodically, thus eliminating network calls and finishing validation in less than a second.\n\nEvaluation Phase 1:\n\nScaffoled a new validation webhook\n\nAdded manifests for ValidatingWebhookConfiguration, certificates and volumes, and updated Makefile\n\nImplemented the validator interface\n\nUpdated helm charts\n\nEvaluation Phase 2:\n\nReimplemented the validator interface.\n\nAdded unit tests for internal functions\n\nAdded e2e tests along with helm tests\n\nUpdated helm charts\n\nResources\n\nPull Requests\n\nAdded validation webhook,manifests,and updated Makefile\n\nImplemented validation logic,added tests and updated helm charts\n\nPhase 1 demo\n\nUser Guide\n\nThe webhook feature is completely optional for the user. It can be easily deployed using Helm Chart by setting webhook.enabled in values.yaml and in the Operator command line flag.\n\nwebhook.enabled=true\n\nTo enable security validation in the jenkins custom resource set\n\njenkins.ValidateSecurityWarnings=true\n\nNote: The webhook takes some time to get up and running, also when helm renders the template, the validating webhook configuration is applied last, hence if the user wants to deploy the Jenkins Custom Resource with validation turned on, he needs to wait for some time. After the webhook is up and running the user can deploy the Jenkins Custom Resource using helm or kubectl\n\nFuture work\n\nImplementing a post-install hook in the helm charts that checks whether the webhook is up and running.\n\nAdding validation for required core version of plugin and core version of Jenkins.\n\nMigrating other validation logic from controller to the webhook.\n\nAdding validation for the dependencies of the plugins.","title":"Security Validator for Jenkins Operator for Kubernetes","tags":["gsoc21","kubernetes","security","plugins"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#a88848","images":{"fallback":{"src":"/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/67151/sharmapulkit04.jpg","srcSet":"/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/ede19/sharmapulkit04.jpg 32w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/bc20c/sharmapulkit04.jpg 64w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/67151/sharmapulkit04.jpg 128w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/f76df/sharmapulkit04.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/8ba60/sharmapulkit04.webp 32w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/a9ea7/sharmapulkit04.webp 64w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/8c23b/sharmapulkit04.webp 128w,\n/gatsby-jenkins-io/static/a0f57d401b1a73bd732b30a1dfa27287/fc98a/sharmapulkit04.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":131}}},"blog":null,"github":"sharmapulkit04","html":"<div class=\"paragraph\">\n<p>A Student at the Indian Institute of Technology(BHU) Varanasi, Pulkit is currently working on a GSoC Project under Jenkins where he aims to add a security validator to the Jenkins Kubernetes Operator.</p>\n</div>","id":"sharmapulkit04","irc":null,"linkedin":null,"name":"Pulkit Sharma","slug":"/blog/author/sharmapulkit04","twitter":"anarchist_04"}]}},{"node":{"date":"2021-06-21T00:00:00.000Z","id":"7b4a4572-df50-5808-b8c2-57dd18827c92","slug":"/blog/2021/06/21/student-luminy-project-security/","strippedHtml":"Context\n\nJenkins is a CI/CD solution and as such, it is critical that the open source plugins that constitute an integral part of it don‚Äôt expose the systems they are used on to any security risks and vulnerabilities.\nIt is in that context that we worked as an audit/code review team to track and report such flaws and problematic practices.\n\nWe worked in collaboration with Jenkins Security team member Wadeck Follonier, as part of an end-of-study project during our last year of the Master‚Äôs Degree - Reliability and IT Security in the university of Aix-Marseille.\n\nProject Goals\n\nThe main goal of this project was to allow us to discover and work on diverse security vulnerabilities in the context of a widely-used software solution, and in order to achieve that we had to separate the project in multiple other goals:\n\nLearning about some of the most common vulnerabilities and the form in which they can be found on a Jenkins Instance and its plugins.\n\nPerforming code review and technical audit on the application, and compiling our results as part of a security team.\n\nReporting our findings to the Jenkins team and the plugin maintainers, while sometimes helping the latter to correct these vulnerabilities.\n\nKnowledge Sharing\n\nAt the beginning of the project, we set up communication channels with our mentor through Slack and Google Meets, and agreed to schedule weekly sessions with him.\nThe goal of these sessions was both to teach us more about the functionalities of Jenkins and the types of vulnerabilities we would encounter, and to allow us to ask more specific questions regarding our findings.\n\nThanks to our mentor developing a mock plugin compiling a variety of classic vulnerabilities and several of their implementations, including server side request forgery ( SSRF), cross site scripting ( XSS), and XML external entity ( XXE) attacks, we have been able to learn through practice.\nIt allowed us to analyze the context of the code and the different ways the Jelly framework can be used to display information, expanding our payload options and giving us a clearer view of the patterns to look for during our code reviews.\n\nWe have also had the opportunity to learn about the process used to report the vulnerabilities to the maintainers through Jira issues, and some ways we could correct them or provide steps to do so.\n\nSearching and compiling\n\nAt first, we decided to work as a pretty loose team, with each member working on a different plugin and regrouping our findings to confirm or reject them, while staying in constant contact to ask each other questions.\nThis allowed us to broaden the scope of our searches, and is the reason why we have been able to find a larger number of vulnerabilities, in plugins that differed widely in popularity, than we would have working together from the start.\n\nWe used a single file to compile the plugins we audited and our findings, making it easier for our mentor to review them and give us feedback.\nPinpointing the specific portion of code causing the issue and providing reproduction steps as clear as we could proved useful for the reporting process, thus making the approval and correction faster.\n\nDuring the last third of this project, we began to work together on bigger plugins, in order to have more points of view reflecting on the same problem.\nWith different analyses, we were able to come up with new payloads, and sometimes with new vulnerabilities where we only found one separately.\n\nReporting and correcting the vulnerabilities\n\nAll of the reporting was done through Jira issues, which allows the Jenkins team to centralize and triage the vulnerabilities.\nOnce we provided the necessary information, along with the reproduction steps we had, a member of the Jenkins security team contacted the plugin maintainer and guided them through the next steps of the process, with hope that they would answer.\n\nWe have also tried to make the maintainers' job easier, working on some fixes.\nTo achieve this, we delved not only into the functionalities of the vulnerable plugins, but also into some mitigation processes that we found either in the Jenkins documentation,  or with the help of our mentor.\n\nEach one of our modifications has been tested locally, in order to assess whether the vulnerability was still present, and whether no function had been altered.\nHowever, some of the plugins we audited demanded more complex fixes, due to their intrinsic logic, or the thought process of their developer, which led to us being unable to provide a clear fix.\n\nConsidering this, the fixes we have been able to bring into light were only suggestions to the maintainers, for them to use as inspiration or template, in order not to interfere with the plugin logic.\n\nConclusion\n\nThrough this project, we have been able to work as a team, delving into some of the different issues that security engineers are bound to face, and the ways they have at their disposal to mitigate them.\nThis has allowed us to complement our studies with a more practical aspect, that we couldn‚Äôt have had otherwise, and to transition into the companies we are now interns in.\nThis experience has strongly encouraged us to improve in and document ourselves on this branch of cybersecurity, which will have a significant impact on our professional future.\n\nUseful links\n\nJenkins - 2021/03/30 Security Advisory - 5 from us\n\nJenkins - 2021/05/11 Security Advisory - 4 from us\n\nJenkins - 2021/05/25 Security Advisory - 3 from us\n\nJenkins - 2021/06/16 Security Advisory - 1 from us\n\nJenkins - 2021/06/18 Security Advisory - 1 from us\n\nMessage from the mentor\n\nI didn‚Äôt expect to have four students with a so deep desire to learn new things, new tricks.\nTheir curiosity helped them to find numerous vulnerabilities that already led to 14 published CVEs.\nThe experience was great and I wish them all the best for their professional career and their never ending quest for knowledge.\n\nIf you are student, intern, or just someone really interested in security and Jenkins in particularly, please reach out to us to see if there is a possibility to organize something together.\nMailing list: jenkinsci-cert@googlegroups.com","title":"Four students and their master project in Jenkins security","tags":["plugins","security","jenkins"],"authors":[{"avatar":null,"blog":null,"github":null,"html":"<div class=\"paragraph\">\n<p>Justin is a cybersecurity engineer who participated in a hands on project related to Jenkins security during his last year of master.</p>\n</div>","id":"jphilip","irc":null,"linkedin":"justin-philip-amu","name":"Justin Philip","slug":"/blog/author/jphilip","twitter":null},{"avatar":null,"blog":null,"github":null,"html":"<div class=\"paragraph\">\n<p>Kevin is a cybersecurity engineer who participated in a hands on project related to Jenkins security during his last year of master.</p>\n</div>","id":"kguerroudj","irc":null,"linkedin":"kevin-guerroudj","name":"Kevin Guerroudj","slug":"/blog/author/kguerroudj","twitter":null},{"avatar":null,"blog":null,"github":null,"html":"<div class=\"paragraph\">\n<p>Quentin is a cybersecurity engineer who participated in a hands on project related to Jenkins security during his last year of master.</p>\n</div>","id":"qparra","irc":null,"linkedin":null,"name":"Quentin Parra","slug":"/blog/author/qparra","twitter":null},{"avatar":null,"blog":null,"github":null,"html":"<div class=\"paragraph\">\n<p>Marc is a cybersecurity engineer who participated in a hands on project related to Jenkins security during his last year of master.</p>\n</div>","id":"mheyries","irc":null,"linkedin":null,"name":"Marc Heyries","slug":"/blog/author/mheyries","twitter":null}]}},{"node":{"date":"2021-05-20T00:00:00.000Z","id":"95f5c8b2-77be-5e34-b420-2968ceb655ee","slug":"/blog/2021/05/20/configure-plugins-with-jcasc/","strippedHtml":"This blog post is for anyone interested to know how to configure a plugin using the Jenkins Configuration as a Code (JCasC) plugin, more specifically, this blog will guide you to get the YAML equivalent of a plugin‚Äôs configuration and use it to do some changes to the plugin without using the Jenkins UI.\n\nIf you‚Äôre a beginner at JCasC and want to learn more about it, you can head over to the following resources to understand JCasC better:\n\nJCasC Documentation\n\nOverview of JCasC (Video Presentation)\n\nManage JCasC (DevOps World 2018)\n\nConfiguring your first plugin using JCasC (Video Demo)\n\nOverview\n\nSo, these are the steps we will be following to achieve our aim:\n\nBrief Introduction to jenkins.yaml file\n\nConfigure the plugin on the UI\n\nDownload the Configuration\n\nUpdate JCasC file locally\n\nLoad the jenkins.yaml file on the Jenkins server\n\nVerify the changes on the UI\n\nBrief Introduction to jenkins.yaml file\n\nThe jenkins.yaml file contains the configuration of the Jenkins instance in YAML format.\nThe JCasC plugin refers to this file to configure the Jenkins instance.\n\nThe default location of jenkins.yaml is $JENKINS_HOME/jenkins.yaml, from where it can be fetched into the Jenkins server whenever you apply a new configuration.\n\nDownload your jenkins.yaml file by going to Manage Jenkins Configuration as Code Download Configuration.\n\nMake sure this file is saved at location $JENKINS_HOME/jenkins.yaml.\n\nLet‚Äôs change the systemMessage field to:\n\nFigure 1. Updating the jenkins.yaml file\n\nReload the existing configuration to apply the system message change\n\nNow, go back to the Dashboard and you can see the updated System Message on top:\n\nFigure 2. Viewing the changes on Dashboard\n\nThis file will be used later to configure the plugin using JCasC.\n\nConfigure the plugin on the UI\n\nFor this demo, install the View Job Filters plugin.\n\nLet‚Äôs create a view by clicking on the New View option on the left side of the Dashboard.\n\nGive it a name (say, ‚ÄútestView‚Äù) and set its type to List View, and click on the OK button.\n\nFigure 3. Creating the View\n\nNow click on Add Job Filter to add any kind of filter, so let‚Äôs select Build Duration Filter and fill the field with any value (say, \"60\" minutes),\n\nFigure 4. Adding filter to the view\n\nClick on Apply Save.\n\nTo view the full configuration, check out your main jenkins.yaml configuration file, by clicking on Manage Jenkins Configuration as Code View Configuration\n\nGo to the views section in this YAML file to see details related to the view,\n\nFigure 5. Here, details regarding the view (which we just created) is visible\n\nDownload the Configuration\n\nNow that you have successfully configured your plugin by UI, let‚Äôs download the configuration by going to Manage Jenkins on the Dashboard, then click on Configuration as Code under \"System Configuration\".\n\nNow click on the Download Configuration button to save the configuration file locally.\n\nFigure 6. Downloading the Configuration\n\nUpdate JCasC file locally\n\nAdd some changes in your downloaded copy of the jenkins.yaml file, to see those changes being automatically reflected on the UI.\n\nFor demo purposes, let‚Äôs change the name to ‚ÄúYoutubeDemoView‚Äù and set the buildDurationMinutes as \"55\".\n\nFigure 7. Changing the View details locally\n\nSave the file.\n\nLoad the jenkins.yaml file on the Jenkins server\n\nNow to reflect the local changes done in the jenkins.yaml file onto the Jenkins server, click on the Reload existing configuration button.\n\nFigure 8. Applying the New Configuration to the Jenkins instance\n\nVerify the changes on the UI\n\nGo back to the main page by clicking on the Jenkins logo on the top-left side.\n\nAnd you will notice that the name of your view has been changed from \"testView\" to ‚ÄúYoutubeDemoView‚Äù,\n\nAnd the field value of Build Duration Filter has been changed from \"60\" to ‚Äú55‚Äù.\n\nThese two are the exact changes that we did locally in our jenkins.yaml file.\n\nFigure 9. Verifying the changes\n\nCongratulations! You‚Äôve successfully configured a plugin (‚ÄúView Job Filter‚Äù) automatically with the help of the ‚ÄúJenkins Configuration as Code‚Äù plugin! You can repeat the same process for other plugins as well.","title":"Configure Plugins with JCasC","tags":["jcasc","tutorial","plugins","yaml"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#586868","images":{"fallback":{"src":"/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/55658/dheerajodha.jpg","srcSet":"/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/3af71/dheerajodha.jpg 32w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/226ae/dheerajodha.jpg 64w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/55658/dheerajodha.jpg 128w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/3dc24/dheerajodha.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/bf13b/dheerajodha.webp 32w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/12101/dheerajodha.webp 64w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/e9db2/dheerajodha.webp 128w,\n/gatsby-jenkins-io/static/7f342743d9a8f15cb84f0a2630efe0c5/6fafe/dheerajodha.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":145}}},"blog":null,"github":"dheerajodha","html":"<div class=\"paragraph\">\n<p>Dheeraj is a Computer Science Engineering student (senior) at Vivekanand Institute of Technology, University of Mumbai. He started his journey of contributing to Jenkins in March 2021. His tiny contributions revolve around the <a href=\"https://github.com/jenkinsci/custom-distribution-service\">Custom Distribution Service for Jenkins Project</a>. He also likes to contribute to the JCasC project and documentation to help the developers.</p>\n</div>","id":"dheerajodha","irc":null,"linkedin":"dheeraj-singh-jodha","name":"Dheeraj Singh Jodha","slug":"/blog/author/dheerajodha","twitter":null}]}},{"node":{"date":"2020-08-31T00:00:00.000Z","id":"6bac69c5-68d0-5291-8064-51a2296a084b","slug":"/blog/2020/08/31/github-checks-api-plugin-coding-phase-3/","strippedHtml":"This blog post is about our phase 3 progress on GitHub Checks API Project, you can find our previous blog posts for phase 1 and phase 2.\n\nAt the end of this summer, the GSoC journey for GitHub Checks API Project comes to an end as well.\nIn this blog post, I‚Äôll show you our works during the last month:\n\nPipeline Support\n\nRerun Request Support\n\nGit SCM Support\n\nDocumentation\n\nAll the above features will be available in our planned 1.0.0 version of Checks API Plugin and GitHub Checks Plugin.\n\nCoding Phase 3 Demo\n\nPipeline Support\n\nThe pipeline support allows users to directly publish checks in their pipeline script without depending on any other consumers.\n\nThe check in the above screenshot is published by script:\n\npublishChecks name: 'pipeline check', title: 'pipeline ', summary: '# A pipeline check example',\n        text: \"## This check is published through the pipeline script\",\n        detailsURL: 'https://ci.jenkins.io'\n\nIf you want to publish checks to GitHub, please install the GitHub implementation and refer to the GitHub API documentation for the requirements for each field. A default value (build link) for detailsURL will be provided automatically.\n\nThis feature can be useful when many stages exist in your pipeline script and each takes a long time: you can publish a check for each stage to keep track of the build.\n\nRerun Request Support\n\nThe rerun request allows GitHub users to rerun the failed builds. When a build failed (which leads to a failed check), a Re-run button will be added automatically by GitHub.\n\nBy clicking the Re-run button, Jenkins will reschedule a build for the last commit of this branch.\n\nSince all checks of a commit are produced by a single build, you don‚Äôt have to rerun all failed checks, just rerun any one of the failed check will refresh all checks.\n\nGit SCM Support\n\nThanks to Ullrich 's great help, the GitHub Checks Plugin now supports Git SCM.\nThis means now you can publish checks for your freestyle project or any other projects that use Git SCM.\n\nDocument\n\nConsumers Guide and Implementation Guide are now available.\nAs a Jenkins developer, you can now start consuming our API or even providing an implementation for other SCM platforms beside GitHub.\n\nAcknowledgment\n\nThe whole GitHub Checks API project is started as a Google Summer of Code project. Much appreciate my mentors ( Tim and Ullrich) for their great help during the whole summer. Also huge thanks to the Jenkins GSoC SIG and the whole community for the technique support and resources.\n\nResources\n\nChecks API Plugin\n\nGitHub Checks Plugin\n\nProject Page\n\nGitter Channel","title":"GitHub Checks API Plugin Project - Coding Phase 3","tags":["github","api","plugins","developer","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg","srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/77b35/XiongKezhi.jpg 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/d4a57/XiongKezhi.jpg 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/68974/XiongKezhi.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/ef6ff/XiongKezhi.webp 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/8257c/XiongKezhi.webp 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/6766a/XiongKezhi.webp 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/22bfc/XiongKezhi.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"XiongKezhi","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 Student. Kezhi is an open source enthusiast who enjoys sharing ideas with other developers. He started contributing to Jenkins in March 2020. Currently, he is working on <a href=\"https://github.com/XiongKezhi/checks-api-plugin\">GitHub Checks API Plugin</a>.</p>\n</div>","id":"XiongKezhi","irc":null,"linkedin":"kezhi-xiong-44234a188","name":"Kezhi Xiong","slug":"/blog/author/xiongkezhi","twitter":"AugustX_"}]}},{"node":{"date":"2020-08-29T00:00:00.000Z","id":"a6cfa2b5-a75a-5920-892a-2548994c1318","slug":"/blog/2020/08/29/git-performance-improvement-phase3/","strippedHtml":"Since the beginning of the project, the core value which drove its progress was \"To enhance the user experience for running Jenkins jobs by reducing the overall execution time\".\n\nTo achieve this goal, we laid out a path:\n\nCompare the two existing git implementations i.e CliGitAPIImpl and JGitAPIImpl using performance benchmarking\n\nUse the results to create a feature which would improve the overall performance of git plugin\n\nAlso, fix existing user reported performance issues\n\nLet‚Äôs take a journey to understand how we‚Äôve built the new features. If you‚Äôd like to skip the journey part, you can directly go to the [major performance improvements] section and the [minor performance section] to see what we‚Äôve done!\n\nJourney to release\n\nThe project started with deciding to choose a git operation and then trying to compare the performance of that operation by using command line git and then with JGit.\n\nStage 1: Benchmark results with git fetch\n\nThe performance of git fetch (average execution time/op) is strongly correlated to the size of a repository\n\nThere exists an inflection point on the scale of repository size after which the nature of JGit performance changes (it starts to degrade)\n\nAfter running multiple benchmarks, it is safe to say that for a large sized repository command line git would be a better choice of implementation.\n\nWe can use this insight to implement a feature which avoids JGit with large repositories.\n\nStage 2: Comparing platforms\n\nThe project was also concerned that there might be important differences between operating systems.\nFor example, what if command line Git for Windows performed very differently than command line Git on Linux or FreeBSD?\nBenchmarks were run to compare fetch performance on several platforms.\n\nRunning git fetch operation for a 400 MiB sized repository on:\n\nAMD64 Microsoft Winders\n\nAMD64 FreeBSD\n\nIBM PowerPC 64 LE Ubuntu 18\n\nIBM System 390 Ubuntu 18\n\nThe result of running this experiment is given below:\n\nThe difference in performance between git and JGit remains constant across all platforms.\n\nBenchmark results on one platform are applicable to all platforms.\n\nStage 3: Performance of git fetch and repository structure\n\nThe area of the circle enclosing each parameter signifies the strength of the positive correlation between the performance of a git fetch operation and that parameter. From the diagram:\n\nSize of the aggregated objects is the dominant player in determining the execution time for a git fetch\n\nNumber of branches and Number of tags play a similar role but are strongly overshadowed by size of repository\n\nNumber of commits has a negligible effect on the performance of running git fetch\n\nAfter running these experiments from Stage-1 to Stage-3, we developed a solution called the GitToolChooser which is explained in the next stage\n\nStage 4: Faster checkout with Git tool chooser\n\nThis feature takes the responsibility of choosing the optimal implementation from the user and hands it to the plugin. It takes the decision of recommending an implementation on the basis of the size of the repository. Here is how it works.\n\nThe image above depicts the performance enhancements we have performed over the course of the GSoC project. These improvements have enabled the checkout step to be finished within half of what it used to take earlier in some cases.\n\nLet‚Äôs talk about performance improvements in two parts.\n\nMajor performance improvements\n\nBuilding Tensorflow (~800 MiB) using a Jenkins pipeline, there is over 50% reduction in overall time spent in completing a job!\nThe result is consistent multiple platforms.\n\nThe reason for such a decrease is the fact that JGit degrades in performance when we are talking about large sized repositories. Since the GitToolChooser is aware of this fact, it chooses to recommend command line git instead which saves the user some time.\n\nMinor performance improvements\n\nNote: Enable JGit before using the new performance features to let GitToolChooser work with more options ‚Üí Here‚Äôs how\n\nBuilding the git plugin (~ 20 MiB) using a Jenkins pipeline, there is a drop of a second across all platforms when performance enhancement is enabled. Also, eliminating a redundant fetch reduces unnecessary load on git servers.\n\nThe reason for this change is the fact that JGit performs better than command line git for small sized repositories (<50MiB) as an already warmed up JVM favors the native Java implementation.\n\nReleases\n\nGit Plugin 4.4.0\n\nAdd GitToolChooser\n\nRemove redundant fetch\n\nGit Client Plugin 3.4.0\n\nAdd support to communicate compatibility of JGit with certain additional SCM behaviors\n\nThe road ahead\n\nSupport from other branch source plugins\n\nPlugins like the GitHub Branch Source Plugin or GitLab Branch Source Plugin need to extend an extension point provided by the git plugin to facilitate the exchange of information related to size of a remote repository hosted by the particular git provider\n\nJENKINS-63519 : GitToolChooser predicts the wrong implementation\n\nAddition of this feature to GitSCMSource\n\nDetection of lock related delays accessing the cache directories present on the controller\n\nThis issue was reported by the plugin maintainer Mark Waite, there is a need to reproduce the issue first and then find a possible solution.\n\nReaching out\n\nFeel free to reach out to us for any questions or feedback on the project‚Äôs\nGitter Channel or the\nJenkins Developer Mailing list.\nReport an issue at Jenkins Jira.\n\nUseful Links\n\nPhase 1 Blog: https://www.jenkins.io/blog/2020/07/09/git-performance-improvement-phase1/\n\nPhase 2 Blog: https://www.jenkins.io/blog/2020/07/29/git-performance-improvement-phase2/\n\nProject Page: https://www.jenkins.io/projects/gsoc/2020/projects/git-plugin-performance/\n\nDemonstration","title":"Git Plugin Performance Improvement: Final Phase and Release","tags":["plugins","git","platform-sig","developer","performance","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#685848","images":{"fallback":{"src":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg","srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/77b35/rishabhbudhouliya.jpg 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/d4a57/rishabhbudhouliya.jpg 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/19e71/rishabhbudhouliya.jpg 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/68974/rishabhbudhouliya.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/ef6ff/rishabhbudhouliya.webp 32w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/8257c/rishabhbudhouliya.webp 64w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/6766a/rishabhbudhouliya.webp 128w,\n/gatsby-jenkins-io/static/32fa8462b37abd3e057f4b70f0558972/22bfc/rishabhbudhouliya.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"rishabhBudhouliya","html":"<div class=\"paragraph\">\n<p>GSoC 2020 student under the Jenkins project (Git Plugin Performance Improvements).\nAspiring to be better at Software Development and participate more in the open source\ncommunity.</p>\n</div>","id":"rishabhbudhouliya","irc":null,"linkedin":null,"name":"Rishabh Budhouliya","slug":"/blog/author/rishabhbudhouliya","twitter":null}]}},{"node":{"date":"2020-08-27T00:00:00.000Z","id":"c3c50d8e-f813-526e-9f03-e29284122a65","slug":"/blog/2020/08/27/machine-learning-plugin-coding-phase3/","strippedHtml":"Good to see you all again !\n\nThis is my final blog post about coding phase 3 in Jenkins Machine Learning Plugin for GSoC 2020.\nBeing at the end of GSoC 2020, we had to finish all the pending issues and testing before a stable release in the main repository. Throughout this program, there were lots of learning and hard work will make this plugin valuable to the Data Science and Jenkins community.\n\nSummary\n\nWith combining all of the work in phase 1, 2 and 3, initial version of Machine learning plugin( 1.0 ) was successfully released in Jenkins plugin repository.\nAn interesting feature which allows users to connect to their existing programming language kernels more than connecting to only IPython kernel was introduced in this phase. It can be selected in multiple steps with different kernel.\nImages and graphs produced by Jupyter notebooks will be saved in user preferred folder in the workspace that can be used for reporting/analytic purposes later. Hoping this blog summarizes the Machine Learning‚Äôs features and future contributions. Thank you for your interest and support !!!\n\nMain features of Machine Learning plugin\n\nExecute Jupyter notebooks directly\n\nRun different language scripts using multiple build steps\n\nConvert Jupyter Notebooks to Python\n\nConfigure Jupyter kernels( IPython, IRKernel, IJulia etc) properties\n\nSupport to execute Notebooks/scripts on Agent\n\nExtract graph/map/images from the code\n\nEach build step can be associated with a machine learning task\n\nSupport for Windows and Linux\n\nFuture improvements\n\nImproving performance of the plugin\n\nTry to implement jira:JENKINS-63377[]\n\nSupport parameterized definitions in Notebooks jira:JENKINS-63478[]\n\nIncreasing testing code coverage\n\nMultiple language kernel support\n\nIf there are existing kernels in the system, user will be able to configure in the global configurations in order to apply in the builder/step configuration.\n\nSome popular interactive kernels\n\nIPython for python\n\nIRKernel for R\n\nIJulia for Julia\n\nIJavascript for javascript\n\nMore kernels and installation guides are found here. https://github.com/jupyter/jupyter/wiki/Jupyter-kernels\n\nDump images and graphs\n\nText output will be displayed in the console log. At the same time images/graphs/heat maps and HTMLs will be saved in the workspace. An action is shown in the left panel to display images in realtime. Due to the Content Security Policy of jenkins, some HTMLs which contain harmful javascript may not render in jenkins UI.\n\nFixed bugs\n\nThere were more bugs identified and fixed with many interactive testings. Setting the working directory of kernels was a big issue while getting datasets/files by script. Zeppelin process launcher was bypassed to fix this issue.\n\nPatch version released\n\nA major bug which was created while setting the process working directory had patched in the v1.0.1. The latest release is more stable now.\n\nAcknowledgement\n\nMachine Learning plugin had been developed under GSoC 2020 program. A huge thanks to Bruno P. Kinoshita, Marky Jackson, Shivay Lamba, Ioannis Moutsatsos and Org admins for this wonderful experience.\nI would be grateful for contributing this plugin continuously and more in Jenkins.\n\nResources\n\nCommunity Bonding blog post\n\nPhase 1 blog post\n\nPhase 2 blog post\n\nGithub\n\nProject page\n\nPlugin page\n\nDesign document","title":"Machine Learning Plugin project - Coding Phase 3 blog post","tags":["machinelearning","datascience","jupyter","plugins","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/63ad2/loghijiaha.jpg","srcSet":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/9b030/loghijiaha.jpg 32w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/f38b5/loghijiaha.jpg 64w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/63ad2/loghijiaha.jpg 128w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/bcd2b/loghijiaha.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/ceea6/loghijiaha.webp 32w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/45b82/loghijiaha.webp 64w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/933cd/loghijiaha.webp 128w,\n/gatsby-jenkins-io/static/75c9c309d675728b2e2735d64a019887/6c13d/loghijiaha.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":158}}},"blog":null,"github":"loghijiaha","html":"<div class=\"paragraph\">\n<p>Computer Science and Engineering Student at University of Moratuwa, Sri Lanka. He has been selected for Machine Learning plugin for Data Science in GSoC 2020 for Jenkins project. Hightly interested and contributing on open source projects.</p>\n</div>","id":"loghijiaha","irc":null,"linkedin":"loghi","name":"Loghi Perinpanayagam","slug":"/blog/author/loghijiaha","twitter":"loghi5"}]}},{"node":{"date":"2020-08-25T00:00:00.000Z","id":"7a744457-8457-529e-9c68-1e00d5e790df","slug":"/blog/2020/08/25/external-fingerprint-storage-phase-3/","strippedHtml":"The final phase for the External Fingerprint Storage\nProject has come to an end and to finish off, we release one more fingerprint storage plugin:\nthe PostgreSQL Fingerprint Storage Plugin!\n\nThis post highlights the progress made during phase-3.\nTo understand what the project is about and the past progress, please refer to the\nphase-1 post and the\nphase-2 post.\n\nIntroducing the PostgreSQL Fingerprint Storage Plugin\n\nWhy PostgreSQL?\n\nThere were several reasons why it made sense to build another reference implementation, especially backed by PostgreSQL.\n\nRedis is a key-value storage, and hence stores the fingerprints as blobs.\nThe PostgreSQL plugin defines a relational structure for fingerprints.\nThis offers a more powerful way to query the database for fingerprint information.\nFingerprint facets can store extra information inside the fingerprints, which cannot be queried in Redis directly.\nPostgreSQL plugin allows powerful (indexing) and efficient querying strategies which can even query the facet metadata.\n\nAnother reason for building this plugin was to provide a basis for other relational database plugins to be built.\nIt also validates the flexibility and design of our external fingerprint storage API.\n\nSince PostgreSQL is a traditional disk storage database, it is more suitable for systems storing a massive number of\nfingerprints.\n\nAmong relational databases, PostgreSQL is quite popular, has extensive support, and is open-source.\nWe expect the new implementation to drive more adoption, and prove to be beneficial to the community.\n\nInstallation:\n\nThe plugin can be installed using the\nexperimental update center.\nFollow along the following steps after running Jenkins to download and install the plugin:\n\nSelect Manage Jenkins\n\nSelect Manage Plugins\n\nGo to Advanced tab\n\nConfigure the Update Site URL as: https://updates.jenkins.io/experimental/update-center.json\n\nClick on Submit, and then press the Check Now button.\n\nGo to Available tab.\n\nSearch for PostgreSQL Fingerprint Storage Plugin and check the box along it.\n\nClick on Install without restart\n\nThe plugin should now be installed on the system.\n\nUsage\n\nOnce the plugin has been installed, you can configure the PostgreSQL server details by following the steps below:\n\nSelect Manage Jenkins\n\nSelect Configure System\n\nScroll to the section Fingerprints and choose PostgreSQL Fingerprint Storage in the dropdown for\nFingerprint Storage Engine.\n\nConfigure the following parameters to connect to your PostgreSQL instance:\n\nHost - Enter hostname where PostgreSQL is running\n\nPort - Specify the port on which PostgreSQL is running\n\nSSL - Click if SSL is enabled\n\nDatabase Name - Specify the database name inside the PostgreSQL instance to be used. Please note that the database\nwill not be created by the plugin, the user has to create the database.\n\nConnection Timeout - Set the connection timeout duration in seconds.\n\nSocket Timeout - Set the socket timeout duration in seconds.\n\nCredentials - Configure authentication using username and password to the PostgreSQL instance.\n\nUse the Test PostgreSQL Connection button to verify that the details are correct and Jenkins is able to connect to\nthe PostgreSQL instance.\n\n[IMPORTANT] When configuring the plugin for the first time, it is highly important to press the Perform PostgreSQL\nSchema Initialization button. It will automatically perform schema initialization and create the necessary indexes.\nThe button can also be used in the case the database is wiped out and schema needs to be recreated.\n\nPress the Save button.\n\nNow, all the fingerprints produced by this Jenkins instance should be saved in the configured PostgreSQL instance!\n\nQuerying the Fingerprint Database\n\nDue to the relational structure defined by PostgreSQL, it allows users/developers to query the fingerprint data which\nwas not possible using the Redis fingerprint storage plugin.\n\nThe fingerprint storage can act as a consolidated storage for multiple Jenkins instances.\nFor example, to search for a fingerprint id across Jenkins instances using the file name, the following query could be\nused:\n\nSELECT fingerprint_id FROM fingerprint.fingerprint\nWHERE filename = 'random_file';\n\nA sample query is provided which can be tweaked depending on the parameters to be searched:\n\nSELECT * FROM fingerprint.fingerprint\nWHERE fingerprint_id = 'random_id'\n        AND instance_id = 'random_jenkins_instance_id'\n        AND filename = 'random_file'\n        AND original_job_name = 'random_job'\n        AND original_job_build_number = 'random_build_number'\n        AND timestamp BETWEEN '2019-12-01 23:59:59'::timestamp AND now()::timestamp\n\nThe facets are stored in the database as jsonb.\nPostgreSQL offers support to query jsonb.\nThis is especially useful for querying the information stored inside fingerprint facets.\nAs an example, the Docker Traceability Plugin stores information like the name of Docker images inside these\nfacets.\nThese can be queried across Jenkins instances like so:\n\n>'imageName' = 'random_container';\n\nAt the moment these queries require working knowledge of the database.\nIn future, these queries can be abstracted away by plugins and the features made available to users directly inside\nJenkins.\n\nDemo\n\nExternal Fingerprint Storage Demo\n\nSlide deck\n\nReleases üöÄ\n\nWe released the 0.1-alpha-1 version for the\nPostgreSQL Fingerprint Storage Plugin.\nPlease refer to the\n\nchangelog for more information.\n\nRedis Fingerprint Storage Plugin 1.0-rc-3 was also\nreleased.\nThe\n\nchangelog provides more details.\n\nA few API changes made in the Jenkins core were released in Jenkins-2.253.\nIt mainly includes exposing fingerprint range set serialization methods for plugins.\n\nFuture Directions\n\nThe relational structure of the plugin allows some performance improvements that can be made when implementing\ncleanup, as well as improving the performance of Fingerprint#add(String job, int buildNumber).\nThese designs were discussed and are a scope of future improvement.\n\nThe current external fingerprint storage API supports configuring multiple Jenkins instances to a single storage.\nThis opens up the possibility of developing traceability plugins which can track fingerprints across Jenkins instances.\n\nPlease consider reaching out to us if you feel any of the use cases would benefit you, or if you would like to share\nsome new use cases.\n\nAcknowledgements\n\nThe PostgreSQL Fingerprint Storage Plugin and the Redis Fingerprint Storage plugin are maintained by the\nGoogle Summer of Code (GSoC) Team for External\nFingerprint Storage for Jenkins.\nSpecial thanks to Oleg Nenashev,\nAndrey Falko, Mike Cirioli,\nTim Jacomb, and the entire Jenkins community for all the contribution to this project.\n\nAs we wrap up, we would like to point out that there are plenty of future directions and use cases for the externalized\nfingerprint storage, as mentioned in the previous section, and we welcome everybody to contribute.\n\nReaching Out\n\nFeel free to reach out to us for any questions, feedback, etc. on the project‚Äôs\nGitter Channel or the\nJenkins Developer Mailing list.\nWe use Jenkins Jira to track issues.\nFeel free to file issues under either the postgresql-fingerprint-storage-plugin or the\nredis-fingerprint-storage-plugin component depending on the plugin.\n\nOther Links\n\nPhase 1 Post\n\nPhase 2 Post\n\nPostgreSQL Fingerprint Storage Plugin\n\nRedis Fingerprint Storage Plugin\n\njep:226[]\n\nGitter Channel\n\nProject Page","title":"External Fingerprint Storage Phase-3 Update: Introducing the PostgreSQL Fingerprint Storage Plugin","tags":["plugins","fingerprint","cloud-native","external-storage","developer","PostgreSQL","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#281818","images":{"fallback":{"src":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/19e71/stellargo.jpg","srcSet":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/77b35/stellargo.jpg 32w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/d4a57/stellargo.jpg 64w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/19e71/stellargo.jpg 128w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/ef6ff/stellargo.webp 32w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/8257c/stellargo.webp 64w,\n/gatsby-jenkins-io/static/57deb704d1eb39e35b9de4a8c22ea56e/6766a/stellargo.webp 128w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":"https://medium.com/@sumitsarinofficial","github":"stellargo","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 student. Sumit is an engineering student (senior) at Netaji Subhas Institute of Technology, University of Delhi. He started his journey of contributing to Jenkins in December 2019. His tiny contribution revolved around the Jenkins Fingerprint engine. He is currently working on building <a href=\"https://www.jenkins.io/projects/gsoc/2020/projects/external-fingerprint-storage\">External Fingerprint Storage for Jenkins</a>.</p>\n</div>","id":"stellargo","irc":null,"linkedin":"sumit-sarin","name":"Sumit Sarin","slug":"/blog/author/stellargo","twitter":null}]}},{"node":{"date":"2020-08-03T00:00:00.000Z","id":"1a966f1b-f29c-510f-943e-ff264acdf7dd","slug":"/blog/2020/08/03/github-checks-api-plugin-coding-phase-2/","strippedHtml":"Another great coding phase for GitHub Checks API Project ends!\nIn this phase, we focused on consuming the checks API in two widely used plugins:\n\nWarnings NG Plugin\n\nCode Coverage API Plugin\n\nBesides the external usage, we have also split the general checks API from its GitHub implementation and released both of the plugins:\n\nChecks API Plugin\n\nGitHub Checks Plugin\n\nCoding Phase 2 Demo [starts from 25:20]\n\nWarning Checks\n\nThe newly released Warnings NG plugin 8.4.0 will use checks API to publish different check runs for different static analysis tools.\nWithout leaving GitHub, users are now able to see the analysis report they interested in.\n\nOn GitHub‚Äôs conversation tab for each PR, users will see summaries for those checks like the screenshot above. The summaries will include:\n\nThe status that indicates the quality gate\n\nThe name of the analysis tool used\n\nA short message that indicates statistics of new and total issues\n\nMore fine-grained statistics can be found in the Details page.\n\nAnother practical feature is the annotation for specific lines of code. Users can now review the code alone with the annotations.\n\nTry It\n\nIn Wanings NG plugin 8.4.0, the warning checks is set as a default feature only for GitHub.\nFor other SCM platforms, a NullPublisher will be used which does nothing.\nTherefore, you can get those checks for your own GitHub project just in a few steps:\n\nUpdate Warnings NG plugin to 8.4.0\n\nInstall GitHub Checks plugin on your Jenkins instance\n\nFollow the GitHub app authentication guide to configure the credentials for the multi-branch project or GitHub organization project you are going to use\n\nUse warnings-ng plugin in your Jenkinsfile for the project you configured in the last step, e.g.\n\nnode {\n    stage ('Checkout') {\n        checkout scm\n    }\n\n    stage ('Build and Static Analysis') {\n        sh 'mvn -V -e clean verify -Dmaven.test.failure.ignore'\n\n        recordIssues tools: [java(), javaDoc()], aggregatingResults: 'true', id: 'java', name: 'Java'\n        recordIssues tool: errorProne(), healthy: 1, unhealthy: 20\n        recordIssues tools: [checkStyle(pattern: 'target/checkstyle-result.xml'),\n            spotBugs(pattern: 'target/spotbugsXml.xml'),\n            pmdParser(pattern: 'target/pmd.xml'),\n            cpd(pattern: 'target/cpd.xml')],\n            qualityGates: [[threshold: 1, type: 'TOTAL', unstable: true]]\n    }\n}\n\nFor more about the pipeline usage of warnings-ng plugin, please see the official documentation.\n\nHowever, if you don‚Äôt want to publish the warnings to GitHub, you can either uninstall the GitHub Checks plugin or disable it by adding skipPublishingChecks: true.\n\nrecordIssues enabledForFailure: true, tools: [java(), javaDoc()], skipPublishingChecks: true\n\nCoverage Checks\n\nThe coverage checks are achieved by consuming the API in Code Coverage API plugin.\nFirst, in the conversation tab of a PR, users will be able to see the summary about the coverage difference compared to previous builds.\n\nThe Details page will contain some other things:\n\nLinks to the reference build, including the target branch build from the master branch and the last successful build from this branch\n\nCoverage healthy score (the default value is 100% if the threshold is not configured)\n\nCoverages and trends of different types in table format\n\nThe pull request for this feature will soon be merged and will be included in the next release of Coverage Checks API plugin. After that, you can use it by adding the below section to your pipeline script:\n\nnode {\n    stage ('Checkout') {\n        checkout scm\n    }\n\n    stage ('Line and Branch Coverage') {\n        publishCoverage adapters: [jacoco('**/*/jacoco.xml')], sourceFileResolver: sourceFiles('STORE_ALL_BUILD')\n    }\n}\n\nLike the warning checks, you can also disable the coverage checks by setting the field skipPublishingChecks, e.g.\n\npublishCoverage adapters: [jacoco('**/*/jacoco.xml')], sourceFileResolver: sourceFiles('STORE_ALL_BUILD'), skipPublishingChecks: true\n\nNext Phase\n\nIn the next phase, we will turn our attention back to Checks API Plugin and GitHub Checks Plugin and add the following features in future versions:\n\nPipeline Support\n\nUsers can publish checks directly in a pipeline script without requiring a consumer plugin that supports the checks.\n\nRe-run Request\n\nUsers can re-run Jenkins build through Checks API.\n\nLastly, it is exciting to inform that we are currently making the checks feature available on ci.jenkins.io for all plugins hosted in the jenkinsci GitHub organization, please see INFRA-2694 for more details.\n\nResources\n\nChecks API Plugin\n\nGitHub Checks Plugin\n\nProject Page\n\nGitter Channel","title":"GitHub Checks API Plugin Project - Coding Phase 2","tags":["github","api","plugins","developer","gsoc","gsoc2020"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg","srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/77b35/XiongKezhi.jpg 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/d4a57/XiongKezhi.jpg 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/19e71/XiongKezhi.jpg 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/68974/XiongKezhi.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/ef6ff/XiongKezhi.webp 32w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/8257c/XiongKezhi.webp 64w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/6766a/XiongKezhi.webp 128w,\n/gatsby-jenkins-io/static/bedf23c1062bf01bb5bdcdd5aea7730e/22bfc/XiongKezhi.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"XiongKezhi","html":"<div class=\"paragraph\">\n<p>Jenkins Google Summer of Code 2020 Student. Kezhi is an open source enthusiast who enjoys sharing ideas with other developers. He started contributing to Jenkins in March 2020. Currently, he is working on <a href=\"https://github.com/XiongKezhi/checks-api-plugin\">GitHub Checks API Plugin</a>.</p>\n</div>","id":"XiongKezhi","irc":null,"linkedin":"kezhi-xiong-44234a188","name":"Kezhi Xiong","slug":"/blog/author/xiongkezhi","twitter":"AugustX_"}]}}]}},"pageContext":{"tag":"plugins","limit":8,"skip":0,"numPages":14,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}