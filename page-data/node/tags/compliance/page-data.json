{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/compliance",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2018-11-12T00:00:00.000Z","id":"19ad29c6-3758-5c7b-bc08-31222e0bfca7","slug":"/blog/2018/11/12/inspecting-binaries-with-jenkins/","strippedHtml":"In a past blog post,\nDelivery Pipelines, with Jenkins 2, SonarQube, and Artifactory,\nwe talked about pipelines which result in binaries for development versions, and in\nDelivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production,\nwe examined ways to consistently promote applications toward production. In this blog post, I continue on both by discussing more details on security related quality gates\nand bringing this together with the handling of Docker images.\n\nUse case: Foster security on given, containerized business application\n\nSecurity is an overloaded term with varying meaning in different contexts. For this contribution, I consider security as the sum of rules regarding vulnerabilities\n(Common Vulnerability and Exposure, CVE), in binaries. In a past blog post, we’ve identified SonarQube already, as a very helpful tool to identify flaws\nin source code, particularly concerning reliability (bugs), vulnerabilities (security, e.g. CWE, that is common weakness enumaration, and OWASP, that is the Open Web Application Security Project), and\nmaintainability (code smells). Now it is a good time to add another tool to the chain, that is Twistlock, for inspection binaries for security issues.\nFeatures of Twistlock include\n\nCompliance and vulnerability management, transitively\n\nRuntime defense\n\nCloud-native CI/CD support\n\nBroad coverage of supported artifact types and platforms\n\nAPI, dashboards, and Jenkins integration, with strong configuration options\n\nThe underlying use case can be derived from several real-world security initiatives, in enterprises, based on given containerized applications. In practice, it is not a surprise that after adding such new\nquality gates, you identify historically grown issues. However, there are many good reasons to do so. You don’t need any Word documents to check any governance criteria manually, rather\nexecution and reporting are done automatically and also part of the actions are taken automatically. And above all, of course, your application is quality assured regarding known vulnerability issues, aligned with\nthe DevOps approach: development is interested in quick feedback whether their change would introduce any vulnerabilities, and operations is interested in insights whether and\nhow running applications are affected if a new CVE is discovered.\n\nThe term DevSecOps was coined to explicitely add security concerns to DevOps.\nIn my opinion, security is already inherent part of DevOps.\nThus, there is no strong reason to introduce a new word. Surely, new words are catchy.\nBut they have limits.\nOr have you ever experienced NoDev, the variant of DevOps where features are suddenly falling from the sky and deployed to production automatically?\n\nConceptually, container inspection is now part of the delivery pipeline and Twistlock processing is now triggered once we have produced our Docker images, see below, in order to get\nfast feedback.\n\nSoftware is staged over different environments by configuration, without rebuilding. All changes go through the entire staging process, although defined\nexception routines may be in place, for details see Michael Hüttermann, Agile ALM (Manning, 2012). The staged software consists of all artifacts which\nmake up the release, consistently, including the business application, test cases, build scripts, Chef cookbooks, Dockerfiles, Jenkins files to build all\nthat in a self-contained way, for details see Michael Hüttermann, DevOps for Developers (Apress, 2012).\n\nThis blog post covers sample tools. Please note, that there are also alternative tools available, and the best target architecture is aligned with concrete requirements and given basic\nconditions. Besides that, the sample toolchain is derived from couple of real world success stories, designed and implemented in the field. However, this blog post\nsimplifies and abstracts them in order to stay focussed while discussing the primitives of delivery units. For example, aggregating multiple Docker images with ASCII files, does not change the\nunderlying primitives and their handlings. For more information on all parts of the blog post, please consult the respective documentation, good books or attend fine conferences. Or go to the extremes: talk to your colleagues.\n\nIn our sample process, we produce a web application that is packaged in a Docker image. The produced Docker images are distributed only if the dedicated quality gate passes.\nA quality gate is a stage in the overall pipeline and a sum of defined commitments, often\ncalled requirements, the unit of work must pass. In our case, the quality gate comprises inspection of produced binaries and it fails if vulnerabilities of severity 'critical' are found.\nWe can configure Twistlock according to our requirements. Have a look how we’ve integrated it into our Jenkins pipeline, with focus on detecting vulnerabilities.\n\nJenkinsfile (excerpt): Twistlock inspection triggered\n\nstage('Twistlock: Analysis') { (1)\nString version = readFile('version.properties').trim() (2)\nprintln \"Scanning for version: ${version}\"\n    twistlockScan ca: '', cert: '', compliancePolicy: 'critical', \\\n        dockerAddress: 'unix:///var/run/docker.sock', \\\n        ignoreImageBuildTime: false, key: '', logLevel: 'true', \\\n        policy: 'critical', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', \\ (3)\nrequirePackageUpdate: false, tag: \"$version\", timeout: 10\n}\n\nstage('Twistlock: Publish') { (4)\nString version = readFile('version.properties ').trim()\n    println \"Publishing scan results for version: ${version}\"\n    twistlockPublish ca: '', cert: '', \\\n        dockerAddress: 'unix:///var/run/docker.sock', key: '', \\\n        logLevel: 'true', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', tag: \"$version\", \\\n        timeout: 10\n}\n\n1\nTwistlock inspection as part of the sequence of stages in Jenkinsfile\n\n2\nNailing down the version of the to be inspected image, dynamically\n\n3\nConfiguring analysis including vulnerability severity level\n\n4\nPublishing the inspection results to Twistlock console, that is the dashboard\n\nNow let’s start with the first phase to bring our application in shape again, that is gaining insight about the security related flaws.\n\nPhase 1: Gain insights about security related flaws\n\nAfter we’ve introduced the new quality gate, it failed, see image above. As integration with other tools, Jenkins is the automation engine and does provide helpful context information,\nhowever, those cannot replace features and data the dedicated, triggered tool does offer. Thus, this is the moment to switch to the dedicated tool, that is Twistlock. Opening\nthe dashboard, we can navigate to the Jenkins build jobs, that is the specific run of the build, and the respective results of the Twistlock analysis. What we see now is a list\nof vulnerabilities, and we need to fix those of severity critical in order to pass the quality gate, and get our changes again toward production. The list shows entries of\ntype jar, that is a finding in a binary as part of the Docker image, in our case the WAR file we’ve deployed to a web container (Tomcat), and of type OS, those are issues of the underlying image itself, the\noperating system, either part of the base image, or as a package added/changed in our Dockerfile.\n\nWe can now easily zoom in and examine the vulnerabilities of the Docker layers. This really helps to structure work and identify root causes. Since, typically,\na Docker image extends a Docker base image, the findings in the base image are shown on the top, see next screenshot, grouped by severity.\n\nOther Docker layers were added to the base image, and those can add vulnerabilities too. In our case, the packaged WAR file obviously contains a vulnerability. The next image shows how we examine that finding, while this time\nexpanding the Twistlock wizard (that is the plus sign) to directly see the list of found vulnerabilities.\n\nFinding and visualizing the issues are a very good first step, and we’ve even made those findings actionable, so we now have to take action and address them.\n\nPhase 2: Address the findings\n\nTo address the findings, we need to split our initiative into two parts:\n\nFixing the critical vulnerabilities related to the Docker image (in our case largely the base image)\n\nFixing the critical vulnerabilities related to the embedded deployment unit (in our case the WAR)\n\nLet’s proceed bottom up, first coping with the Docker base image.\n\nThis is an easy example covering multiple scenarios particularly identifying and fixing vulnerabilities in transitive binaries, i.e. binaries contained in\nother binaries, e.g. a Docker image containing a WAR file that in turn contains libraries. To expand this vertical feasibility spike, you can easily add\nmore units of each layer, or add more abstractions, however, the idea can always be nailed down to the primitives, covered in this blog post.\n\nLet’s now have a look at the used Docker image by looking at the used Dockerfile.\n\nDockerfile: The Dockerfile based on Alpine, running OpenJDK 8\n\nFROM openjdk:8-jre-alpine (1)\nLABEL maintainer \"michael@huettermann.net\"\n\n# Domain of your Artifactory. Any other storage and URI download link works, just change the ADD command, see below.\nARG ARTI\nARG VER\n\n# Expose web port\nEXPOSE 8080\n\n# Tomcat Version\nENV TOMCAT_VERSION_MAJOR 9 (2)\nENV TOMCAT_VERSION_FULL  9.0.6\n\n# Download, install, housekeeping\nRUN apk add --update curl &&\\ (3)\napk add bash &&\\\n  #apk add -u libx11 &&\\ (4)\nmkdir /opt &&\\\n  curl -LO ${ARTI}/list/generic-local/apache/org/tomcat/tomcat-${TOMCAT_VERSION_MAJOR}/v${TOMCAT_VERSION_FULL}/bin/apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &&\\\n  gunzip -c apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz | tar -xf - -C /opt &&\\\n  rm -f apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &&\\\n  ln -s /opt/apache-tomcat-${TOMCAT_VERSION_FULL} /opt/tomcat &&\\\n  rm -rf /opt/tomcat/webapps/examples /opt/tomcat/webapps/docs &&\\\n  apk del curl &&\\\n  rm -rf /var/cache/apk/*\n\n# Download and deploy the Java EE WAR\nADD http://${ARTI}/list/libs-release-local/com/huettermann/web/${VER}/all-${VER}.war /opt/tomcat/webapps/all.war (5)\n\nRUN chmod 755 /opt/tomcat/webapps/*.war\n\n# Set environment\nENV CATALINA_HOME /opt/tomcat\n\n# Start Tomcat on startup\nCMD ${CATALINA_HOME}/bin/catalina.sh run\n\n1\nBase image ships OpenJDK 8, on Alpine\n\n2\nDefined version of web container\n\n3\nApplying some defined steps to configure Alpine, according to requirements\n\n4\nUpdating package itself would address one vulnerability already\n\n5\nDeploying the application\n\nBy checking available versions of the official OpenJDK Alpine image, we see that there’s a newer version 8u181 which we could use.\nWe can zoom in and study release notes and contents, or we just pragmatically switch the base image to a more recent version. Often it is a good idea\nto upgrade versions regularly, in defined intervals. This leads to the following change in the Dockerfile.\n\nDockerfile (excerpt): The Dockerfile based on Alpine, running OpenJDK 8u181\n\nFROM openjdk:8u181-jre-alpine (1)\nLABEL maintainer \"michael@huettermann.net\"\n\n1\nBase image is now OpenJDK 8u181, on Alpine\n\nThere are more options available to fix the issues, but let’s proceed to the second part, the vulnerabilities in the deployment unit.\n\nBefore we push this change to GitHub, we also address the vulnerability issue in the deployment unit, that is jetty-io. Here we are a bit unsure about\nwhy, in this specific use case, the library is used. To retrieve more information about dependencies, we run a dependency:tree command on our Maven\nbased project. We now see that jetty-io is transitively referenced by org.seleniumhq.selenium:htmlunit-driver. We can surely discuss why this is a compile\ndependency and the libraries are shipped as part of the WAR, but let’s consider this to be given according to requirements, thus we must take special attention now\nto version 2.29.0 of the specific library.\n\nAlso here we can browse release notes and content (particularly how those libs are built themselves), and come to the conclusion to\nswitch from the used version, that is 2.29.0, to a newer version of htmlunit-driver, that is 2.31.1.\n\npom.xml (excerpt): Build file\n\n(1)\n\norg.seleniumhq.selenium\nselenium-java\n3.14.0\n\norg.seleniumhq.selenium (2)\nhtmlunit-driver\n2.31.1\n\njunit\njunit\n4.7\n\n1\nPart of the underlying POM defining dependencies\n\n2\nDefinition of the dependency, causing the vulnerability finding; we use a newer version now\n\nOK, now we are done. We push the changes to GitHub, and our GitHub webhook directly triggers the workflow. This time the quality gate passes, so it\nlooks like our fixes did address the root causes and eliminated those with the configured threshold severity.\n\nFinally, after running through our entire workflow, that is made up of different pipelines, our inspected and quality assured container does successfully\nrun in our production runtime environment, that is on Oracle Cloud.\n\nCrisp, isn’t it?\n\nSummary\n\nThis closes our quick walkthrough of how to inject security related quality gates into a Jenkins based delivery pipeline.\nWe’ve discussed some concepts and how this can look like with sample tools.\nIn the center of our efforts, we used Jenkins, the swiss army knife of automation.\nWe enriched our ecosystem by integrating couple of platforms and tools, above all Twistlock.\nAfter this tasty appetizer you are ready to assess your own delivery pipelines,\nconcepts and tools, and to possibly invest even more attention to security.\n\nReferences\n\n'Agile ALM', Manning, 2011\n\n'DevOps for Developers', Apress, 2012\n\nDocker, the standard to develop and ship set of changes\n\nDocker images, shipping OpenJDK\n\nOracle Cloud Infrastructure, for containers\n\nAlpine Linux\n\nSonarQube, the language/platform agnostic Continuous Inspection tool\n\nTwistlock, the container security platform\n\nSources on GitHub\n\nASCII, commonly used standard to work on primitives, such as Docker (and their aggregations)\n\nCommon Vulnerabilities and Exposures\n\nHolistic pipelines, Live 15-minute Jenkins Demos, Part 1, on YouTube\n\nHolistic pipelines, Live 15-minute Jenkins Demos, Part 2, on YouTube\n\nDelivery Pipelines, with Jenkins 2, SonarQube, and Artifactory\n\nDelivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production","title":"The Silence of the Lambs: Inspecting binaries with Jenkins","tags":["devops","devsecops","security","vulnerabilities","compliance","twistlock"],"authors":[{"avatar":{"childImageSharp":null},"blog":"http://huettermann.net","github":"michaelhuettermann","html":"<div class=\"paragraph\">\n<p>Michael is expert in Continuous Delivery, DevOps and SCM/ALM supporting enterprises in implementing DevOps.\nMichael is Jenkins Ambassador.</p>\n</div>","id":"michaelhuettermann","irc":null,"linkedin":null,"name":"Michael Hüttermann","slug":"/blog/author/michaelhuettermann","twitter":"huettermann"}]}}]}},"pageContext":{"tag":"compliance","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}