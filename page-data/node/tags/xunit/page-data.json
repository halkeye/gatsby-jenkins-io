{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/xunit",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2017-02-23T00:00:00.000Z","id":"4617d4e9-51f3-58b1-8cf1-558aa14ce01d","slug":"/blog/2017/02/23/declarative-saucelabs-xunit/","strippedHtml":"This is a guest post by Liam Newman,\nTechnical Evangelist at CloudBees.\n\nDeclare Your Pipelines!\nDeclarative Pipeline 1.0 is here!\nThis is the fourth post in a series showing some of the cool features of\nDeclarative Pipeline.\n\nIn the\nprevious post,\nwe integrated several notification services into a Declarative Pipeline.\nWe kept our Pipeline clean and easy to understand\nby using a shared library to make a custom step called sendNotifications\nthat we called at the start and end of our Pipeline.\n\nIn this blog post, we’ll start by translating the Scripted Pipeline in the sample project I worked with\nin\n\" Browser-testing with Sauce OnDemand and Pipeline\"\nand\n\" xUnit and Pipeline\"\nto Declarative.\nWe’ll make our Pipeline clearer by adding an environment directive\nto define some environment variables, and then moving some code to a shared library.\nFinally, we’ll look at using the when directive to add simple conditional behavior to our Pipeline.\n\nSetup\n\nThe setup for this post uses the same repository as the two posts above,\nmy fork\nof the\nJS-Nightwatch.js sample project.\nI’ve once again created a branch specifically for this blog post,\nthis time called\nblog/declarative/sauce .\n\nLike the two posts above, this Pipeline will use the\nxUnit and\nSauce OnDemand plugins.\nThe xUnit plugin only needs to be installed, the Sauce OnDemand needs additional configuration.\nFollow\nSauce Labs' configuration instructions\nto create an account with Sauce Labs and add your Sauce Labs credentials to Jenkins.\nThe Sauce OnDemand plugin will automatically install\nSauce Connect\nfor us when we call it from our Pipeline.\n\nBe sure to you have the latest version of the\nSauce OnDemand plugin (1.160 or newer).\nIt has several fixes required for this post.\n\nFor a shared library, I’ve still got the one from the\nprevious post.\nTo set up this \"Global Pipeline Library,\" navigate to \"Manage Jenkins\" → \"Configure System\"\nin the Jenkins web UI.\nOnce there, under \"Global Pipeline Libraries\", add a new library.\nThen set the name to bitwiseman-shared, point it at my repository,\nand set the default branch for the library to master.\n\nReducing Complexity with Declarative\n\nIf you’ve been following along through this series,\nthis first step will be quite familiar by now.\nWe’ll start from the Pipeline we had at the end of the xUnit post\nand translate it to Declarative.\n\n// Declarative //\npipeline {\n    agent any\n    options {\n        // Nightwatch.js supports color ouput, so wrap add his option\n        ansiColor colorMapName: 'XTerm'\n    }\n    stages {\n        stage (\"Build\") {\n            steps {\n                // Install dependencies\n                sh 'npm install'\n            }\n        }\n        stage (\"Test\") {\n            steps {\n                // Add sauce credentials\n                sauce('f0a6b8ad-ce30-4cba-bf9a-95afbc470a8a') {\n                    // Start sauce connect\n                    sauceconnect() {\n                        // Run selenium tests using Nightwatch.js\n                        // Ignore error codes. The junit publisher will cover setting build status.\n                        sh \"./node_modules/.bin/nightwatch -e chrome,firefox,ie,edge --test tests/guineaPig.js || true\"\n                    }\n                }\n            }\n            post {\n                always {\n                    step([$class: 'XUnitBuilder',\n                        thresholds: [\n                            [$class: 'SkippedThreshold', failureThreshold: '0'],\n                            // Allow for a significant number of failures\n                            // Keeping this threshold so that overwhelming failures are guaranteed\n                            //     to still fail the build\n                            [$class: 'FailedThreshold', failureThreshold: '10']],\n                        tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\n                    saucePublisher()\n                }\n            }\n        }\n    }\n// Scripted //\nnode {\n    stage \"Build\"\n    checkout scm\n\n    // Install dependencies\n    sh 'npm install'\n\n    stage \"Test\"\n    // Add sauce credentials\n    sauce('f0a6b8ad-ce30-4cba-bf9a-95afbc470a8a') {\n        // Start sauce connect\n        sauceconnect() {\n\n            // List of browser configs we'll be testing against.\n            def platform_configs = [\n                'chrome',\n                'firefox',\n                'ie',\n                'edge'\n            ].join(',')\n\n            // Nightwatch.js supports color ouput, so wrap this step for ansi color\n            wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm']) {\n                // Run selenium tests using Nightwatch.js\n                // Ignore error codes. The junit publisher will cover setting build status.\n                sh \"./node_modules/.bin/nightwatch -e ${platform_configs} --test tests/guineaPig.js || true\"\n            }\n\n            step([$class: 'XUnitBuilder',\n                thresholds: [\n                    [$class: 'SkippedThreshold', failureThreshold: '0'],\n                    // Allow for a significant number of failures\n                    // Keeping this threshold so that overwhelming failures are guaranteed\n                    //     to still fail the build\n                    [$class: 'FailedThreshold', failureThreshold: '10']],\n                tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\n            saucePublisher()\n        }\n    }\n}\n\nBlue Ocean doesn’t support displaying SauceLabs test reports yet\n(see JENKINS-42242).\nTo view the report above, I had to switch back to the stage view of this run.\n\nElevating Settings using environment\n\nEach time we’ve moved a project from Scripted Pipeline to Declarative,\nwe’ve found the cleaner format of Declarative Pipeline highlights the less\nclear parts of the existing Pipeline.\nIn this case, the first thing that jumps out at me is that the parameters of the\nSaucelabs and Nightwatch execution are hardcoded and buried down in the middle of our Pipeline.\nThis is a relatively short Pipeline, so it isn’t terribly hard to find them,\nbut as this pipeline grows and changes it would be better if those values were kept separate.\nIn Scripted, we’d have defined some variables,\nbut Declarative doesn’t allow us to define variables in the usual Groovy sense.\n\nThe environment directive let’s us set some environment variables\nand use them later in our pipeline.\nAs you’d expect, the environment directive is just a set of name-value pairs.\nEnvironment variables are accessible in Pipeline via env.variableName (or just variableName)\nand in shell scripts as standard environment variables, typically $variableName.\n\nLet’s move the list of browsers, the test filter, and the sauce credential string to environment variables.\n\nJenkinsfile\n\nenvironment {\n        saucelabsCredentialId = 'f0a6b8ad-ce30-4cba-bf9a-95afbc470a8a'\n        sauceTestFilter = 'tests/guineaPig.js'\n        platformConfigs = 'chrome,firefox,ie,edge'\n    }\n    stages {\n        /* ... unchanged ... */\n        stage (\"Test\") {\n            steps {\n                // Add sauce credentials\n                sauce(saucelabsCredentialId) {\n                    // Start sauce connect\n                    sauceconnect() {\n                        // Run selenium tests using Nightwatch.js\n                        // Ignore error codes. The junit publisher will cover setting build status.\n                        sh \"./node_modules/.bin/nightwatch -e ${env.platformConfigs} --test ${env.sauceTestFilter} || true\" (1)\n}\n                }\n            }\n            post { /* ... unchanged ... */ }\n        }\n    }\n}\n\n1\nThis double-quoted string causes Groovy to replace the variables with their\nliteral values before passing to sh.\nThis could also be written using singe-quotes:\nsh './node_modules/.bin/nightwatch -e $platformConfigs --test $sauceTestFilter || true'.\nWith a single quoted string, the string is passed as written to the shell,\nand then the shell does the variable substitution.\n\nMoving Complex Code to Shared Libraries\n\nNow that we have settings separated from the code, we can do some code clean up.\nUnlike the previous post, we don’t have any repeating code,\nbut we do have some distractions.\nThe nesting of sauce, sauceconnect, and sh nightwatch seems excessive,\nand that xUnit step is a bit ugly as well.\nLet’s move those into our shared library as custom steps with parameters.\nWe’ll change the Jenkinsfile in our main project,\nand add the custom steps to a branch named\nblog/declarative/sauce in our library repository.\n\nJenkinsfile\n\n@Library('bitwiseman-shared@blog/declarative/sauce') _\n\n/* ... unchanged ... */\n\nstage (\"Test\") {\n    steps {\n        sauceNightwatch saucelabsCredentialId,\n            platformConfigs,\n            sauceTestFilter\n    }\n    post {\n        always {\n            xUnitPublishResults 'reports/**',\n                /* failWhenSkippedExceeds */ 0,\n                /* failWhenFailedExceeds */ 10\n\n            saucePublisher()\n        }\n    }\n}\n\nvars/sauceNightwatch.groovy\n\ndef call(String sauceCredential, String platforms = null, String testFilter = null) {\n    platforms = platforms ? \"-e '\" + platforms + \"'\" : ''\n    testFilter = testFilter ? \"--test '\" + testFilter + \"'\" : ''\n\n    // Add sauce credentials\n    sauce(sauceCredential) {\n        // Start sauce connect\n        sauceconnect() {\n            // Run selenium tests using Nightwatch.js\n            // Ignore error codes. The junit publisher will cover setting build status.\n            sh \"./node_modules/.bin/nightwatch ${platforms} ${testFilter} || true\" (1)\n}\n    }\n}\n\n1\nIn this form, this could not be written using a literal single-quoted string.\nHere, platforms and testFilter are groovy variables, not environment variables.\n\nvars/xUnitPublishResults.groovy\n\ndef call(String pattern, Integer failWhenSkippedExceeds,\n        Integer failWhenFailedExceeds) {\n    step([$class: 'XUnitBuilder',\n        thresholds: [\n            [$class: 'SkippedThreshold', failureThreshold: failWhenSkippedExceeds.toString()],\n            // Allow for a significant number of failures\n            // Keeping this threshold so that overwhelming failures are guaranteed\n            //     to still fail the build\n            [$class: 'FailedThreshold', failureThreshold: failWhenFailedExceeds.toString()]],\n        tools: [[$class: 'JUnitType', pattern: pattern]]])\n}\n\nRunning Conditional Stages using when\n\nThis is a sample web testing project.\nWe probably wouldn’t deploy it like we would production code,\nbut we might still want to deploy somewhere,\nby publishing it to an artifact repository, for example.\nThis project is hosted on GitHub and uses feature branches and pull requests to make changes.\nI’d like to use the same Pipeline for feature branches, pull requests, and the master branch,\nbut I only want to deploy from master.\n\nIn Scripted, we’d wrap a stage in an if-then and check if the branch for\nthe current run is named \"master\".\nDeclarative doesn’t support that kind of general conditional behavior.\nInstead, it provides a\nwhen directive\nthat can be added to stage sections.\nThe when directive supports several types of conditions, including a branch condition,\nwhere the stage will run when the branch name matches the specified pattern.\nThat is exactly what we need here.\n\nJenkinsfile\n\nstages {\n    /* ... unchanged ... */\n    stage ('Deploy') {\n        when {\n            branch 'master'\n        }\n        steps {\n             echo 'Placeholder for deploy steps.'\n        }\n    }\n}\n\nWhen we run our Pipeline with this new stage, we get the following outputs:\n\nLog output for 'feature/test' branch\n\n...\nFinished Sauce Labs test publisher\n[Pipeline] }\n[Pipeline] // stage\n[Pipeline] stage\n[Pipeline] { (Deploy)\nStage 'Deploy' skipped due to when conditional\n[Pipeline] }\n[Pipeline] // stage\n[Pipeline] }\n...\n\nLog output for 'master' branch\n\n...\nFinished Sauce Labs test publisher\n[Pipeline] }\n[Pipeline] // stage\n[Pipeline] stage\n[Pipeline] { (Deploy)\n[Pipeline] echo\nPlaceholder for deploy steps.\n[Pipeline] }\n[Pipeline] // stage\n[Pipeline] }\n...\n\nConclusion\n\nI have to say, our latest Declarative Pipeline turned out extremely well.\nI think someone coming from Freestyle jobs, with little to no experience with Pipeline or Groovy,\nwould still be able to look at this Declarative Pipeline and make sense of what it is doing.\nWe’ve added new functionality to our Pipeline while making it easier to understand\nand maintain.\n\nI hope you’ve learned as much as I have during this blog series.\nI’m excited to see that even in the the short time since Declarative 1.0 was released,\nteams are already using it in make improvements similar to what those we’ve covered in this series.\nThanks for reading!\n\nLinks\n\nxUnit\n\nSauce OnDemand\n\nDeclarative Pipeline plugin\n\nDeclarative Pipeline Syntax Reference\n\nPipeline source for this post\n\nPipeline Shared Library source for this post","title":"Browser testing and conditional logic in Declarative Pipeline","tags":["pipeline","plugins","xunit","nightwatch","saucelabs","selenium","declarative"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"bitwiseman","html":"<div class=\"paragraph\">\n<p>Liam started his software career as a tester, which might explain why he&#8217;s such a fan of CI/CD and Pipeline as Code.\nHe has spent the majority of his software engineering career implementing Continuous Integration systems at companies big and small.\nHe is a Jenkins project contributor and an expert in Jenkins Pipeline, both Scripted and Declarative.\nLiam currently works as a Jenkins Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\nWhen not at work, he enjoys testing gravity by doing Aikido.</p>\n</div>","id":"lnewman","irc":null,"linkedin":null,"name":"Liam Newman","slug":"blog/author/lnewman","twitter":"bitwiseman"}]}},{"node":{"date":"2016-10-31T00:00:00.000Z","id":"dcf580a2-8de4-526e-8237-399ee53b3b39","slug":"/blog/2016/10/31/xunit-reporting/","strippedHtml":"This is a guest post by Liam Newman,\nTechnical Evangelist at CloudBees.\n\nThe\nJUnit plugin\nis the go-to test result reporter for many Jenkins projects,\nbut the it is not the only one available.  The\nxUnit plugin\nis a viable alternative that supports JUnit and many other test result file formats.\n\nIntroduction\n\nNo matter the project, you need to gather and report test results.\nJUnit is one of the most widely supported formats for recording test results.\nFor a scenarios where your tests are stable and your framework can produce JUnit output,\nthis makes the JUnit plugin ideal for reporting results in Jenkins.\nIt will consume results from a specified file or path, create a report,\nand if it finds test failures it will set the the job state to \"unstable\" or \"failed\".\n\nThere are also plenty of scenarios where the JUnit plugin is not enough.\nIf your project has some failing tests that will take some time to fix,\nor if there are some flaky tests,\nthe JUnit plugin’s simplistic view of test failures may be difficult to work with.\n\nNo problem, the Jenkins plugin model lets us replace the JUnit\nplugin functionality with similar\nfunctionality from another plugin and Jenkins Pipeline lets us do this in safe\nstepwise fashion where we can test and debug each of our changes.\n\nIn this article, I will show you how to replace the JUnit plugin with the\nxUnit plugin in Pipeline code to address a few common test reporting scenarios.\n\nInitial Setup\n\nI’m going to use the \"JS-Nightwatch.js\" sample project from my\nprevious post to demonstrate a couple\ncommon scenarios that the xUnit handles better.\nI already have the latest\nJUnit plugin\nand\nxUnit plugin\ninstalled on my Jenkins server.\n\nI’ll be keeping my changes in\nlink: my fork\nof the \"JS-Nightwatch.js\" sample project on GitHub, under the\n\" blog/xunit\" branch.\n\nHere’s what the Jenkinsfile looked like at the end of that previous post and what\nthe report page looks like after a few runs:\n\nJenkinsfile\n\nnode {\n    stage \"Build\"\n    checkout scm\n\n    // Install dependencies\n    sh 'npm install'\n\n    stage \"Test\"\n    // Add sauce credentials\n    sauce('f0a6b8ad-ce30-4cba-bf9a-95afbc470a8a') {\n        // Start sauce connect\n        sauceconnect(options: '', useGeneratedTunnelIdentifier: false, verboseLogging: false) {\n\n            // List of browser configs we'll be testing against.\n            def platform_configs = [\n                'chrome',\n                'firefox',\n                'ie',\n                'edge'\n            ].join(',')\n\n            // Nightwatch.js supports color ouput, so wrap this step for ansi color\n            wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm']) {\n                // Run selenium tests using Nightwatch.js\n                // Ignore error codes. The junit publisher will cover setting build status.\n                sh \"./node_modules/.bin/nightwatch -e ${platform_configs} || true\"\n            }\n\n            junit 'reports/**'\n\n            step([$class: 'SauceOnDemandTestPublisher'])\n        }\n    }\n}\n\nSwitching from JUnit to xUnit\n\nI’ll start by replacing JUnit with xUnit in my pipeline.\nI use the Snippet Generator to create the step with the right parameters.\nThe main downside of using the xUnit plugin is that while it is Pipeline compatible,\nit still uses the more verbose step() syntax and has some very rough edges around that, too.\nI’ve filed\nJENKINS-37611\nbut in the meanwhile, we’ll work with what we have.\n\n// Original JUnit step\njunit 'reports/**'\n\n// Equivalent xUnit step - generated (reformatted)\nstep([$class: 'XUnitBuilder', testTimeMargin: '3000', thresholdMode: 1,\n    thresholds: [\n        [$class: 'FailedThreshold', failureNewThreshold: '', failureThreshold: '', unstableNewThreshold: '', unstableThreshold: '1'],\n        [$class: 'SkippedThreshold', failureNewThreshold: '', failureThreshold: '', unstableNewThreshold: '', unstableThreshold: '']],\n    tools: [\n        [$class: 'JUnitType', deleteOutputFiles: false, failIfNotNew: false, pattern: 'reports/**', skipNoTestFiles: false, stopProcessingIfError: true]]\n    ])\n\n// Equivalent xUnit step - cleaned\nstep([$class: 'XUnitBuilder',\n    thresholds: [[$class: 'FailedThreshold', unstableThreshold: '1']],\n    tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\nIf I replace the junit step in my Jenkinsfile with that last step above,\nit produces a report and job result identical to the JUnit plugin but using the xUnit plugin.  Easy!\n\nnode {\n    stage \"Build\"\n    // ... snip ...\n\n    stage \"Test\"\n    // Add sauce credentials\n    sauce('f0a6b8ad-ce30-4cba-bf9a-95afbc470a8a') {\n        // Start sauce connect\n        sauceconnect(options: '', useGeneratedTunnelIdentifier: false, verboseLogging: false) {\n\n            // ... snip ...\n\n            // junit 'reports/**'\n            step([$class: 'XUnitBuilder',\n                thresholds: [[$class: 'FailedThreshold', unstableThreshold: '1']],\n                tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\n            // ... snip ...\n        }\n    }\n}\n\nAccept a Baseline\n\nMost projects don’t start off with automated tests passing or even running.\nThey start with a people hacking and prototyping, and eventually they start to write tests.\nAs new tests are written, having tests checked-in, running, and failing can be valuable information.\nWith the xUnit plugin we can accept a baseline of failed cases and drive that number down over time.\n\nI’ll start by changing the Jenkinsfile to fail jobs only if the number of failures is greater than an expected baseline,\nin this case four failures. When I run the job with this change, the reported numbers remain the same, but the job passes.\n\nJenkinsfile\n\n// The rest of the Jenkinsfile is unchanged.\n// Only the xUnit step() call is modified.\nstep([$class: 'XUnitBuilder',\n    thresholds: [[$class: 'FailedThreshold', failureThreshold: '4']],\n    tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\nNext, I can also check that the plugin reports the job as failed if more failures occur.\nSince this is sample code, I’ll do this by adding another failing test and checking the job\nreports as failed.\n\ntests/guineaPig.js\n\n// ... snip ...\n\n    'Guinea Pig Assert Title 0 - D': function(client) { /* ... */ },\n\n    'Guinea Pig Assert Title 0 - E': function(client) {\n        client\n            .url('https://saucelabs.com/test/guinea-pig')\n            .waitForElementVisible('body', 1000)\n            //.assert.title('I am a page title - Sauce Labs');\n            .assert.title('I am a page title - Sauce Labs - Cause a Failure');\n    },\n\n    afterEach: function(client, done) { /* ... */ }\n\n// ... snip ...\n\nIn a real project, we’d make fixes over a number of commits bringing the number of failures down and adjusting our baseline.\nSince this is a sample, I’ll just make all tests pass and set the job failure threshold for failed and skipped cases to zero.\n\nJenkinsfile\n\n// The rest of the Jenkinsfile is unchanged.\n// Only the xUnit step() call is modified.\nstep([$class: 'XUnitBuilder',\n    thresholds: [\n        [$class: 'SkippedThreshold', failureThreshold: '0'],\n        [$class: 'FailedThreshold', failureThreshold: '0']],\n    tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\ntests/guineaPig.js\n\n// ... snip ...\n\n    'Guinea Pig Assert Title 0 - D': function(client) { /* ... */ },\n\n    'Guinea Pig Assert Title 0 - E': function(client) {\n        client\n            .url('https://saucelabs.com/test/guinea-pig')\n            .waitForElementVisible('body', 1000)\n            .assert.title('I am a page title - Sauce Labs');\n    },\n\n    afterEach: function(client, done) { /* ... */ }\n\n// ... snip ...\n\ntests/guineaPig_1.js\n\n// ... snip ...\n\n    'Guinea Pig Assert Title 1 - A': function(client) {\n        client\n            .url('https://saucelabs.com/test/guinea-pig')\n            .waitForElementVisible('body', 1000)\n            .assert.title('I am a page title - Sauce Labs');\n    },\n\n// ... snip ...\n\nAllow for Flakiness\n\nWe’ve all known the frustration of having one flaky test that fails once every ten jobs.\nYou want to keep it active so you can working isolating the source of the problem,\nbut you also don’t want to destablize your CI pipeline or reject commits that are actually okay.\nYou could move the test to a separate job that runs the \"flaky\" tests,\nbut in my experience that just leads to a job that is always in a failed state\nand a pile of flaky tests no one looks at.\n\nWith the xUnit plugin, we can keep the this flaky test in main test suite but allow\nthe our job to still pass.\n\nI’ll start by adding a sample flaky test.  After a few runs, we can see the test\nfails intermittently and causes the job to fail too.\n\ntests/guineaPigFlaky.js\n\n// New test file: tests/guineaPigFlaky.js\nvar https = require('https');\nvar SauceLabs = require(\"saucelabs\");\n\nmodule.exports = {\n\n    '@tags': ['guineaPig'],\n\n    'Guinea Pig Flaky Assert Title 0': function(client) {\n        var expectedTitle = 'I am a page title - Sauce Labs';\n        // Fail every fifth minute\n        if (Math.floor(Date.now() / (1000 * 60)) % 5 === 0) {\n            expectedTitle += \" - Cause failure\";\n        }\n\n        client\n            .url('https://saucelabs.com/test/guinea-pig')\n            .waitForElementVisible('body', 1000)\n            .assert.title(expectedTitle);\n    }\n\n    afterEach: function(client, done) {\n        client.customSauceEnd();\n\n        setTimeout(function() {\n            done();\n        }, 1000);\n\n    }\n\n};\n\nI can almost hear my teammates screaming in frustration just looking at this report.\nTo allow specific tests to be unstable but not others,\nI’m going to add a guard \"suite completed\" test to the suites that should be stable,\nand keep flaky test on it’s own.\nThen I’ll tell xUnit to allow for a number of failed tests, but no skipped ones.\nIf any test fails other than the ones I allow to be flaky,\nit will also result in one or more skipped tests and will fail the build.\n\n// The rest of the Jenkinsfile is unchanged.\n// Only the xUnit step() call is modified.\nstep([$class: 'XUnitBuilder',\n    thresholds: [\n        [$class: 'SkippedThreshold', failureThreshold: '0'],\n        // Allow for a significant number of failures\n        // Keeping this threshold so that overwhelming failures are guaranteed\n        //     to still fail the build\n        [$class: 'FailedThreshold', failureThreshold: '10']],\n    tools: [[$class: 'JUnitType', pattern: 'reports/**']]])\n\ntests/guineaPig.js\n\n// ... snip ...\n\n    'Guinea Pig Assert Title 0 - E': function(client) { /* ... */ },\n\n    'Guinea Pig Assert Title 0 - Suite Completed': function(client) {\n      // No assertion needed\n    },\n\n    afterEach: function(client, done) { /* ... */ }\n\n// ... snip ...\n\ntests/guineaPig_1.js\n\n// ... snip ...\n\n    'Guinea Pig Assert Title 1 - E': function(client) { /* ... */ },\n\n    'Guinea Pig Assert Title 1 - Suite Completed': function(client) {\n      // No assertion needed\n    },\n\n    afterEach: function(client, done) { /* ... */ }\n\n// ... snip ...\n\nAfter a few more runs, you can see the flaky test is still being flaky,\nbut it is no longer failing the build.  Meanwhile, if another test fails,\nit will cause the \"suite completed\" test to be skipped, failing the job.\nIf this were a real project, the test owner could instrument and eventually fix\nthe test.  When they were confident they had stabilized the test the could add\na \"suite completed\" test after it to enforce it passing without changes to other\ntests or framework.\n\nConclusion\n\nThis post has shown how to migrate from the JUnit plugin to the\nxUnit plugin on an existing project in Jenkins pipeline.  It also covered how to\nuse the features of xUnit plugin to get more meaningful and effective Jenkins\nreporting behavior.\n\nWhat I didn’t show was how many other formats xUnit supports - from CCPUnit to MSTest.  You can\nalso write your own XSL for result formats not on the known/supported list.\n\nLinks\n\nxUnit plugin\n\nbitwiseman/JS-Nightwatch.js\n\nsaucelabs-sample-test-frameworks","title":"xUnit and Pipeline","tags":["pipeline","plugins","xunit","nightwatch"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"bitwiseman","html":"<div class=\"paragraph\">\n<p>Liam started his software career as a tester, which might explain why he&#8217;s such a fan of CI/CD and Pipeline as Code.\nHe has spent the majority of his software engineering career implementing Continuous Integration systems at companies big and small.\nHe is a Jenkins project contributor and an expert in Jenkins Pipeline, both Scripted and Declarative.\nLiam currently works as a Jenkins Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\nWhen not at work, he enjoys testing gravity by doing Aikido.</p>\n</div>","id":"lnewman","irc":null,"linkedin":null,"name":"Liam Newman","slug":"blog/author/lnewman","twitter":"bitwiseman"}]}}]}},"pageContext":{"tag":"xunit","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}