{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/docker",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2021-08-17T00:00:00.000Z","id":"d629c3ce-afaa-5437-9120-457244788553","slug":"/blog/2021/08/17/docker-images-use-jdk-11-by-default/","strippedHtml":"The Jenkins project provides Docker images for controllers, inbound agents, outbound agents, and more.\nBeginning with Jenkins 2.307 released August 17, 2021 and Jenkins 2.303.1 released August 25, 2021, the Docker images provided by the Jenkins project will use Java 11 instead of Java 8.\n\nControllers use Java 11 by default\n\nIf you are running one of the Jenkins Docker controller images that does not include a JDK version in its label, the Java runtime will switch from Java 8 to Java 11 with the upgrade.\n\nFor example:\n\nJenkins 2.306 running as jenkins/jenkins:latest uses Java 8.\nWhen Jenkins 2.307 or later is run with jenkins/jenkins:latest, it will use Java 11\n\nJenkins 2.289.3 running as jenkins/jenkins:lts uses Java 8.\nWhen Jenkins 2.303.1 or later is run with jenkins/jenkins:lts, it will use Java 11\n\nThe Docker image tags affected by this upgrade include:\n\nalpine\n\ncentos7\n\nlatest\n\nlts\n\nslim\n\nUsers that need to remain with Java 8 may use a different Docker image tag to run with Java 8.\n\nJenkins 2.306 running as jenkins/jenkins:latest uses Java 8.\nWhen Jenkins 2.307 or later is run with jenkins/jenkins:latest-jdk8, it will use Java 8\n\nJenkins 2.289.3 running as jenkins/jenkins:lts uses Java 8.\nWhen Jenkins 2.303.1 or later is run with jenkins/jenkins:lts-jdk8, it will use Java 8\n\nAgents use Java 11 by default\n\nDuring the next 1-2 weeks (Aug 17, 2021 - Aug 31, 2021), the Jenkins agent images will be updated to use Java 11 instead of Java 8.\n\nFor example:\n\nRunning a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:4.9-1 uses Java 8.\nWhen running a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:4.10-1 it will use Java 11.\n\nRunning a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:latest uses Java 8.\nWhen running a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:latest after the agent change, it will use Java 11.\n\nUsers that need to remain with Java 8 may use a different Docker image tag to run with Java 8.\n\nRunning a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:4.9-1 uses Java 8.\nWhen running a Jenkins agent from Docker image jenkins/jenkins-inbound-agents:4.10-1-jdk8 it will also use Java 8.\n\nDocker tag updates stopped\n\nThe Jenkins project will no longer update the Docker images that are based on CentOS 8.\nThe CentOS project has changed direction to track just ahead of a Red Hat Enterprise Linux release rather than tracking after a release.\nThey are no longer publishing updates for CentOS 8 Docker images.\n\nUsers running Jenkins 2.306 or earlier with the jenkins/jenkins:centos tag will need to switch to use a different tag.\nThey may consider using:\n\njenkins/jenkins:almalinux\n\njenkins/jenkins:rhel-ubi8-jdk11\n\nUsers running Jenkins 2.289.3 or earlier with the jenkins/jenkins:centos tag will need to switch to use a different tag\n\nThey may consider using:\n\njenkins/jenkins:lts-almalinux\n\njenkins/jenkins:lts-rhel-ubi8-jdk11\n\nWindow 1809 Docker images stopped\n\nThe Windows Docker images have published versions based on both the 1809 feature release and the Windows Server long term support channel (\"LTSC\").\nWindows support for the 1809 images will no longer be published because Microsoft has ended mainstream support for the 1809 images.\nUsers should switch to use the Jenkins images based on the \"LTSC\" channel.","title":"Docker images use Java 11 by default","tags":["java","platform","docker"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"markewaite","html":"<div class=\"paragraph\">\n<p>Mark is the <a href=\"/project/team-leads/#documentation\">Jenkins Documentation Officer</a>, a long-time Jenkins user and contributor, and maintains the <a href=\"https://plugins.jenkins.io/git\">git plugin</a> and the <a href=\"https://plugins.jenkins.io/git-client\">git client plugin</a>.\nHe is active in <a href=\"/sigs/\">Jenkins special interest groups</a> including the <a href=\"/sigs/docs/\">Docs SIG</a>, <a href=\"/sigs/platform\">Platform SIG</a>, and <a href=\"/sigs/advocacy-and-outreach\">Advocacy SIG</a>.</p>\n</div>","id":"markewaite","irc":"markewaite","linkedin":"markwaite","name":"Mark Waite","slug":"blog/author/markewaite","twitter":"MarkEWaite"},{"avatar":{"childImageSharp":null},"blog":null,"github":"dheerajodha","html":"<div class=\"paragraph\">\n<p>Dheeraj is a Computer Science Engineering student (senior) at Vivekanand Institute of Technology, University of Mumbai. He started his journey of contributing to Jenkins in March 2021. His tiny contributions revolve around the <a href=\"https://github.com/jenkinsci/custom-distribution-service\">Custom Distribution Service for Jenkins Project</a>. He also likes to contribute to the JCasC project and documentation to help the developers.</p>\n</div>","id":"dheerajodha","irc":null,"linkedin":"dheeraj-singh-jodha","name":"Dheeraj Singh Jodha","slug":"blog/author/dheerajodha","twitter":null}]}},{"node":{"date":"2021-02-08T00:00:00.000Z","id":"cf843c22-ea33-5664-9347-9c1a8010c2ed","slug":"/blog/2021/02/08/docker-base-os-upgrade/","strippedHtml":"Beginning with Jenkins 2.279 and Jenkins 2.263.4, the Jenkins project is upgrading the base operating system and Java version used in the jenkins/jenkins:latest and jenkins/jenkins:lts images.\nThe update replaces OpenJDK 8u242 with AdoptOpenJDK 8u282 and replaces Debian 9 (\"Stretch\") with Debian 10 (\"Buster\").\n\nWhy?\n\nWe’re changing the base image so that we have a better supported operating system and a more current Java release for Jenkins controllers.\n\nBetter supported operating system\n\nThe Docker images provided by the Jenkins project rely on the operating system security processes of the operating system provider.\n\nOur Docker images have used Debian 9 (\"Stretch\") for multiple years.\nDebian 9 security updates have been discontinued as of July 6, 2020.\nDebian 9 Long Term Support security updates will be discontinued at the end of June 2022.\nThe upgrade to Debian 10 keeps us on an operating system maintained by the operating system security team.\n\nMore current Java release\n\nThe Debian 9 Docker images were based on the openjdk:8-jdk-stretch Docker image.\nThe last update to that image was one year ago with the release of JDK 8u242.\nWe need a maintained Docker base image that keeps pace with JDK releases and operating system updates so that the controller is running the most recent Java updates and most recent operating system updates.\n\nOther Jenkins controller images have already switched from using openjdk base images to instead use base images provided by Eclipse Adoptium.\nEclipse Adoptium is the Eclipse project formed when AdoptOpenJDK joined the Eclipse Foundation.\nThis change adapts the jenkins/jenkins:latest and jenkins/jenkins:lts images to use the Adoptium JDK images in the same pattern as is already used for the Jenkins JDK 11 Docker images like jenkins/jenkins:lts-jdk11.\nThe Jenkins Platform SIG has enjoyed very good results in our interactions with the Eclipse Adoptium project.\nWe look forward to continuing our collaboration with them.\n\nThanks a lot to Alex Earl and Jim Crowley for the image build restructuring groundwork that made the image upgrade possible!\nAlso thanks to Oleg Nenashev and other contributors for their reviews and testing.\n\nPackaging changes\n\nThe Jenkins Docker image based on Debian 10 (\"Buster\") includes some different packages than Debian 9 (\"Stretch\").\nSome packages have been removed because they are no longer supported by their communities.\nSome packages have been removed due to infrequent and decreasing use.\nUsers of the Jenkins Docker images may need to extend their definition of their Docker image to include packages that are no longer included in the base image.\n\nSCM packages removed\n\nThe following source control management packages are no longer included in the Jenkins controller images for jenkins/jenkins:latest or for jenkins/jenkins:lts :\n\nbzr\n\nmercurial\n\nsubversion\n\nOther packages removed\n\nAdditional packages that are no longer included in the Jenkins controller images include:\n\nbzip2\n\nmime-support\n\npython (the Python project stopped supporting Python 2 January 1, 2020)\n\nxz-utils\n\nA detailed list of the exact package changes is available in the pull request.\n\nUpgrade and compatibility notes\n\nThe Jenkins controller images are designed to be extended to meet user needs.\nCustom Jenkins controller images can be created from the base images and are designed to allow additional Jenkins plugins and additional operating system packages.\n\nFor example, the Installing Docker instructions illustrate a technique to install the Blue Ocean plugins and some operating system packages in a custom Docker image.\n\nDocker image with Subversion\n\nThe following Docker image definition installs the most recent Jenkins Long Term Support release with the subversion plugin and the operating system subversion command:\n\nFROM jenkins/jenkins:lts\nUSER root\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends subversion\nUSER jenkins\nRUN jenkins-plugin-cli --plugins subversion:2.14.0\n\nBuild a new docker image from this Dockerfile and assign the image a meaningful name, e.g. \"myjenkins-subversion:1.1\":\n\ndocker build -t myjenkins-subversion:1.1 .\n\nDocker image with Mercurial\n\nThe following Docker image definition installs the most recent Jenkins Weekly release with the mercurial plugin and the operating system hg command:\n\nFROM jenkins/jenkins:latest\nUSER root\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends mercurial\nUSER jenkins\nRUN jenkins-plugin-cli --plugins mercurial:2.12\n\nBuild a new docker image from this Dockerfile and assign the image a meaningful name, e.g. \"myjenkins-mercurial:1.1\":\n\ndocker build -t myjenkins-mercurial:1.1 .\n\nWhat’s next?\n\nWe will continue Docker image updates as new Java versions are released.\n\nIf you are interested in new features in Jenkins Docker packaging,\nstay tuned for future announcements!\nThere are multiple ongoing initiatives which you can find on the public Jenkins roadmap.\nSome stories:\n\nSwitching to AdoptOpenJDK.\n\nGeneral availability of Windows images.\n\nSupport for more platforms (AArch64, IBM s390x, PowerPC).\n\nIntroducing multi-platform Docker images.\n\nIf you are interested in any of these projects and would like to contribute,\nplease reach out to the Platform Special Interest Group which coordinates initiatives related to Jenkins in Docker.","title":"Docker image updates","tags":["announcement","docker","platform-sig"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"markewaite","html":"<div class=\"paragraph\">\n<p>Mark is the <a href=\"/project/team-leads/#documentation\">Jenkins Documentation Officer</a>, a long-time Jenkins user and contributor, and maintains the <a href=\"https://plugins.jenkins.io/git\">git plugin</a> and the <a href=\"https://plugins.jenkins.io/git-client\">git client plugin</a>.\nHe is active in <a href=\"/sigs/\">Jenkins special interest groups</a> including the <a href=\"/sigs/docs/\">Docs SIG</a>, <a href=\"/sigs/platform\">Platform SIG</a>, and <a href=\"/sigs/advocacy-and-outreach\">Advocacy SIG</a>.</p>\n</div>","id":"markewaite","irc":"markewaite","linkedin":"markwaite","name":"Mark Waite","slug":"blog/author/markewaite","twitter":"MarkEWaite"}]}},{"node":{"date":"2020-05-11T00:00:00.000Z","id":"a9a89ae0-1c8f-5566-81ab-6fdf73b725f7","slug":"/blog/2020/05/11/docker-windows-agents/","strippedHtml":"We would like to announce the availability of official Windows agent images for Docker.\nThese images allow provisioning Jenkins agents with Windows OS on Docker and Kubernetes.\n\nNew images\n\nAll official Docker images for agents now provide nanoserver-1809 and windowsservercore-1809 tags which include Windows images and, at the moment, Java 8 (these are like the latest tag).\nWe also provide tags with explicit Java selection, e.g. jdk8-windowsservercore-1809 or jdk11-nanoserver-1809.\nVersion tags are also available, e.g. jenkins/agent:4.3-4-jdk8-nanoserver-1809.\n\njenkins/agent is a basic agent which bundles the agent.jar for agent ⇐ ⇒ controller communication. This is most useful as a base image for other images.\nWindows images are available starting from version 4.3-4\n\njenkins/inbound-agent is an agent that is based on the jenkins/agent image above. It provides a wrapper script written in PowerShell to help specify the parameters to agent.jar.\nWindows images are available starting from version 4.3-4\n\njenkins/ssh-agent is an image which has OpenSSH installed and should be used with the SSH Build Agents Plugin.\nWindows images are available starting from version 2.1.0\n\nUsing Windows Docker images\n\nTo use the new images, you will need a proper Docker or Kubernetes environment which supports running Windows containers.\nFor Windows desktop users, the easiest way is to use Docker for Windows.\nWindows support in Kubernetes is documented here.\n\njenkins/agent\n\nThe jenkins/agent image is a simple agent with the JDK and the agent.jar (Jenkins Remoting library).\n\nThere are two main use cases for this image:\n\nAs a base image for other Docker images (e.g., FROM jenkins/agent:jdk8-nanoserver-1809 in your Dockerfile). The jenkins/inbound-agent is based on this image.\n\nThis image may also be used to launch an agent using the Launch method of Launch agent via execution of command on the master.  This allows the controller to launch the agent inside the docker container automatically.\n\nTo run the agent for the second use case, you would specify the following command on the Jenkins controller after setting Remote root directory to C:\\Users\\jenkins\\agent :\n\ndocker run -i --rm --name agent --init jenkins/agent:jdk8-windowsservercore-1809 java -jar C:/ProgramData/Jenkins/agent.jar\n\njenkins/inbound-agent\n\nThe inbound-agent Docker image tries to provide a higher level interaction with the agent.jar executable. It provides a PowerShell wrapper script around agent.jar and it is specified as the entrypoint so that you just need to pass in some command line arguments to run the agent. A pull request has been opened which documents these command line parameters and environment variables.\n\nExample:\n\ndocker run jenkins/inbound-agent:windowsservercore-1809 `\n   -Url http://jenkins-server:port `\n   -WorkDir=C:/Users/jenkins/Agent `\n   -Secret `\n   -Name\n\nExample using environment variables:\n\ndocker run -e \"JENKINS_URL=http://jenkins-server:port\" -e \"JENKINS_AGENT_NAME=AGENTNAME\" `\n   jenkins/inbound-agent:windowsservercore-1809 `\n   -WorkDir=C:/Users/jenkins/Agent `\n   -Secret `\n   -Name\n\nThe -Url, -Name and -Secret parameters are required, but can be specified as either command line parameters or environment variables.\n\njenkins/ssh-agent\n\nAs mentioned above the jenkins/ssh-agent docker image is based on SSH communication with the controller, rather than the remoting TCP or WebSocket protocols. The image sets up a jenkins user and the OpenSSH server so that the controller can connect to the agent via SSH. The image expects an SSH public key as a parameter and puts that key into the authorized_keys file for the jenkins user. The private key should be specified in the agent configuration on the controller to allow the controller to connect.\n\nExample:\n\ndocker run jenkins/ssh-agent:jdk8-windowsservercore-1809 \"\"\n\nYou can also pass the public key as an environment variable when using docker run.\n\nExample:\n\ndocker run -e \"JENKINS_AGENT_SSH_PUBKEY=\" jenkins/ssh-agent:jdk8-windowsservercore-1809\n\nYou will then be able to connect this agent using the SSH Build Agents Plugin as \"jenkins\" with the matching private key.\n\nWhat’s next?\n\nWe are considering providing versions based on Windows Server 2019 build 1909 so that Jenkins users can run these images on GKE clusters (see this issue).\n\nWe are also looking into providing multiarch manifests which would allow Windows images to be part of the latest tag.\n\nThere is also an open pull-request to create a Windows based Docker image for a Jenkins controller. There hasn’t been a lot of requests for this, but to make the offerings complete for Windows users, the pull request was created.\n\nFor plans unrelated to Windows, please see the Docker images for agents: New names and What’s next blogpost.","title":"Windows Docker Agent Images: General Availability","tags":["announcement","docker","platform-sig","windows"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"slide","html":"<div class=\"paragraph\">\n<p>Alex comes from a .NET background but likes to get his hands dirty in many different languages and frameworks. He currently\ndoes embedded development in a silicon validation group. He is an internal evangelist for Jenkins at his company. Alex\nis a community contributor to Jenkins, working on plugin hosting and maintaining several plugins. He is also involved in\na few SIGS. Alex enjoys working on open source software in his \"free\" time as well as spending time with his family.</p>\n</div>","id":"slide_o_mix","irc":null,"linkedin":null,"name":"Alex Earl","slug":"blog/author/slide_o_mix","twitter":"alexcearl"}]}},{"node":{"date":"2020-05-06T00:00:00.000Z","id":"4e4838ee-bab2-53c0-b338-e2fa90ee89b2","slug":"/blog/2020/05/06/docker-agent-image-renaming/","strippedHtml":"We would like to announce the renaming of the official Docker images for Jenkins agents.\nIt does not have any immediate impact on Jenkins users, but they are expected to gradually upgrade their instances.\nThis article provides information about the new official names, upgrade procedure, and the support policy for the old images.\nWe will also talk about what’s next for the Docker packaging in Jenkins.\n\nNew image names\n\njenkins/agent is the new name of the old jenkins/slave image,\nstarting from 4.3-2\n\njenkins/inbound-agent is the new name of the jenkins/jnlp-slave image,\nstarting from 4.3-2\n\njenkins/ssh-agent is the new name of the old jenkins/ssh-slave image,\nstarting from 2.0.0\n\nSee the upgrade guidelines below.\n\nWhy?\n\nThe \"slave\" term is widely considered inappropriate in open source communities.\nIt has been officially deprecated in Jenkins 2.0 in 2016, but there are remaining usages in some Jenkins components.\nThe jira:JENKINS-42816[Slave to Agent renaming leftovers] EPIC tracks cleanup of such usages.\nOfficial Docker agent images were a glaring case, it was not easy to fix that with the previous versions of the image release Pipelines on DockerHub.\nIt is great to have the image naming issue finally fixed by this update.\n\nAnother notable change is replacing the JNLP agent term with inbound agent.\nHistorically \"JNLP\" has been used as a name of Remoting protocols.\nJNLP stands for Java Network Launch Protocol which is a part of the Java Web Start.\nJenkins supports Java Web Start mode for agents when running agents on Java 1.8,\nbut our networking protocols are based on TCP and have nothing to do with Java Network Launch Protocol.\nThis name has been very confusing since the beginning\nand became worse with the introduction of WebSocket support in Jenkins 2.217 (jep:222[]).\nDocker agent images support WebSockets, so we decided to change the image name to jenkins/inbound-agent so that it prevents further confusion.\nInbound agent term refers to agent protocols in which the agent initiates the connection to the Jenkins controller through different protocols.\n\nThanks a lot to Alex Earl and krufab for the repository restructuring groundwork which made the renaming possible!\nAlso thanks to Tim Jacomb, Marky Jackson, Mark Waite, Ivan Fernandez Calvo and other contributors for their reviews and testing.\n\nUpgrading and Compatibility Notes\n\nGood news, there are no breaking changes caused by this renaming.\nAll images have been already modified to use the new terminology internally.\nIf you use the recent versions of the previous images,\nyou can just replace the old names with the new ones.\nThese names may be referenced in your Dockerfiles, scripts, and Jenkins configurations.\n\nWe will keep updating the old images on DockerHub for at least 3 months (until August 05, 2020).\nThere will be no new configurations and platforms added to the old images,\nbut all existing ones will remain available (Debian for Java 1.8 and 11, Alpine for Java 1.8, etc.).\nAfter August 05, 2020, the old images will no longer receive updates, but previous versions will remain available to users on DockerHub.\n\nWhat’s next?\n\nWe will continue renaming of the Docker images in Jenkins components which reference old image names.\nThere is also a set of convenience Docker images which include build tools like Maven or Gradle which will be renamed later.\nThe jenkins/ssh-agent image might be renamed again in the future as well;\nsee the ongoing discussion in this developer mailing list thread.\n\nIf you are rather interested in new features in Jenkins Docker packaging,\nstay tuned for future announcements!\nThere are multiple ongoing initiatives which you can find on the public Jenkins roadmap\n(in the draft stage, see jep:14[]).\nSome stories:\n\nGeneral availability of Windows images.\n\nSupport for more platforms (AArch64, IBM s390x, PowerPC).\n\nSwitching to AdoptOpenJDK.\n\nIntroducing multi-platform Docker images.\n\nIf you are interested in any of these projects and would like to contribute,\nplease reach out to the Platform Special Interest Group which coordinates initiatives related to Jenkins in Docker.\n\nRegarding the agent terminology cleanup outside Docker images,\nwe will keep working on this project in the Advocacy & Outreach SIG.\nIf you see the usage of the obsolete \"slave\" term anywhere in the Jenkins organization (Web UI, documentation, etc.),\nplease feel free to submit a pull request or to report an issue in the jira:JENKINS-42816[Slave to Agent renaming leftovers] EPIC.\nThere are \"just\" 3000 occurences left in the jenkinsci GitHub organization, but we will get there.\nAny contributions will be appreciated!","title":"Docker images for agents: New names and What's next","tags":["announcement","docker","platform-sig"],"authors":[{"avatar":{"childImageSharp":null},"blog":"https://oleg-nenashev.github.io/","github":"oleg-nenashev","html":"<div class=\"paragraph\">\n<p>Jenkins core maintainer and board member.\nOleg started using Hudson for Hardware/Embedded projects in 2008 and became an active Jenkins contributor in 2012.\nNowadays he leads several Jenkins <a href=\"/sigs\">SIGs</a>, outreach programs (<a href=\"/projects/gsoc\">Google Summer of Code</a>, <a href=\"/events/hacktoberfest\">Hacktoberfest</a>) and <a href=\"/projects/jam/\">Jenkins meetups</a> in Switzerland and Russia.\nOleg works for <a href=\"https://www.cloudbees.com/\">CloudBees</a> and focuses on key projects in the community.</p>\n</div>","id":"oleg_nenashev","irc":"oleg_nenashev","linkedin":"onenashev","name":"Oleg Nenashev","slug":"blog/author/oleg_nenashev","twitter":"oleg_nenashev"}]}},{"node":{"date":"2018-12-10T00:00:00.000Z","id":"432aab4d-1fb0-5872-b4e3-0530602e2a92","slug":"/blog/2018/12/10/the-official-Docker-image/","strippedHtml":"There are now three different Docker Hub repositories that are or have been used as the \"official\" Jenkins image.\nThis article aims at providing a clarification about which one is the current official one (as of December 2018 :-)).\n\nThe official one\n\ndocker pull jenkins/jenkins\n\ni.e. https://hub.docker.com/r/jenkins/jenkins/ is the right repository to use.\n\nI also documented some time ago on my blog the recommended way to run Jenkins using the official Docker image.\n\nThe deprecated ones\n\njenkins\n\nDeprecated since a long time already.\nA short version of why we stopped using and updating this image is that we never had a way to get our images published without having each time to go through a manual process.\n\njenkinsci/jenkins\n\nDeprecated since a long time too, but for easing transition, we had kept updating both jenkins/jenkins (the right one) and jenkinsci/jenkins together.\nWe stopped updating jenkinsci/jenkins in early December 2018 (cf. INFRA-1934 for details if you are interested)\n\nThanks for reading!","title":"Official Jenkins image to use from Docker Hub","tags":["docker"],"authors":[{"avatar":{"childImageSharp":null},"blog":"http://batmat.net","github":"batmat","html":"<div class=\"paragraph\">\n<p>Baptiste has been using and contributing to Jenkins since it was called differently, and is a huge proponent of the Agile, Devops &amp; Continuous Delivery movements.\nHe loves to discuss not only the technical aspects, but also the even more essential cultural aspects of this all, working together to improve the value provided to customers in a great inclusive and blameless environment.</p>\n</div>","id":"batmat","irc":null,"linkedin":null,"name":"Baptiste Mathus","slug":"blog/author/batmat","twitter":"bmathus"}]}},{"node":{"date":"2018-10-16T00:00:00.000Z","id":"2abe9d0a-5a91-57f9-b708-13a0a890774b","slug":"/blog/2018/10/16/custom-war-packager/","strippedHtml":"I would like to introduce Custom WAR Packager -\na new tool for Jenkins administrators and developers.\nThis tool allows packaging custom Jenkins distributions as WAR files,\nDocker images\nand Jenkinsfile Runner bundles.\nThis tool allows packaging Jenkins, plugins, and configurations in a ready-to-fly distribution.\nCustom WAR packager is a part of the Ephemeral Jenkins controller toolchain\nwhich we presented in our A Cloud Native Jenkins blogpost.\nThis toolchain is already used in Jenkins X to package serverless images.\n\nIn this blogpost I will show some common use-cases for Custom WAR Packager.\n\nHistory\n\nAs with Jenkins itself, Custom WAR Packager started as a small development tool.\nFor a long time it was a problem to run integration testing in Jenkins.\nWe have 3 main frameworks for it:\nJenkins Test Harness,\nAcceptance Test Harness,\n    and Plugin Compatibility Tester.\nAll these frameworks require a Jenkins WAR file to be passed to them to run tests.\nWhat if you want to run Jenkins tests in a custom environment like AWS?\nOr what if you want to reuse existing Jenkins Pipeline tests and to run them against\nPluggable Storage to ensure there are no regressions?\n\nAnd it was not just an idle question.\nThere were major activities happening in the Jenkins project: Cloud-Native Jenkins, Jenkins Evergreen, and Jenkins X.\nAll these activities required a lot of integration testing  to enable Continuous Delivery flows.\nIn order to do this in existing test frameworks, we needed to package a self-configuring WAR file so that it would be possible to run integration tests in existing frameworks.\nThat is why Custom WAR Packager was created in April 2018.\nLater it got support for packaging Docker images,\nand in September 2018 it also got support for Jenkinsfile Runner\nwhich was created by Kohsuke Kawaguchi\nand then improved by Nicolas de Loof.\n\nWhat’s inside?\n\nCustom WAR packager is a tool which is available as CLI Executable, Maven Plugin, or Docker package.\nThis tool takes input definitions and packages them as requested by the user.\nEverything is managed by a YAML configuration file:\n\nThe tool supports various types of inputs.\nThe list of plugins can be passed via YAML itself, pom.xml, or a BOM file from jep:309[].\nCustom WAR Packager supports not only released versions,\nbut also builds deployed to the Incremental repository (CD flow for Jenkins core and plugins - jep:305[]) and\neven direct builds by Git or directory path specifications.\nIt allows building packages from any source, without waiting for official releases.\nThe builds are also pretty fast, because the plugin does caching in the local Maven repository by using commit IDs.\n\nCustom WAR packager also supports the following self-configuration options:\n\nYAML files for Jenkins Configuration as Code\n\nGroovy Hooks (e.g. init hooks for pre-configuration)\n\nSystem properties\n\nWAR Packaging\n\nWAR packaging happens by default every time the repo is built.\nGenerally Custom WAR Packager repackages all inputs into a single WAR file by following conventions defined in the Jenkins core and the JCasC plugin.\n\nSample configuration:\n\nbundle:\n  groupId: \"io.jenkins.tools.war-packager.demo\"\n  artifactId: \"blogpost-demo\"\n  vendor: \"Jenkins project\"\n  description: \"Just a demo for the blogpost\"\nwar:\n  groupId: \"org.jenkins-ci.main\"\n  artifactId: \"jenkins-war\"\n  source:\n    version: 2.138.2\nplugins:\n  - groupId: \"io.jenkins\"\n    artifactId: \"configuration-as-code\"\n    source:\n      # Common release\n      version: 1.0-rc2\n  - groupId: \"io.jenkins\"\n    artifactId: \"artifact-manager-s3\"\n    source:\n      # Incrementals\n      version: 1.2-rc259.c9d60bf2f88c\n  - groupId: \"org.jenkins-ci.plugins.workflow\"\n    artifactId: \"workflow-job\"\n    source:\n      # Git\n      git: https://github.com/jglick/workflow-job-plugin.git\n      commit: 18d78f305a4526af9cdf3a7b68eb9caf97c7cfbc\n  # etc.\nsystemProperties:\n    jenkins.model.Jenkins.slaveAgentPort: \"9000\"\n    jenkins.model.Jenkins.slaveAgentPortEnforce: \"true\"\ngroovyHooks:\n  - type: \"init\"\n    id: \"initScripts\"\n    source:\n      dir: src/main/groovy\ncasc:\n  - id: \"jcasc\"\n    source:\n      dir: casc.yml\n\nDocker packaging\n\nIn order to do the Docker packaging, Custom WAR Packager uses the official\njenkins/jenkins\nDocker images or other images using the same format.\nDuring the build the WAR file just gets replaced by the one built by the tool.\nIt means that ALL image features are available for such custom builds: plugins.txt, Java options, Groovy hooks, etc., etc.\n\n## ...\n## WAR configuration from above\n## ...\n\nbuildSettings:\n  docker:\n    build: true\n    # Base image\n    base: \"jenkins/jenkins:2.138.2\"\n    # Tag to set for the produced image\n    tag: \"jenkins/custom-war-packager-casc-demo\"\n\nFor example, this demo\nshows packaging of a Docker image with External Build Logging to Elasticsearch.\nAlthough the implementations have been improved as a part of jep:207[] and jep:210[],\nyou can check out this demo to see how the Docker image does self-configuration, connects to a Elasicsearch, and then starts externally storing logs without changes in build log UIs.\nA Docker Compose file for running the entire cluster is included.\n\nJenkinsfile Runner packaging\n\nThis is probably the most tricky mode of Jenkinsfile Runner.\nIn March a new Jenkinsfile Runner project\nwas announced in the developer mailing list.\nThe main idea is to support running Jenkins Pipeline in a single-shot controller mode when the instance just executes a single run and prints outputs to the console.\nJenkinsfile Runner runs as CLI or as a Docker image.\nCustom WAR Packager is able to produce both, though only Docker run mode is recommended.\nWith Jenkinsfile Runner you can run Pipelines simply as…​\n\ndocker run --rm -v $PWD/Jenkinsfile:/workspace/Jenkinsfile acmeorg/jenkinsfile-runner\n\nWhen we started working on Ephemeral (aka \"single-shot\") controllers in the Cloud Native SIG,\nthere was an idea to use Custom WAR Packager and other existing tools (Jenkinsfile Runner, Jenkins Configuration as Code, etc.) to implement it.\nIt would be possible to just replace Jenkins core JAR and add plugins to Jenkinsfile Runner, but it is not enough.\nTo be efficient, Jenkinsfile Runner images should start up FAST, really fast.\nIn the build flow implementation we used some experimental options available in Jenkins and Jenkinsfile Runner, including classloader precaching, plugin unarchiving, etc, etc.\nWith such patches Jenkins starts up in few seconds with configuration-as-code and dozens of bundled plugins.\n\nSo, how to build custom Jenkinsfile Runner images?\nAlthough there is no release so far, it is not something which can stop us as you see above.\n\n##...\n## WAR Configuration from above\n##...\n\nbuildSettings:\n  jenkinsfileRunner:\n    source:\n      groupId: \"io.jenkins\"\n      artifactId: \"jenkinsfile-runner\"\n      build:\n        noCache: true\n      source:\n        git: https://github.com/jenkinsci/jenkinsfile-runner.git\n        commit: 8ff9b1e9a097e629c5fbffca9a3d69750097ecc4\n    docker:\n      base: \"jenkins/jenkins:2.138.2\"\n      tag: \"onenashev/cwp-jenkinsfile-runner-demo\"\n      build: true\n\nYou can find a Demo of Jenkinsfile Runner packaging with Custom WAR Packager\nhere.\n\nMore info\n\nThere are many other features which are not described in this blogpost.\nFor example, it is possible to alter Maven build settings or to add/replace libraries within the Jenkins core (e.g. Remoting).\nPlease see the Custom WAR Packager documentation for more information.\nThere are a number of demos available in the repository.\n\nIf you are interested to contribute to the repository,\nplease create pull requests and CC @oleg-nenashev\nand Raul Arabaolaza who is the second maintainer now working on Jenkins test automation flows.\n\nWhat’s next?\n\nThere are still many improvements that could be made to the tool to make it more efficient:\n\nAdd upper bounds checks for transitive plugin dependencies so that the conflicts are discovered during the build\n\nAllow passing all kinds of system properties and Java options via configuration YAML\n\nImprove Jenkinsfile Runner to improve performance\n\nIntegrate the tool into Jenkins Integration test flows\n(see essentialsTest()\nin the Jenkins Pipeline library)\n\nMany other tasks could be implemented in Custom WAR Packager,\nbut even now it is available to all Jenkins users so that they can build their own Jenkins bundles with it.\n\nWant to know more?\n\nIf you are going to DevOps World - Jenkins World in Nice on Oct 22-25,\nI will be presenting Custom WAR Packager at the Community Booth during the lunch demo sessions.\nWe will be also repeating our A Cloud Native Jenkins talk together with Carlos Sanchez where we will show how Ephemeral Jenkins works with Pluggable Storage.\nJenkins X team is also going to present their project using Custom WAR Packager.\n\nCome meet Oleg and other Cloud Native SIG members at\nDevOps World - Jenkins World on October 22-25 in Nice.\nregister with the code JWFOSS for a 30% discount off your pass.","title":"Build your own Jenkins! Introducing Custom WAR/Docker Packager","tags":["tools","docker","jenkins-x","cloud-native"],"authors":[{"avatar":{"childImageSharp":null},"blog":"https://oleg-nenashev.github.io/","github":"oleg-nenashev","html":"<div class=\"paragraph\">\n<p>Jenkins core maintainer and board member.\nOleg started using Hudson for Hardware/Embedded projects in 2008 and became an active Jenkins contributor in 2012.\nNowadays he leads several Jenkins <a href=\"/sigs\">SIGs</a>, outreach programs (<a href=\"/projects/gsoc\">Google Summer of Code</a>, <a href=\"/events/hacktoberfest\">Hacktoberfest</a>) and <a href=\"/projects/jam/\">Jenkins meetups</a> in Switzerland and Russia.\nOleg works for <a href=\"https://www.cloudbees.com/\">CloudBees</a> and focuses on key projects in the community.</p>\n</div>","id":"oleg_nenashev","irc":"oleg_nenashev","linkedin":"onenashev","name":"Oleg Nenashev","slug":"blog/author/oleg_nenashev","twitter":"oleg_nenashev"}]}},{"node":{"date":"2018-08-17T00:00:00.000Z","id":"003e40e9-a1b3-5859-a18a-60017d86c651","slug":"/blog/2018/08/17/speaker-blog-brent-laster/","strippedHtml":"More and more today, continuous delivery (CD) pipelines are making use of containers.\nIn many implementations, the primary workflow/orchestration tool for CD pipelines is Jenkins.\nAnd the primary container orchestration tool is Docker.\nTogether these two applications provide a powerful, yet simple to understand and use, model for leveraging containers in your CD pipeline.\n\nWhen creating a pipeline script in Jenkins, there are multiple ways to incorporate Docker into your CD pipeline.\nThey include:\n\nManually running a predefined Docker image as a separate Jenkins agent\n\nAutomatically provisioning a Docker image, when needed, as a part of a “cloud” configuration\n\nReferencing a “docker” global variable that can be invoked via the Jenkins DSL\n\nCalling the Docker executable directly via a shell call in the Jenkins DSL\n\nFor this article, we’ll focus on the third item in this list given that it provides the most flexibility and convenience for Docker use in the pipeline.\nMore details on the other three can be found in the upcoming “Continuous Delivery and Containerization” workshop at Jenkins World/DevOps World 2018.\n\nFirst, we’ll provide some background on a couple of terms for those who may not be familiar with Jenkins 2.\nIf you already are familiar with it, feel free to skip ahead to the Global Variables section.\n\nBackground\n\nWhen we talk about Jenkins here, we’re referring to “Jenkins 2” - a name we use to generally refer to the 2.0 and beyond versions of Jenkins.\nJenkins 2 offers a powerful evolution of Jenkins over prior versions.\nIn particular, it provides full integration for “pipeline-as-code” (PAC).\nPAC refers to being able to write your pipeline in a scripting language, much like source code for any program.\nThe code you write becomes the program that defines your pipeline.\nIt is also the code that gets executed when your pipeline is initiated.\nListing 1 shows a simple example pipeline.\nNotice that this is very different from the classic way of creating pipelines in Jenkins.\nHere you are writing code - rather than the more traditional approaches, such as filling in web forms to configure a Freestyle job.\n\n// Scripted Pipeline //\nnode('worker') {\n    stage('Source') { // Get code\n        // Get code from our git repository\n        git 'git@diyvb2:/home/git/repositories/workshop.git'\n    }\n    stage('Compile') { // Compile and do unit testing\n        // Run gradle to execute compile and unit testing\n        sh \"gradle clean compileJava test\"\n    }\n}\n// Declarative //\n\nListing 1: Example Jenkins 2 pipeline\n\nThe language that we write the Jenkins pipeline code in is a Domain-Specific Language (DSL).\nYou can think of it as the “programming language” for Jenkins pipelines.\nThere are two variants of it.\nThe style we saw in figure 1 is called “scripted syntax”.\nIt is a mixture of elements from the Groovy programming language and special Jenkins “steps”.\nThe Jenkins steps are provided by the plugins that are installed in the current system.\nA built-in tool called the Snippet Generator provides a wizard interface to allow users to pick the step and options they want.\nThen, the user can click on a button to have Jenkins automatically generate the correct DSL code in the large text box (figure 1).\nThe DSL code can be copied from there and pasted into the pipeline script.\n\nFigure 1. The Snippet Generator\n\nA second type of syntax is called “declarative syntax.”  We won’t go into detail on it here.\nBut it is a much more structured syntax that focuses on having users declare what they want in a pipeline, rather than writing the logic to make it happen.\n\nGlobal Variables\n\nIn addition to the steps that are provided by plugins, additional functionality for pipelines can be provided by global variables.\nThe simplest way to think of a global variable is as an object with methods that can be invoked on it.\nSeveral of these are built in to Jenkins, such as the Docker global variable.\nOthers can be created by users as part of the structure of a shared source code repository called a “shared pipeline library.”\n\nTo get a list of the global variables that are currently available to your Jenkins instance, you can go to the Snippet Generator screen.\nImmediately below the box for the generated pipeline script is a section titled Global Variables.\nThere, within the small print, is a link to get to the actual section (figure 2).\n\nFigure 2. Link to Global Variables Reference section.\n\nClicking on that link takes us to a list of currently available Global Variables.\nIf you have the Docker Pipeline Plugin installed, you will see one at the top for Docker. (Figure 3).\n\nFigure 3. Docker global variable specifics.\n\nBroadly, the docker global variable includes methods that can be applied to the Docker application, Docker images, and Docker containers.\n\nWe’ll focus first on a couple of the Docker image methods as shown in figure 4.\n\nFigure 4. Key methods for getting a Docker image.\n\nThere are multiple ways you can use these methods to create a new image.\nListing 2 shows a basic example of assigning and pulling an image using the image method.\n\nmyImage = docker.image(\"bclaster/jenkins-node:1.0\")\nmyImage.pull()\n\nListing 2: Assigning a image to a variable and pulling it down.\n\nThis can also be done in a single statement as shown in listing 3.\n\ndocker.image(\"bclaster/jenkins-node:1.0\").pull()\n\nListing 3: Shorthand version of previous call.\n\nYou can also download a Dockerfile and build an image based on it.(See listing 4.)\n\nnode() {\n    def myImg\n    stage (\"Build image\") {\n        // download the dockerfile to build from\n        git 'git@diyvb:repos/dockerResources.git'\n\n        // build our docker image\n        myImg = docker.build 'my-image:snapshot'\n    }\n}\n\nListing 4: Pipeline code to download a Dockerfile and build an image from it.\n\nFigure 5 shows the actual output from running that “Build image” stage.\nNote that the docker.build step was translated into an actual Docker build command.\n\nFigure 5. Actual Docker output from running the download and build\n\nThe Inside Command\n\nAnother powerful method available for the Docker global variable is the inside method.\nWhen executed, this method will do the following:\n\nGet an agent and a workspace to execute on\n\nIf the Docker image is not already present, pull it down\n\nStart the container with that image\n\nMount the workspace from Jenkins\n\nExecute the build steps\n\nMounting the workspace means that the Jenkins workspace will appear as a volume inside the container.\nAnd it will have the same file path.\nSo, things running in the container will have direct access to the same location.\nHowever, this can only be done if the container is running on the same underlying system - such that it can directly access the path.\n\nIn terms of executing the build steps, the inside method acts as a scoping method.\nThis means that the environment it sets up is in effect for any statement that happens within its scope (within the block under it bounded by {}).\nThe practical application here is that any pipeline “sh” steps (a call to the shell to execute something) are automatically run in the container.\nBehind the scenes, this is done by wrapping the calls with “docker exec”.\n\nWhen executed, the calls with the global variable are translated (by Jenkins) into actual Docker call invocations.\nListing 5 shows an example of using this in a script, along with the output from the first invocation of the “inside” method.\nYou can see in the output the docker commands that are generated from the inside method call.\n\nstage (\"Get Source\") {\n        // run a command to get the source code download\n        myImg.inside('-v /home/git/repos:/home/git/repos') {\n            sh \"rm -rf gradle-greetings\"\n            sh \"git clone --branch test /home/git/repos/gradle-greetings.git\"\n        }\n    }\n    stage (\"Run Build\") {\n        myImg.inside() {\n            sh \"cd gradle-greetings && gradle -g /tmp clean build -x test\"\n        }\n    }\n\nListing 5: Example inside method usage.\n\nFigure 6. Example inside method Docker command output.\n\nOnce completed, the inside step will stop the container,\nget rid of the storage, and create a record that this image was used for the build.\nThat record facilitates image traceability, updates, etc.\n\nAs you can see, the combination of using the Docker “global variable” and its “inside” method provide a simple and powerful way to spin up and work with containers in your pipeline.\nIn addition, since you are not having to make the direct Docker calls, you can invoke steps like sh within the scope of the inside method, and have them executed by Docker transparently.\n\nAs we mentioned, this is only one of several ways you can interact with Docker in your pipeline code.\nTo learn about the other methods and get hands-on practice, join me at DevOps World/Jenkins World in San Francisco or Nice for the workshop\n\" Creating a Deployment Pipeline with Jenkins 2\".\nHope to see you there!\n\nJoin the Jenkins project at\nJenkins World on September 16-19th,\nregister with the code JWFOSS for a 30% discount off your pass.","title":"Using the Docker Global Variable in Your Jenkins Pipeline","tags":["event","jenkinsworld","jenkinsworld2018","pipeline","docker"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"brentlaster","html":"<div class=\"paragraph\">\n<p>Brent Laster is a Senior Manager in the Research and Development division at SAS in Cary, North Carolina. He manages several groups involved with release engineering processes, best practices, and tooling. He also serves as a resource for the use of open-source technologies and conducts internal training classes in technologies such as Git, Gerrit, Gradle, and Jenkins, both in the U.S. and abroad.</p>\n</div>\n<div class=\"paragraph\">\n<p>Brent Laster is the author of \"Professional Git\"\n(a comprehensive guide to Git for users ranging from beginners to advanced)\nand \"Jenkins 2 – Up and Running:  Evolve Your Pipeline for Next-Generation Automation\".</p>\n</div>","id":"brentlaster","irc":null,"linkedin":null,"name":"Brent Laster","slug":"blog/author/brentlaster","twitter":"brentclaster"}]}},{"node":{"date":"2017-08-08T00:00:00.000Z","id":"2e385886-1033-5881-ab06-b060d5568108","slug":"/blog/2017/08/08/introducing-jenkins-minute/","strippedHtml":"This is a guest post by Liam Newman,\nTechnical Evangelist at CloudBees.\n\nThere are less than three weeks left until\nJenkins World 2017.\nLike last year, I’ll be at the\n\" Ask the Experts\"\nbooth to answer questions about all things Jenkins.\nIn preparation, I’ve started a continuing series of quick tutorial videos that answer\nsome of the most common questions I’ve seen asked in the community forums.\nThese  are by no means exhaustive - they’re basic answers, which we can build upon.\nEach video give a takes a simple example, shows how to create a working solution,\nand includes links in the description to related Jenkins documentation pages.\n\nI hope you find them useful.  Look for more of them coming soon!\n\nLiam will be at the\n\" Ask the Experts\"\nbooth at\nJenkins World in August.\nRegister with the code JWFOSS for a 30% discount off your pass.\n\nCreating Your First Pipeline in Blue Ocean\n\nUsing a Dockerfile with Jenkins Pipeline\n\nAdding Parameters to Jenkins Pipeline\n\nRecording Test Results and Archiving Artifacts","title":"Introducing the Jenkins Minute video series","tags":["blueocean","docker","jenkins-minute","pipeline"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"bitwiseman","html":"<div class=\"paragraph\">\n<p>Liam started his software career as a tester, which might explain why he&#8217;s such a fan of CI/CD and Pipeline as Code.\nHe has spent the majority of his software engineering career implementing Continuous Integration systems at companies big and small.\nHe is a Jenkins project contributor and an expert in Jenkins Pipeline, both Scripted and Declarative.\nLiam currently works as a Jenkins Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\nWhen not at work, he enjoys testing gravity by doing Aikido.</p>\n</div>","id":"lnewman","irc":null,"linkedin":null,"name":"Liam Newman","slug":"blog/author/lnewman","twitter":"bitwiseman"}]}}]}},"pageContext":{"tag":"docker","limit":8,"skip":0,"numPages":2,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}