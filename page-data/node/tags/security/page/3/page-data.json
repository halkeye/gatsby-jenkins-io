{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/security/page/3",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2019-02-21T00:00:00.000Z","id":"ee6f71b5-7195-56bb-8a9e-87e021747a53","slug":"/blog/2019/02/21/credentials-masking/","strippedHtml":"In the Jenkins project, we ask that people report security issues to our private issue tracker.\nThis allows us to review issues and prepare fixes in private, often resulting in better, safer security fixes.\n\nAs a side effect of that, we also learn about common misconceptions and usability problems related to security in Jenkins.\nThis post is intended to address one of those:\nThe goal and limitations of credentials masking.\n\nThe Problem\n\nOne very common example of that is the role of credentials masking in Jenkins, typically involving a pipeline snippet that looks like this:\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh './deploy.sh' // requires PWD and USR to be set\n}\n// Declarative //\n\nCredentials that are in scope are made available to the pipeline without limitation.\nTo prevent accidental exposure in the build log, credentials are masked from regular output, so an invocation of env (Linux) or set (Windows), or programs printing their environment or parameters would not reveal them in the build log to users who would not otherwise have access to the credentials.\n\nThe misconception here is that Jenkins will prevent other, perhaps deliberate ways to reveal the password.\nSome examples:\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh 'echo $PWD | base64' // will print e.g. dDBwczNjcjN0Cg= which is trivially converted back to the top secret password\n}\n// Declarative //\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh 'echo $PWD > myfile'\n  archiveArtifacts 'myfile' // then browse archived artifacts from the Jenkins UI\n}\n// Declarative //\n\nBoth of these snippets circumvent credentials masking in the build log, and show that people with control over the build script can use credentials in ways not necessarily intended or approved by admins.\n\nObviously these are just the most straightforward examples illustrating the problem.\nOthers could involve the proc file system, sending it to an HTTP server in response to a 401 authentication challenge, embedding it in the (otherwise legitimate) build result, etc.\n\nIt would be great if Jenkins could allow the flexible use of credentials with no risk of exposing them through straightforward build script modifications, but realistically, it is impossible for Jenkins to police use of the credential by a build script without the support of a very specific environment setup (e.g. restrictive network configuration).\n\nIt should also be noted that credentials aren’t just at risk from users able to control the pipeline, typically by editing the Jenkinsfile.\nActual build scripts invoked by pipelines, either shell scripts as in the example above, or more standard build tools such as Maven (controlled by pom.xml) are just as much of a risk if they are run inside a withCredentials block, or executing on the same agent as another block that passed such credentials.\n\nDisclosure of secrets can also happen inadvertently:\nJenkins will prevent exact matches of the password or other secret to appear in the log file.\nConsider that the secret may contain shell metacharacters that bash +x would escape by adding a \\ before those characters.\nThe sequence of characters to be printed is no longer identical to the secret, so would not be masked.\n\nThe Solution\n\nCredentials can be defined in different scopes:\nCredentials defined on the root Jenkins store (the default) will be available to all jobs on the instance.\nThe only exception are credentials with System scope, intended for the global configuration only, for example, to connect to agents.\nCredentials defined in a folder are only available within that folder (transitively, i.e. also in folders inside this folder).\n\nThis allows defining sensitive credentials, such as deployment credentials, on specific folders whose contents only users trusted with those credentials are allowed to configure:\nDirectly in Jenkins using Matrix Authorization Plugin and by limiting write access to repositories defining pipelines as code.\n\nPipelines inside this folder can use the (e.g. deployment) credentials without limitation, while they’re inaccessible to pipelines outside the folder.\nThose would need to use the build step or similar approaches to invoke the pipelines inside the folder to deploy their output.\n\nCaveats\n\nWhile the previous section outlines a solution to the problem of restricting access to credentials, care needs to be taken so that credentials are not captured anyway.\nFor example, a deployment pipeline that allows its users to define where to deploy to as a build parameter might still be used to send credentials to a maliciously set up host to capture them.\nA blog post explaining the design of some Jenkins project infrastructure discusses some of these concerns around trust.\n\nIt should also be noted that credential domains are a UI hint only — defining a credential to only be valid for github.com does not actually prevent its use elsewhere.","title":"Limitations of Credentials Masking","tags":["security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/author/daniel-beck","twitter":null}]}},{"node":{"date":"2019-02-17T00:00:00.000Z","id":"a79ea93c-0082-5a4a-a338-9fde01ae88b1","slug":"/blog/2019/02/17/remoting-cli-removed/","strippedHtml":"Close to two years ago, we announced in\nNew, safer CLI in 2.54\nthat the traditional “Remoting” operation mode of the Jenkins command-line interface\nwas being deprecated for a variety of reasons, especially its very poor security record.\nToday in Jenkins 2.165 support for this mode is finally being removed altogether,\nin both the server and bundled jenkins-cli.jar client.\nThe projected June 5th LTS release will reflect this removal,\nat which point the Jenkins project will no longer maintain this feature\nnor investigate security vulnerabilities in it.\n\nThis change makes the code in Jenkins core related to the CLI considerably simpler and more maintainable.\n(There are still two transports —HTTP(S) and SSH—but they have similar capabilities and behavior.)\nIt also reduces the “attack surface” the Jenkins security team must consider.\nAmong other issues, a compromised server could freely attack a developer’s laptop if -remoting were used.\n\nThe\n2.46.x upgrade guide\nalready urged administrators to disable Remoting mode on the server.\nThose Jenkins users who rely on the CLI for remote scripting (as opposed to the HTTP(S) REST APIs)\nwould be affected only if they were still using the -remoting CLI flag,\nsince the default has long been to use HTTP(S) mode.\n\nMost CLI features have long worked fine without -remoting,\nin some cases using slightly different syntax such as requiring shell redirects to access local files.\nAs part of this change, some CLI commands, options, and option types in Jenkins core have been removed, other than -remoting itself:\n\nThe login and logout commands, and the --username and --password options.\n\nThe -p option to select a proxy. (The CLI in default -http mode accesses Jenkins no differently than any other HTTP client.)\n\nThe install-tool, set-build-parameter, and set-build-result commands relied on a fundamentally insecure idiom that is no longer supportable.\n\nCommand options or arguments which took either a local file or = for standard input/output (e.g., install-plugin, build -p, support) now only accept the latter.\n\nSome features of relatively little-used plugins will no longer work, such as:\n\nDistFork\n\nRemote Terminal Access\n\nBuild Env Propagator","title":"Remoting-based CLI removed from Jenkins","tags":["core","security","remoting"],"authors":[{"avatar":null,"blog":null,"github":"jglick","html":"<div class=\"paragraph\">\n<p>Jesse has been developing Jenkins core and plugins for years.\nHe is the coauthor with Kohsuke of the core infrastructure of the Pipeline system.</p>\n</div>","id":"jglick","irc":null,"linkedin":null,"name":"Jesse Glick","slug":"/blog/author/jglick","twitter":"tyvole"}]}},{"node":{"date":"2019-01-07T00:00:00.000Z","id":"4187a71c-adb8-54ce-90c9-c412101f2f56","slug":"/blog/2019/01/07/webhook-firewalls/","strippedHtml":"In this post I wanted to show how you can run Jenkins behind a firewall (which could be a corporate firewall, a NAT’ed network like you have at home) but still receive webhooks in real time from GitHub.com. You can generalise this to other services too - such as BitBucket or DockerHub, or anything really that emits webhooks, but the instructions will be for GitHub projects hosted on github.com.\n\nWhat are webhooks\n\nJust a very quick refresher on what webhooks are: Messages (often JSON, but not always) typically posted by HTTP(S) from a server to a client that is listening for events.\n\nThe events flow left to right, Jenkins sits there happily listing on paths like /github-webhook/ or /dockerhub-webhook/ etc for some HTTP request to tell it to wake up and do some work.\n\nGitHub/BitBucket may be reporting a new commit or PR, or DockerHub reporting an upstream image has changed. What all these things have in common is that they push to Jenkins, and expect to be able to push to it (ie that Jenkins is visible to them). This works great when the network is open - say GitHub Enterprise, or Jenkins is listening on the web.\n\nNot on the web\n\nThe trick is when something gets in the middle, say a firewall:\n\n( As is industry standard, all firewalls have to be a wall on fire. Please don’t somehow set bricks on fire in your organisation)\n\nThis is just the same when you fire up Jenkins on your laptop, and want to receive webhooks from github.com (a legitimate thing, perhaps to test out your setup, perhaps to run builds for iOS on a mac, or some corner of a network that is not exposed to the web). Unless your laptop is addressable to the whole web that is (not likely), or your network is configured just right, the webhooks won’t be able to flow.\n\nThis is fine - we can fall back to polling for changes. Except this is terrible. You burn through API quotas, and you don’t get changes in real time, and really no one is happy.\n\nSome problems are opportunities\n\nWe can both solve this problem, but also, view this is an opportunity. Having things not addressable on the web, or locked down in some default way is a feature, not a bug. You massively reduce your attack surface, and can have defence in depth:\n\nA Webhook forwarding service\n\nEnter the memorably named Smee. This is an OSS project provided by GitHub and also helpfully hosted as a service by GitHub. This can capture and forward webhooks for you. I’ll try to explain it with a diagram:\n\nGitHub pushes an event (via HTTPS/json in this case) to Smee.io (the funny thing with circles, which is on the public web and accessible from GitHub.com) - and Jenkins in turn subscribes to Smee with an outgoing connection from a client. Note the direction of the arrows: Jenkins only makes an outbound connection.\n\nThis is the important point: this will work as long as the firewall is one way (like a NAT typically is, and many networks). If the Jenkins side can’t connect to anything on the outside world - well, this won’t help with that of course (but that is not often the case).\n\nSetting it up\n\nStep 1: Firstly - go to https://smee.io/ and click “Start a new channel”:\n\nThis will give you a unique URL (which you should copy for later use):\n\nNext you should install the smee client next to where you have the Jenkins server running:\n\nnpm install --global smee-client\n\n(This will make the smee client/command available to receive and forward webhooks).\n\nNow start the smee client and point it to your Jenkins server. In this case I have it running on port 8080 (the default if you fire it up on your laptop, change both the port and the smee URL as needed):\n\nsmee --url https://smee.io/GSm1B40sRfBvSjYS --path /github-webhook/ --port 8080\n\nThis says to connect to the smee service, and forward webhooks to /github-webhook/ (that trailing slash is important, don’t miss it). Once this is running, you will see it log that it is connected and forwarding webhooks. Leave this command running for as long as you want to receive webhooks.\n\nNext, you need to configure a pipeline that makes use of github. In this case I set up one from scratch. You can skip this if you already have a pipeline setup:\n\nI then chose “GitHub” as the where the code is:\n\nThen choose your repository. This will set things up ready to receive webhooks from GitHub. (also if you have an existing pipeline setup, and it is using GitHub as the SCM source, that is also fine).\n\nThe final step is to tell GitHub to post webhook events for that repository (or organization, you can do that too) to Smee (which ultimately means Jenkins will receive them).\n\nGo to the settings tab for your GitHub repository, and then click “add webhook”:\n\nNext, configure the webhook:\n\nPaste in the “smee” URL you copied from the step above.\n\nChoose application/json as the content type\n\nTell it to send everything (you can pick and choose what events, but I just did that as simpler).\n\nPress Add Webhook (or update)\n\nIt should look something like this:\n\nOK - webhooks should be flowing now. You can make a change to your repository, and check that a build starts soon after:\n\nGood luck!","title":"Triggering builds with webhooks behind a secure firewall","tags":["jenkins","webhooks","security"],"authors":[{"avatar":{"childImageSharp":null},"blog":null,"github":"michaelneale","html":"<div class=\"paragraph\">\n<p>Michael is a CD enthusiast with a interest in User Experience.\nHe is a co-founder of CloudBees and a long time OSS developer, and can often be found\nlurking around the jenkins-dev mailing list or #jenkins on irc (same nick as twitter name).\nBefore CloudBees he worked at Red Hat.</p>\n</div>","id":"michaelneale","irc":null,"linkedin":null,"name":"Michael Neale","slug":"/blog/author/michaelneale","twitter":"michaelneale"}]}},{"node":{"date":"2018-12-05T00:00:00.000Z","id":"f0b2bc67-df2c-5d35-83cb-1f19d82bdcd8","slug":"/blog/2018/12/05/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.154 and LTS 2.150.1, that fix multiple security vulnerabilities.\nSince 2.150.1 is the first release in the new LTS line, we also released 2.138.4, a security update for the previous LTS line.\nThis allows administrators to install today’s security fixes without having to upgrade to the new LTS line immediately.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes, see our LTS 2.138.4 upgrade guide.\n\nA note on previously released changes related to this fix\n\nIn the Jenkins core security updates released in August and October, we also included security improvements that can be disabled by setting various system properties.\nThose changes are an essential part of the SECURITY-595 fix, so we strongly recommend not disabling them for any reason.\nPreviously published documentation has been updated.","title":"Important security updates for Jenkins","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/author/daniel-beck","twitter":null}]}},{"node":{"date":"2018-11-12T00:00:00.000Z","id":"19ad29c6-3758-5c7b-bc08-31222e0bfca7","slug":"/blog/2018/11/12/inspecting-binaries-with-jenkins/","strippedHtml":"In a past blog post,\nDelivery Pipelines, with Jenkins 2, SonarQube, and Artifactory,\nwe talked about pipelines which result in binaries for development versions, and in\nDelivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production,\nwe examined ways to consistently promote applications toward production. In this blog post, I continue on both by discussing more details on security related quality gates\nand bringing this together with the handling of Docker images.\n\nUse case: Foster security on given, containerized business application\n\nSecurity is an overloaded term with varying meaning in different contexts. For this contribution, I consider security as the sum of rules regarding vulnerabilities\n(Common Vulnerability and Exposure, CVE), in binaries. In a past blog post, we’ve identified SonarQube already, as a very helpful tool to identify flaws\nin source code, particularly concerning reliability (bugs), vulnerabilities (security, e.g. CWE, that is common weakness enumaration, and OWASP, that is the Open Web Application Security Project), and\nmaintainability (code smells). Now it is a good time to add another tool to the chain, that is Twistlock, for inspection binaries for security issues.\nFeatures of Twistlock include\n\nCompliance and vulnerability management, transitively\n\nRuntime defense\n\nCloud-native CI/CD support\n\nBroad coverage of supported artifact types and platforms\n\nAPI, dashboards, and Jenkins integration, with strong configuration options\n\nThe underlying use case can be derived from several real-world security initiatives, in enterprises, based on given containerized applications. In practice, it is not a surprise that after adding such new\nquality gates, you identify historically grown issues. However, there are many good reasons to do so. You don’t need any Word documents to check any governance criteria manually, rather\nexecution and reporting are done automatically and also part of the actions are taken automatically. And above all, of course, your application is quality assured regarding known vulnerability issues, aligned with\nthe DevOps approach: development is interested in quick feedback whether their change would introduce any vulnerabilities, and operations is interested in insights whether and\nhow running applications are affected if a new CVE is discovered.\n\nThe term DevSecOps was coined to explicitely add security concerns to DevOps.\nIn my opinion, security is already inherent part of DevOps.\nThus, there is no strong reason to introduce a new word. Surely, new words are catchy.\nBut they have limits.\nOr have you ever experienced NoDev, the variant of DevOps where features are suddenly falling from the sky and deployed to production automatically?\n\nConceptually, container inspection is now part of the delivery pipeline and Twistlock processing is now triggered once we have produced our Docker images, see below, in order to get\nfast feedback.\n\nSoftware is staged over different environments by configuration, without rebuilding. All changes go through the entire staging process, although defined\nexception routines may be in place, for details see Michael Hüttermann, Agile ALM (Manning, 2012). The staged software consists of all artifacts which\nmake up the release, consistently, including the business application, test cases, build scripts, Chef cookbooks, Dockerfiles, Jenkins files to build all\nthat in a self-contained way, for details see Michael Hüttermann, DevOps for Developers (Apress, 2012).\n\nThis blog post covers sample tools. Please note, that there are also alternative tools available, and the best target architecture is aligned with concrete requirements and given basic\nconditions. Besides that, the sample toolchain is derived from couple of real world success stories, designed and implemented in the field. However, this blog post\nsimplifies and abstracts them in order to stay focussed while discussing the primitives of delivery units. For example, aggregating multiple Docker images with ASCII files, does not change the\nunderlying primitives and their handlings. For more information on all parts of the blog post, please consult the respective documentation, good books or attend fine conferences. Or go to the extremes: talk to your colleagues.\n\nIn our sample process, we produce a web application that is packaged in a Docker image. The produced Docker images are distributed only if the dedicated quality gate passes.\nA quality gate is a stage in the overall pipeline and a sum of defined commitments, often\ncalled requirements, the unit of work must pass. In our case, the quality gate comprises inspection of produced binaries and it fails if vulnerabilities of severity 'critical' are found.\nWe can configure Twistlock according to our requirements. Have a look how we’ve integrated it into our Jenkins pipeline, with focus on detecting vulnerabilities.\n\nJenkinsfile (excerpt): Twistlock inspection triggered\n\nstage('Twistlock: Analysis') { (1)\nString version = readFile('version.properties').trim() (2)\nprintln \"Scanning for version: ${version}\"\n    twistlockScan ca: '', cert: '', compliancePolicy: 'critical', \\\n        dockerAddress: 'unix:///var/run/docker.sock', \\\n        ignoreImageBuildTime: false, key: '', logLevel: 'true', \\\n        policy: 'critical', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', \\ (3)\nrequirePackageUpdate: false, tag: \"$version\", timeout: 10\n}\n\nstage('Twistlock: Publish') { (4)\nString version = readFile('version.properties ').trim()\n    println \"Publishing scan results for version: ${version}\"\n    twistlockPublish ca: '', cert: '', \\\n        dockerAddress: 'unix:///var/run/docker.sock', key: '', \\\n        logLevel: 'true', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', tag: \"$version\", \\\n        timeout: 10\n}\n\n1\nTwistlock inspection as part of the sequence of stages in Jenkinsfile\n\n2\nNailing down the version of the to be inspected image, dynamically\n\n3\nConfiguring analysis including vulnerability severity level\n\n4\nPublishing the inspection results to Twistlock console, that is the dashboard\n\nNow let’s start with the first phase to bring our application in shape again, that is gaining insight about the security related flaws.\n\nPhase 1: Gain insights about security related flaws\n\nAfter we’ve introduced the new quality gate, it failed, see image above. As integration with other tools, Jenkins is the automation engine and does provide helpful context information,\nhowever, those cannot replace features and data the dedicated, triggered tool does offer. Thus, this is the moment to switch to the dedicated tool, that is Twistlock. Opening\nthe dashboard, we can navigate to the Jenkins build jobs, that is the specific run of the build, and the respective results of the Twistlock analysis. What we see now is a list\nof vulnerabilities, and we need to fix those of severity critical in order to pass the quality gate, and get our changes again toward production. The list shows entries of\ntype jar, that is a finding in a binary as part of the Docker image, in our case the WAR file we’ve deployed to a web container (Tomcat), and of type OS, those are issues of the underlying image itself, the\noperating system, either part of the base image, or as a package added/changed in our Dockerfile.\n\nWe can now easily zoom in and examine the vulnerabilities of the Docker layers. This really helps to structure work and identify root causes. Since, typically,\na Docker image extends a Docker base image, the findings in the base image are shown on the top, see next screenshot, grouped by severity.\n\nOther Docker layers were added to the base image, and those can add vulnerabilities too. In our case, the packaged WAR file obviously contains a vulnerability. The next image shows how we examine that finding, while this time\nexpanding the Twistlock wizard (that is the plus sign) to directly see the list of found vulnerabilities.\n\nFinding and visualizing the issues are a very good first step, and we’ve even made those findings actionable, so we now have to take action and address them.\n\nPhase 2: Address the findings\n\nTo address the findings, we need to split our initiative into two parts:\n\nFixing the critical vulnerabilities related to the Docker image (in our case largely the base image)\n\nFixing the critical vulnerabilities related to the embedded deployment unit (in our case the WAR)\n\nLet’s proceed bottom up, first coping with the Docker base image.\n\nThis is an easy example covering multiple scenarios particularly identifying and fixing vulnerabilities in transitive binaries, i.e. binaries contained in\nother binaries, e.g. a Docker image containing a WAR file that in turn contains libraries. To expand this vertical feasibility spike, you can easily add\nmore units of each layer, or add more abstractions, however, the idea can always be nailed down to the primitives, covered in this blog post.\n\nLet’s now have a look at the used Docker image by looking at the used Dockerfile.\n\nDockerfile: The Dockerfile based on Alpine, running OpenJDK 8\n\nFROM openjdk:8-jre-alpine (1)\nLABEL maintainer \"michael@huettermann.net\"\n\n# Domain of your Artifactory. Any other storage and URI download link works, just change the ADD command, see below.\nARG ARTI\nARG VER\n\n# Expose web port\nEXPOSE 8080\n\n# Tomcat Version\nENV TOMCAT_VERSION_MAJOR 9 (2)\nENV TOMCAT_VERSION_FULL  9.0.6\n\n# Download, install, housekeeping\nRUN apk add --update curl &&\\ (3)\napk add bash &&\\\n  #apk add -u libx11 &&\\ (4)\nmkdir /opt &&\\\n  curl -LO ${ARTI}/list/generic-local/apache/org/tomcat/tomcat-${TOMCAT_VERSION_MAJOR}/v${TOMCAT_VERSION_FULL}/bin/apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &&\\\n  gunzip -c apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz | tar -xf - -C /opt &&\\\n  rm -f apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &&\\\n  ln -s /opt/apache-tomcat-${TOMCAT_VERSION_FULL} /opt/tomcat &&\\\n  rm -rf /opt/tomcat/webapps/examples /opt/tomcat/webapps/docs &&\\\n  apk del curl &&\\\n  rm -rf /var/cache/apk/*\n\n# Download and deploy the Java EE WAR\nADD http://${ARTI}/list/libs-release-local/com/huettermann/web/${VER}/all-${VER}.war /opt/tomcat/webapps/all.war (5)\n\nRUN chmod 755 /opt/tomcat/webapps/*.war\n\n# Set environment\nENV CATALINA_HOME /opt/tomcat\n\n# Start Tomcat on startup\nCMD ${CATALINA_HOME}/bin/catalina.sh run\n\n1\nBase image ships OpenJDK 8, on Alpine\n\n2\nDefined version of web container\n\n3\nApplying some defined steps to configure Alpine, according to requirements\n\n4\nUpdating package itself would address one vulnerability already\n\n5\nDeploying the application\n\nBy checking available versions of the official OpenJDK Alpine image, we see that there’s a newer version 8u181 which we could use.\nWe can zoom in and study release notes and contents, or we just pragmatically switch the base image to a more recent version. Often it is a good idea\nto upgrade versions regularly, in defined intervals. This leads to the following change in the Dockerfile.\n\nDockerfile (excerpt): The Dockerfile based on Alpine, running OpenJDK 8u181\n\nFROM openjdk:8u181-jre-alpine (1)\nLABEL maintainer \"michael@huettermann.net\"\n\n1\nBase image is now OpenJDK 8u181, on Alpine\n\nThere are more options available to fix the issues, but let’s proceed to the second part, the vulnerabilities in the deployment unit.\n\nBefore we push this change to GitHub, we also address the vulnerability issue in the deployment unit, that is jetty-io. Here we are a bit unsure about\nwhy, in this specific use case, the library is used. To retrieve more information about dependencies, we run a dependency:tree command on our Maven\nbased project. We now see that jetty-io is transitively referenced by org.seleniumhq.selenium:htmlunit-driver. We can surely discuss why this is a compile\ndependency and the libraries are shipped as part of the WAR, but let’s consider this to be given according to requirements, thus we must take special attention now\nto version 2.29.0 of the specific library.\n\nAlso here we can browse release notes and content (particularly how those libs are built themselves), and come to the conclusion to\nswitch from the used version, that is 2.29.0, to a newer version of htmlunit-driver, that is 2.31.1.\n\npom.xml (excerpt): Build file\n\n(1)\n\norg.seleniumhq.selenium\nselenium-java\n3.14.0\n\norg.seleniumhq.selenium (2)\nhtmlunit-driver\n2.31.1\n\njunit\njunit\n4.7\n\n1\nPart of the underlying POM defining dependencies\n\n2\nDefinition of the dependency, causing the vulnerability finding; we use a newer version now\n\nOK, now we are done. We push the changes to GitHub, and our GitHub webhook directly triggers the workflow. This time the quality gate passes, so it\nlooks like our fixes did address the root causes and eliminated those with the configured threshold severity.\n\nFinally, after running through our entire workflow, that is made up of different pipelines, our inspected and quality assured container does successfully\nrun in our production runtime environment, that is on Oracle Cloud.\n\nCrisp, isn’t it?\n\nSummary\n\nThis closes our quick walkthrough of how to inject security related quality gates into a Jenkins based delivery pipeline.\nWe’ve discussed some concepts and how this can look like with sample tools.\nIn the center of our efforts, we used Jenkins, the swiss army knife of automation.\nWe enriched our ecosystem by integrating couple of platforms and tools, above all Twistlock.\nAfter this tasty appetizer you are ready to assess your own delivery pipelines,\nconcepts and tools, and to possibly invest even more attention to security.\n\nReferences\n\n'Agile ALM', Manning, 2011\n\n'DevOps for Developers', Apress, 2012\n\nDocker, the standard to develop and ship set of changes\n\nDocker images, shipping OpenJDK\n\nOracle Cloud Infrastructure, for containers\n\nAlpine Linux\n\nSonarQube, the language/platform agnostic Continuous Inspection tool\n\nTwistlock, the container security platform\n\nSources on GitHub\n\nASCII, commonly used standard to work on primitives, such as Docker (and their aggregations)\n\nCommon Vulnerabilities and Exposures\n\nHolistic pipelines, Live 15-minute Jenkins Demos, Part 1, on YouTube\n\nHolistic pipelines, Live 15-minute Jenkins Demos, Part 2, on YouTube\n\nDelivery Pipelines, with Jenkins 2, SonarQube, and Artifactory\n\nDelivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production","title":"The Silence of the Lambs: Inspecting binaries with Jenkins","tags":["devops","devsecops","security","vulnerabilities","compliance","twistlock"],"authors":[{"avatar":{"childImageSharp":null},"blog":"http://huettermann.net","github":"michaelhuettermann","html":"<div class=\"paragraph\">\n<p>Michael is expert in Continuous Delivery, DevOps and SCM/ALM supporting enterprises in implementing DevOps.\nMichael is Jenkins Ambassador.</p>\n</div>","id":"michaelhuettermann","irc":null,"linkedin":null,"name":"Michael Hüttermann","slug":"/blog/author/michaelhuettermann","twitter":"huettermann"}]}},{"node":{"date":"2018-10-10T00:00:00.000Z","id":"c142077a-cf17-5ac3-a33f-2658b51ec566","slug":"/blog/2018/10/10/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.146 and 2.138.2, that fix multiple security vulnerabilities.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes on upgrading Jenkins LTS, see our LTS upgrade guide.\n\nFurther improvements\n\nIn addition to the security fixes listed in the security advisory, we also applied multiple improvements that make future security vulnerabilities more difficult, or even impossible to exploit.\n\nOne such improvement concerns cross-site scripting vulnerabilities, and comes with a risk of regressions.\n\nJenkins uses a fork of Jelly for the vast majority of the views it renders.\nSince 2011, it includes a feature that lets view authors opt in or out of automatic escaping of variable values for rendering in HTML, and since 2016, the plugin build tooling requires that views explicitly specify whether to apply this automatic escaping.\nDetails are available in the developer documentation.\n\nUntil now, if views do not declare whether to automatically escape, they were rendered without automatic escaping, and developers were expected to explicitly escape every variable reference that was not supposed to contain markup.\nThis has resulted in a number of cross-site scripting (XSS) vulnerabilities, most recently SECURITY-1130 in Job Config History Plugin.\n\nFor that reason, we have decided to enable this automatic escaping by default if plugins do not specify a preference.\nThis can result in problems with some plugins if they need their output to remain unescaped.\nWe expect that those plugins will adapt pretty quickly to this change, as the fix is typically straightforward.\nWe track known affected plugins and their status on the Jenkins wiki.\n\nIn the mean time, users can set the system property org.kohsuke.stapler.jelly.CustomJellyContext.escapeByDefault to false to disable this additional protection.","title":"Important security updates for Jenkins","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/author/daniel-beck","twitter":null}]}},{"node":{"date":"2018-08-15T00:00:00.000Z","id":"09b0e766-f69d-5d93-bda5-3729f028d501","slug":"/blog/2018/08/15/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.138 and 2.121.3, that fix multiple security vulnerabilities.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes on upgrading Jenkins LTS, see our LTS upgrade guide.\n\nSubscribe to the jenkinsci-advisories mailing list to receive important notifications related to Jenkins security.","title":"Jenkins 2.121.3 and 2.138 security updates","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/author/daniel-beck","twitter":null}]}},{"node":{"date":"2018-07-18T00:00:00.000Z","id":"4f74ad43-7236-5f3c-bf1f-5c49dd133357","slug":"/blog/2018/07/18/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.133 and 2.121.2, that fix multiple security vulnerabilities.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes on upgrading Jenkins LTS, see our LTS upgrade guide.\n\nSubscribe to the jenkinsci-advisories mailing list to receive important notifications related to Jenkins security.","title":"Security updates for Jenkins core","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/author/daniel-beck","twitter":null}]}}]}},"pageContext":{"tag":"security","limit":8,"skip":16,"numPages":7,"currentPage":3}},
    "staticQueryHashes": ["3649515864"]}