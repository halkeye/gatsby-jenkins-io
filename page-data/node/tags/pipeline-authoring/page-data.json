{
    "componentChunkName": "component---src-templates-tag-blog-list-template-js",
    "path": "/node/tags/pipeline-authoring",
    "result": {"data":{"allBlog":{"edges":[{"node":{"date":"2019-05-09T00:00:00.000Z","id":"8e971fb0-7d4b-559d-a327-05b99fb4739e","slug":"/blog/2019/05/09/templating-engine/","strippedHtml":"Implementing DevSecOps practices at the enterprise scale is challenging. With multiple programming languages, automated testing frameworks, and security compliance tools being used by different applications within your organization, it becomes difficult to build and maintain pipelines for each team.\n\nMost pipelines are going to follow the same generic workflow regardless of which specific tech stack is employed by an application.  The Templating Engine Plugin (abbreviated as JTE for Jenkins Templating Engine) allows you to capture this efficiency by creating tool-agnostic, templated workflows to be reused by every team.\n\nAs technology consultants with clients in both the public and private sectors, at Booz Allen we found ourselves building DevSecOps pipelines from scratch for every new project.  Through developing the Jenkins Templating Engine, we’ve seen pipeline development decrease from months to days now that we can reuse tool integrations while bringing a new level of governance to Jenkins pipelines.\n\nPipeline Templating\n\nOrganizations benefit from letting application developers focus on what they do best: building applications. Supporting this means building a centralized DevOps team responsible for maintaining platform infrastructure and creating CI/CD pipelines utilized by development teams.\n\nWith the rise of microservice-based architectures, a centralized DevOps teams can support many different development teams simultaneously; all of whom may be leveraging different programming languages and automated testing tools.\n\nWhile the tools may differ between development teams, the workflow is often the same: unit test, static code analysis, build and publish an artifact, deploy it, and then perform different types of testing against the deployed application.\n\nThe Templating Engine Plugin allows you to remove the Jenkinsfile from each repository by defining a common workflow for teams to inherit.  Instead of an entire pipeline definition in each repository, teams supply a configuration file specifying which tools to use for the workflow.\n\nJTE in Action\n\nLet’s walk through a bare bones example to demonstrate the reusability of templates:\n\nExample Pipeline Template:\n\nunit_test()\nbuild()\nstatic_code_analysis()\n\nTemplates leverage Steps contributed by Libraries to outline a workflow teams must implement.  While a template does get executed just like any other Jenkinsfile (meaning that the standard scripted and declarative syntax is supported), the goal of a template should be to read like plain English and avoid any technical implementation.\n\nLeveraging templates in this way lets you separate the business logic (what should happen when) of your pipeline from the\ntechnical implementation (what’s actually going to happen).  The result of this is a CI/CD pipeline that’s proven to be\nsignificantly easier to manage when supporting multiple teams simultaneously.\n\nThe steps outlined by this template ( unit_test, build, and static_code_analysis) have been named generically on purpose. This way teams can specify different libraries to use while sharing the same pipeline.\n\nImplementing the Template\n\nImplementing a shareable pipeline with the Templating Engine requires a few key components:\n\nPipeline Template : Outline the workflow to be performed\n\nLibraries : Provide technical implementations of the steps of the workflow\n\nConfiguration Files : Specify which libraries to use and their configuration\n\nStep 1: Create a Pipeline Configuration Repository\n\nA Pipeline Configuration Repository is used to store common configurations and pipeline templates inherited by teams.\n\nThis example Pipeline Configuration Repository will later be configured as part of a Governance Tier : the mechanism in JTE that allows you to build hierarchical configurations representing your organization.\n\nA Governance Tier holds three things:\n\nPipeline Templates\n\nA list of Library Sources\n\nThe tier’s configuration file ( pipeline_config.groovy)\n\nThe pipeline templates and the configuration file for a Governance Tier are stored in the pipeline configuration repository.\n\nWhen configuring the Governance Tier in Jenkins, you will provide a source code management location for a repository that contains the above components as well as the base directory where these artifacts can be found.\n\nStep 2: Create the Pipeline Template\n\nNext, we’ll create a Jenkinsfile for the Governance Tier.  In JTE, the Jenkinsfile is the default pipeline template that an execution will use.\n\nJenkinsfile\n\nunit_test()\nbuild()\nstatic_code_analysis()\n\nStep 3: Create the Libraries\n\nThe Templating Engine Plugin has implemented a version of Jenkins Shared Libraries to enhance the reusability of libraries.  A library is a root directory within a source code repository that has been configured as a Library Source on a Governance Tier.\n\nIn our example, the pipeline template needs to perform unit testing, package an artifact, and run static code analysis.\n\nLet’s assume that we have some teams using gradle and some teams using maven to build and test their application but they will both use SonarQube to perform static code analysis.\n\nIn this scenario, we should create gradle, maven, and sonarqube libraries.\n\n|- gradle/\n  \\-- build.groovy\n  \\-- unit_test.groovy\n|- maven/\n  \\-- build.groovy\n  \\-- unit_test.groovy\n|- sonarqube/\n  \\-- static_code_analysis.groovy\n\nStep 4: Implement the Steps\n\nImplementing a library step is exactly the same as just writing regular global variables as part of the default Jenkins Shared Libraries.\n\nFor the purposes of this demonstration, we will just have each step print out the step name and contributing library.\n\ngradle/build.groovy\n\nvoid call(){\n    println \"gradle: build()\"\n}\n\nRead more about Library Development within JTE.\n\nStep 5: Create the Configuration Files\n\nThe configuration file for JTE is named pipeline_config.groovy.\n\nIn the Governance Tier we’ll create a configuration file specifying common configurations between the applications. In this case, both applications are using the sonarqube library:\n\npipeline_config.groovy\n\nlibraries{\n  merge = true // allow individual apps to contribute additional libraries\n  sonarqube\n}\n\nNext, we’ll create two more repositories representing the maven and gradle applications. Within those repositories all we’ll need is an application-specific pipeline_config.groovy file.\n\nThese repositories both contain an application pipeline_config.groovy configuration file.\n\nmaven app: pipeline_config.groovy\n\nlibraries{\n    maven\n}\n\ngradle app: pipeline_config.groovy\n\nlibraries{\n    gradle\n}\n\nStep 6: Configure the Governance Tier in Jenkins\n\nNow that we have a Pipeline Configuration Repository and a Library Source Repository, we can configure a Governance Tier in Jenkins:\n\nThis configuration shown in the image above can be found under Manage Jenkins >> Configure System\n\nThrough the Templating Engine, you can create a pipeline governance hierarchy matching your organization’s taxonomy by representing this structure via Folders in Jenkins.\n\nStep 7: Create a Multibranch Pipeline for Both Applications\n\nWhen creating Multibranch Pipeline Projects for each app, the Templating Engine plugin supplies a new Project Recognizer\ncalled Jenkins Templating Engine.  This sets the project to use the Templating Engine framework for all branches within the\nrepository.\n\nYou can also set the Jenkins Templating Engine project recognizer for a GitHub Organization project, enabling you to easily share the same pipeline across an entire Github Organization!\n\nStep 8: Run the Pipelines\n\nThat’s it!  Now, both applications will leverage the exact same pipeline template while having the flexibility to select which\ntools should be used during each phase of the workflow.\n\nBelow is sample output from the console log from both applications pipeline runs:\n\nGradle:\n\n[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-configuration\n[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-app-gradle.git\n[JTE] Loading Library sonarqube from git https://github.com/steven-terrana/example-jte-libraries.git\n[JTE] Loading Library gradle from git https://github.com/steven-terrana/example-jte-libraries.git\n...\n[JTE] Obtained Template Jenkinsfile from git https://github.com/steven-terrana/example-jte-configuration\n[JTE][Step - gradle/unit_test]\n[Pipeline] echo\ngradle: unit_test()\n[JTE][Step - gradle/build]\n[Pipeline] echo\ngradle: build()\n[JTE][Step - sonarqube/static_code_analysis]\n[Pipeline] echo\nsonarqube: static_code_analysis()\n[Pipeline] End of Pipeline\n\nMaven:\n\n[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-configuration\n[JTE] Obtained Template Configuration File pipeline_config.groovy from git https://github.com/steven-terrana/example-jte-app-maven.git\n[JTE] Loading Library sonarqube from git https://github.com/steven-terrana/example-jte-libraries.git\n[JTE] Loading Library maven from git https://github.com/steven-terrana/example-jte-libraries.git\n...\n[JTE] Obtained Template Jenkinsfile from git https://github.com/steven-terrana/example-jte-configuration\n[JTE][Step - maven/unit_test]\n[Pipeline] echo\nmaven: unit_test()\n[JTE][Step - maven/build]\n[Pipeline] echo\nmaven: build()\n[JTE][Step - sonarqube/static_code_analysis]\n[Pipeline] echo\nsonarqube: static_code_analysis()\n[Pipeline] End of Pipeline\n\nBenefits of the Templating Engine\n\nApply Organizational Governance\n\nLeveraging the Templating Engine Plugin will allow you to define enterprise-scale, approved\nworkflows that can be used by teams regardless of what tools are being used.  This top-down\napproach makes scaling and enforcing DevSecOps principles significantly easier within your organization.\n\nOptimize Code Reuse\n\nThere’s really no need for every team in your organization to figure out how to do the same things over\nand over again.  At Booz Allen, we have seen pipeline development time decrease from months to days as\nwe have continuously reused and expanded upon our Templating Engine library portfolio as part of our Solutions\nDelivery Platform.\n\nSimplify Pipeline Maintainability\n\nOften DevOps engineers find themselves building and supporting pipelines for multiple development teams at\nthe same time.  By decoupling the workflow from the technical implementation and consolidating the pipeline\ndefinition to a centralized location, the Templating Engine plugin allows DevOps engineers to scale much faster.\n\nGet Involved!\n\nThe Templating Engine Plugin has been open sourced and made available in the Jenkins Update Center.\n\nWe always appreciate feedback and contributions! If you have an interesting use case or would like to ask questions, try the templating-engine-plugin on Gitter.\n\nAdvanced Features\n\nConfiguration File Conditional Inheritance\n\nExternalize Library Configurations\n\nAspect Oriented LifeCycle Hooks\n\nMultiple Pipeline Templates\n\nDefault Step Implementation\n\nConfiguration File DSL Sandboxing\n\nMore Resources\n\nFor this Demonstration\n\nPipeline Configuration Repository\n\nSample Libraries\n\nSample Maven Repository\n\nSample Gradle Repository\n\nAdditional Resources\n\nTemplating Engine Documentation\n\nSource Code\n\nBooz Allen’s SDP Pipeline Libraries\n\nBooz Allen Hamilton","title":"Introducing the Jenkins Templating Engine!","tags":["general","pipeline","plugin","pipeline-authoring"],"authors":[{"avatar":null,"blog":null,"github":"steven-terrana","html":"","id":"steven-terrana","irc":null,"linkedin":null,"name":"Steven Terrana","slug":"blog/author/steven-terrana","twitter":null}]}}]}},"pageContext":{"tag":"pipeline-authoring","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}