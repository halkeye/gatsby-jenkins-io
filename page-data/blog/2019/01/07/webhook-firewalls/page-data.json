{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2019/01/07/webhook-firewalls/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>In this post I wanted to show how you can run Jenkins behind a firewall (which could be a corporate firewall, a NAT’ed network like you have at home) but still receive webhooks in real time from GitHub.com. You can generalise this to other services too - such as BitBucket or DockerHub, or anything really that emits webhooks, but the instructions will be for GitHub projects hosted on github.com.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"what-are-webhooks\"><a class=\"anchor\" href=\"#what-are-webhooks\"></a>What are webhooks</h3>\n<div class=\"paragraph\">\n<p>Just a very quick refresher on what webhooks are: Messages (often JSON, but not always) typically posted by HTTP(S) from a server to a client that is listening for events.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/webhooks.png\" alt=\"webhook diagram\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>The events flow left to right, Jenkins sits there happily listing on paths like <code>/github-webhook/</code> or <code>/dockerhub-webhook/</code> etc for some HTTP request to tell it to wake up and do some work.</p>\n</div>\n<div class=\"paragraph\">\n<p>GitHub/BitBucket may be reporting a new commit or PR, or DockerHub reporting an upstream image has changed. What all these things have in common is that they push to Jenkins, and expect to be able to push to it (ie that Jenkins is visible to them). This works great when the network is open - say GitHub Enterprise, or Jenkins is listening on the web.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"not-on-the-web\"><a class=\"anchor\" href=\"#not-on-the-web\"></a>Not on the web</h3>\n<div class=\"paragraph\">\n<p>The trick is when something gets in the middle, say a firewall:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/firewalls.png\" alt=\"firewall diagram\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>(<em>As is industry standard, all firewalls have to be a wall on fire. Please don’t somehow set bricks on fire in your organisation</em>)</p>\n</div>\n<div class=\"paragraph\">\n<p>This is just the same when you fire up Jenkins on your laptop, and want to receive webhooks from github.com (a legitimate thing, perhaps to test out your setup, perhaps to run builds for iOS on a mac, or some corner of a network that is not exposed to the web). Unless your laptop is addressable to the whole web that is (not likely), or your network is configured just right, the webhooks won’t be able to flow.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is fine - we can fall back to polling for changes. Except this is terrible. You burn through API quotas, and you don’t get changes in real time, and really no one is happy.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"some-problems-are-opportunities\"><a class=\"anchor\" href=\"#some-problems-are-opportunities\"></a>Some problems are opportunities</h3>\n<div class=\"paragraph\">\n<p>We can both solve this problem, but also, view this is an opportunity. Having things not addressable on the web, or locked down in some default way is a feature, not a bug. You massively reduce your attack surface, and can have defence in depth:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/exposed.png\" alt=\"exposed on web\"></span></p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"a-webhook-forwarding-service\"><a class=\"anchor\" href=\"#a-webhook-forwarding-service\"></a>A Webhook forwarding service</h3>\n<div class=\"paragraph\">\n<p>Enter the memorably named <a href=\"https://smee.io/\">Smee</a>. This is an <a href=\"https://github.com/probot/smee\">OSS project</a> provided by GitHub and also helpfully hosted as a service by GitHub. This can capture and forward webhooks for you. I’ll try to explain it with a diagram:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/forwarding.png\" alt=\"forwarding\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>GitHub pushes an event (via HTTPS/json in this case) to Smee.io (the funny thing with circles, which is on the public web and accessible from GitHub.com) - and Jenkins in turn subscribes to Smee with an outgoing connection from a client. Note the direction of the arrows: Jenkins only makes an outbound connection.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is the important point: this will work as long as the firewall is one way (like a NAT typically is, and many networks). If the Jenkins side can’t connect to anything on the outside world - well, this won’t help with that of course (but that is not often the case).</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"setting-it-up\"><a class=\"anchor\" href=\"#setting-it-up\"></a>Setting it up</h3>\n<div class=\"paragraph\">\n<p>Step 1: Firstly - go to <a href=\"https://smee.io/\" class=\"bare\">https://smee.io/</a> and click “Start a new channel”:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/smee.png\" alt=\"smee website\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>This will give you a unique URL (which you should copy for later use):</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/config1.png\" alt=\"smee config\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Next you should install the smee client next to where you have the Jenkins server running:</p>\n</div>\n<div class=\"paragraph\">\n<p><code>npm install --global smee-client</code></p>\n</div>\n<div class=\"paragraph\">\n<p>(This will make the smee client/command available to receive and forward webhooks).</p>\n</div>\n<div class=\"paragraph\">\n<p>Now start the smee client and point it to your Jenkins server. In this case I have it running on port 8080 (the default if you fire it up on your laptop, change both the port and the smee URL as needed):</p>\n</div>\n<div class=\"paragraph\">\n<p><code>smee --url <a href=\"https://smee.io/GSm1B40sRfBvSjYS\" class=\"bare\">https://smee.io/GSm1B40sRfBvSjYS</a> --path /github-webhook/ --port 8080</code></p>\n</div>\n<div class=\"paragraph\">\n<p>This says to connect to the smee service, and forward webhooks to /github-webhook/ (that trailing slash is important, don’t miss it). Once this is running, you will see it log that it is connected and forwarding webhooks. Leave this command running for as long as you want to receive webhooks.</p>\n</div>\n<div class=\"paragraph\">\n<p>Next, you need to configure a pipeline that makes use of github. In this case I set up one from scratch. You can skip this if you already have a pipeline setup:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/newpipeline.png\" alt=\"new pipeline\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>I then chose “GitHub” as the where the code is:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/choice.png\" alt=\"choose github\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Then choose your repository. This will set things up ready to receive webhooks from GitHub. (also if you have an existing pipeline setup, and it is using GitHub as the SCM source, that is also fine).</p>\n</div>\n<div class=\"paragraph\">\n<p>The final step is to tell GitHub to post webhook events for that repository (or organization, you can do that too) to Smee (which ultimately means Jenkins will receive them).</p>\n</div>\n<div class=\"paragraph\">\n<p>Go to the settings tab for your GitHub repository, and then click “add webhook”:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/addwebhook.png\" alt=\"add webhook\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Next, configure the webhook:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Paste in the “smee” URL you copied from the step above.</p>\n</li>\n<li>\n<p>Choose <code>application/json</code> as the content type</p>\n</li>\n<li>\n<p>Tell it to <code>send everything</code> (you can pick and choose what events, but I just did that as simpler).</p>\n</li>\n<li>\n<p>Press Add Webhook (or update)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>It should look something like this:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/config2.png\" alt=\"config webhook\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>OK - webhooks should be flowing now. You can make a change to your repository, and check that a build starts soon after:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2019-01-07-webhook-firewalls/running.png\" alt=\"running pipeline\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Good luck!</p>\n</div>\n</div>","id":"4187a71c-adb8-54ce-90c9-c412101f2f56","title":"Triggering builds with webhooks behind a secure firewall","date":"2019-01-07T00:00:00.000Z","slug":"/blog/2019/01/07/webhook-firewalls/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/19e71/michaelneale.jpg","srcSet":"/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/77b35/michaelneale.jpg 32w,\n/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/d4a57/michaelneale.jpg 64w,\n/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/19e71/michaelneale.jpg 128w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/ef6ff/michaelneale.webp 32w,\n/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/8257c/michaelneale.webp 64w,\n/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/6766a/michaelneale.webp 128w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}},"publicURL":"/gatsby-jenkins-io/static/75c8520897a1db139d524965f5bb7ccc/michaelneale.jpg"},"blog":null,"github":"michaelneale","html":"<div class=\"paragraph\">\n<p>Michael is a CD enthusiast with a interest in User Experience.\nHe is a co-founder of CloudBees and a long time OSS developer, and can often be found\nlurking around the jenkins-dev mailing list or #jenkins on irc (same nick as twitter name).\nBefore CloudBees he worked at Red Hat.</p>\n</div>","id":"michaelneale","irc":null,"linkedin":null,"name":"Michael Neale","slug":"/blog/authors/michaelneale/","twitter":"michaelneale"}]}},"pageContext":{"id":"4187a71c-adb8-54ce-90c9-c412101f2f56"}},
    "staticQueryHashes": ["1271460761","3649515864"]}