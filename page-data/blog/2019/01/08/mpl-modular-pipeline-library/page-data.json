{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2019/01/08/mpl-modular-pipeline-library/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>Despite speeding up development with deployment automation, one of our clients\nwas experiencing slow time-to-market due to a lack of collaboration in DevOps.\nWhile they had invested in DevOps, every production pipeline was set up\nindividually, forcing teams to remake the wheel for each project. Making matters\nworse, there was no cross-team collaboration, so any bug in the platform was\npresent in each new pipeline. Many of our clients have similar issues, so we\ndecided that we should develop a common tool which would both help current\nclients, and be adaptable for use in the future. While the most obvious option\nwas standardizing the CI/CD platform with a common framework, this led to a\nmonolithic structure, which was inflexible and ultimately unworkable. Since each\nteam needed to work on their own pipelines, we developed a solution that would\nstore each reusable part of the DevOps pipeline for later use: a Jenkins-powered\nmodular pipeline library.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"solution-a-modular-pipeline-library\"><a class=\"anchor\" href=\"#solution-a-modular-pipeline-library\"></a>Solution: a modular pipeline library</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The modular pipeline library (<a href=\"https://github.com/griddynamics/mpl\">MPL</a>) we\ncreated is a highly-flexible shared library for a Jenkins Pipeline that enables\neasy sharing of best practices across the entire company. It has a clear modular\nstructure, an advanced testing framework, multi-level nesting, a pipeline\nconfiguration system, improved error handling, and many other useful components.</p>\n</div>\n<div class=\"paragraph\">\n<p>We will take a look under the hood and explain how our solution works in several\nparts:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Explore the technologies and tools we used to build the MPL</p>\n</li>\n<li>\n<p>Review the MPL, and illustrate why it’s effective</p>\n</li>\n<li>\n<p>Follow a step-by-step guide to operate the MPL on a sample pipeline</p>\n</li>\n<li>\n<p>Dive into some of the more important components of the solution, such as the test framework and nested libraries</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>So now let’s jump right into an explanation of the crucial features we used to\nbuild our solution.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"building-the-mpl-with-shared-libraries-and-jenkins-pipelines\"><a class=\"anchor\" href=\"#building-the-mpl-with-shared-libraries-and-jenkins-pipelines\"></a>Building the MPL with shared libraries and Jenkins pipelines</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Jenkins, our main automation platform, recently received some updates to\n<a href=\"/doc/book/pipeline/#overview\">Jenkins Pipeline</a>. These updates allow us to\ncreate one <a href=\"/doc/pipeline/tour/hello-world/\">Jenkinsfile</a> that\ndescribes the entire pipeline, and the steps that need to be executed with a\nseries of self-explanatory scripts. This increases the visibility of CI/CD\nautomation processes for end users, and improves supportability by DevOps teams.</p>\n</div>\n<div class=\"paragraph\">\n<p>However, there’s a large issue with Pipeline: it’s hard to support multiple\nJenkinsfiles (and therefore multiple projects) with unique pipelines. We need to\nstore the common logic somewhere, which is where\n<a href=\"/doc/book/pipeline/shared-libraries/#extending-with-shared-libraries\">Jenkins Shared Libraries</a>\ncome in. They are included in the Jenkinsfile, and allow the use of prepared\ninterfaces to simplify automation and store common pieces.</p>\n</div>\n<div class=\"paragraph\">\n<p>While shared libraries allow you to store logic and manipulate Jenkins, they\ndon’t provide a good way to utilize all the common information. Therefore, the\nMPL optimizes the pipeline and shared libraries by allowing users to create\neasy-to-follow descriptions for processes, which are then stored for later use\nby other teams.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-mpl-works-to-create-collaborative-devops-processes-across-teams\"><a class=\"anchor\" href=\"#the-mpl-works-to-create-collaborative-devops-processes-across-teams\"></a>The MPL works to create collaborative DevOps processes across teams</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>With the MPL, we are now able to collaborate and share our DevOps practices\nacross teams, easily adopt existing pipelines for specific projects, and debug\nand test features before we actually integrate them into the library. Each team\ncan create a nested library, add a number of pipelines and modules inside, and\nuse it with pipeline automation to create great visibility of the processes for\nthe end user. The MPL can also work on any project to prepare a Jenkinsfile, and\nmanage it as flexibly as the project team wants.</p>\n</div>\n<div class=\"paragraph\">\n<p>At its core, the MPL provides a simple way to:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Separate pipelines and steps by introducing modules</p>\n</li>\n<li>\n<p>Describe steps in the modules with an easy configuration interface</p>\n</li>\n<li>\n<p>Test the described modules and share the results with other pipelines and projects</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>There are a lot of other features in the MPL, but it&#8217;s essentially a platform to\nsolve general DevOps collaboration issues. To simplify development and manual\ntesting, the MPL provides modules overriding and an inheritance model, allowing\nusers to test specific fixes in the project without affecting anything else. In\nJenkins, a module is a file with scripted steps and logic to reach a simple goal\n(build an artifact, run tests, create an image, etc.). These modules are\ncombined in the pipeline stages, and are easily readable for anyone who knows\nthe Jenkins Pipeline syntax.</p>\n</div>\n<div class=\"paragraph\">\n<p>The MPL allows users to use the core features of the library (structure,\nmodules, pipelines) and create nested libraries for specific DevOps team needs.\nA DevOps team can prepare complete pipelines with any custom logic and use it\nfor their projects. They can also override and inherit the core MPL modules in a\nnumber of ways, or prepare custom modules which are easy to share with other\nteams. Check out the infographic below to see how modules fit in:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig01-layers-of-the-mpl.png\" alt=\"Fig 1. Layers of the MPL\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also specify certain pipeline required poststeps in a module. For\nexample, a dynamic deployment module creates the test environment, which needs\nto be destroyed when the pipeline ends. To take a closer look at the MPL calling\nprocess, check out the infographic below:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig02-the-mpl-process.png\" alt=\"Fig 2. The MPL process\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This infographic shows how calls are executed in the MPL. First, you need a job\non your Jenkins, which will call a Jenkinsfile (for example, when the source\ncode is changed), after which the Jenkinsfile will call a pipeline. The pipeline\ncould be described on the MPL side, in the pipeline script in the job, in the\nnested library, or in the project Jenkinsfile. Finally, the stages of the\npipeline will call the modules, and these modules will use features, which could\nbe groovy logic, pipeline steps, or steps in the shared libraries.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now that we’ve done an overview of the solution, let’s take a look at a simple\npipeline execution to see how the MPL works in action.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"an-example-of-a-pipeline-execution-in-the-mpl\"><a class=\"anchor\" href=\"#an-example-of-a-pipeline-execution-in-the-mpl\"></a>An example of a pipeline execution in the MPL</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>For example, let’s say you have a common Java Maven project. You are creating a\nJenkinsfile in the repo, and want to use the default pipeline prepared by your\nDevOps team. The MPL already has a simple pipeline: the core <code>MPLPipeline</code>. It’s\na really simple pipeline, but it&#8217;s a good start for anyone who wants to try the\nMPL. Let’s look at a simple Jenkinsfile:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">@Library('mpl') _\nMPLPipeline {}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This Jenkinsfile contains a single line to load the MPL, and another line to run\nthe pipeline. Most of the shared libraries implement an interface like this,\ncalling one step and providing some parameters. <code>MPLPipeline</code> is merely a custom\nPipeline step, as it lies in the <code>vars</code> directory, and its structure is very\nsimple, following these steps:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>Initialize the MPL</strong><br>\nThe MPL uses the <code>MPLManager</code> singleton object to control the pipeline</p>\n</li>\n<li>\n<p><strong>Merge configuration with default and store it</strong><br>\nA default configuration needed to specify stages and predefine some useful configs</p>\n</li>\n<li>\n<p><strong>Define a declarative pipeline with 4 stages and poststeps:</strong></p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Checkout - Getting the project sources</p>\n</li>\n<li>\n<p>Build - Compiling, validation of static, unit tests</p>\n</li>\n<li>\n<p>Deploy - Uploading artifacts to the dynamic environment and running the app</p>\n</li>\n<li>\n<p>Test - Checking integration with other components</p>\n</li>\n<li>\n<p>Poststeps - Cleaning dynamic environment, sending notifications, etc.</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Running the defined pipeline</strong><br>\nThis is where the MPL starts to work its magic and actually runs</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Stages of the main MPL usually have just one step, the <a href=\"https://github.com/griddynamics/mpl/blob/master/vars/MPLModule.groovy#L29\"><code>MPLModule</code></a>.\nThis step contains the core functionality of the MPL: executing the modules\nwhich contain the pipeline logic. You can find default modules in the MPL\nrepository, which are placed in <a href=\"https://github.com/griddynamics/mpl/tree/master/resources/com/griddynamics/devops/mpl/modules\">resources/com/griddynamics/devops/mpl/modules</a>.\nSome of the folders include: Checkout, Build, Deploy, and Test, and in each of\nthem we can find Groovy files with the actual logic for the stages. This\ninfographic is a good example of a simplified <a href=\"https://github.com/griddynamics/mpl/\">MPL repository</a>\nstructure:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig03-a-simplified-mpl-repository-structure.png\" alt=\"Fig 3. A simplified MPL repository structure\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When the Checkout stage starts, <code>MPLModule</code> loads the module by name (by default\na stage name), and runs the <a href=\"https://github.com/griddynamics/mpl/blob/master/resources/com/griddynamics/devops/mpl/modules/Checkout/Checkout.groovy\">Checkout/Checkout.groovy</a>\nlogic:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">if( CFG.'git.url' )\n  MPLModule('Git Checkout', CFG)\nelse\n  MPLModule('Default Checkout', CFG)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the configuration contains the <code>git.url</code> option, it will load a <code>Git Checkout</code>\nmodule; otherwise, it will run the <code>Default Checkout</code> module. All the called\nmodules use the same configuration as the parent module, which is why CFG was\npassed to the <code>MPLModule</code> call. In this case, we have no specific configuration,\nso it will run the\n<a href=\"https://github.com/griddynamics/mpl/blob/master/resources/com/griddynamics/devops/mpl/modules/Checkout/DefaultCheckout.groovy\">Checkout/DefaultCheckout.groovy</a>\nlogic. The space in the name is a separator to place the module into a specific\nfolder.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the <code>Default Checkout</code> module, there is just one line with <code>checkout scm</code>\nexecution, which clones the repository specified in the Jenkins job. That’s all\nthe Checkout stage does, as the MPL functionality is excessive for such a small\nstage, and we only need to talk about it here to show how the MPL works in\nmodules.</p>\n</div>\n<div class=\"paragraph\">\n<p>The same process applies to the Build stage, as the pipeline runs the\n<a href=\"https://github.com/griddynamics/mpl/blob/master/resources/com/griddynamics/devops/mpl/modules/Build/MavenBuild.groovy\">Maven Build</a>\nmodule:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">withEnv([\"PATH+MAVEN=${tool(CFG.'maven.tool_version' ?: 'Maven 3')}/bin\"]) {\n  def settings = CFG.'maven.settings_path' ? \"-s '${CFG.'maven.settings_path'}'\" : ''\n  sh \"\"\"mvn -B ${settings} -DargLine='-Xmx1024m -XX:MaxPermSize=1024m' clean install\"\"\"\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This stage is a little bit more complicated, but the action is simple: we take\nthe tool with the default name <code>Maven 3</code>, and use it to run <code>mvn clean install</code>.\nThe modules are scripted pipelines, so you can do the same steps usually\navailable in the Jenkins Pipeline. The files don’t need any specific and\ncomplicated syntax, just a plain file with steps and <code>CFG</code> as a predefined\nvariable with a stage configuration. The MPL modules inherited the sandbox from\nthe parent, so your scripts will be safe and survive the Jenkins restart, just\nlike a plain Jenkins pipeline.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the Deploy folder, we find the sample structure of the <code>Openshift Deploy</code>\nmodule. Its main purpose here is to show how to use poststep definitions in the\nmodules:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">MPLPostStep('always') {\n  echo \"OpenShift Deploy Decommission poststep\"\n}\necho 'Executing Openshift Deploy process'</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>First, we define the <code>always</code> poststep. It is stored in the <code>MPLManager</code>, and is\ncalled when poststeps are executed. We can call <code>MPLPostStep</code> with <code>always</code> as\nmany times as we want: all the poststeps will be stored and executed in FILO\norder. Therefore, we can store poststep logic for actions that need to be done,\nand then undone, in the same module, such as the decommission of the dynamic\nenvironment. This ensures that the actions will be executed when the pipeline\nis complete.</p>\n</div>\n<div class=\"paragraph\">\n<p>After the deploy stage, the pipeline executes the Test stage, but nothing too\ninteresting happens there. However, there is an aspect of testing which is very\nimportant, and that’s the testing framework of the MPL itself.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"testing-of-the-mpl\"><a class=\"anchor\" href=\"#testing-of-the-mpl\"></a>Testing of the MPL</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The testing framework of the MPL is based on the\n<a href=\"https://github.com/jenkinsci/JenkinsPipelineUnit\">JenkinsPipelineUnit</a>\nfrom LesFurets, with the one small difference being its ability to test the MPL\nmodules. Testing the whole pipeline doesn’t work, as pipelines can be really\ncomplicated, and writing tests for such monsters is a Sisyphean task. It is much\neasier to test a black box with a small amount of steps, ensuring that this\nparticular task is working correctly.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the MPL, you can find <code>Build</code> module testing examples: all the tests are\nstored in the\n<a href=\"https://github.com/griddynamics/mpl/tree/master/test/groovy/com/griddynamics/devops/mpl/modules\">test/groovy/com/griddynamics/devops/mpl/modules</a>\ndirectory, and you can find the\n<a href=\"https://github.com/griddynamics/mpl/blob/master/test/groovy/com/griddynamics/devops/mpl/modules/Build/BuildTest.groovy\">Build/BuildTest.groovy</a>\nfile with a number of test cases there. Tests are executed during the MPL build\nprocess, allowing users to see traces like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">Loading shared library mpl with version snapshot\n  MPLModule.call(Build, {maven={tool_version=Maven 2}})\n    Build.run()\n      Build.MPLModule(Maven Build, {maven.tool_version=Maven 2})\n        MavenBuild.run()\n          MavenBuild.tool(Maven 2)\n          MavenBuild.withEnv([PATH+MAVEN=Maven 2_HOME/bin], groovy.lang.Closure)\n            MavenBuild.sh(mvn -B  -DargLine='-Xmx1024m -XX:MaxPermSize=1024m' clean install)\n      Build.fileExists(openshift)</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The test runs the <code>MPLModule</code> with custom configuration and mocked steps to\ncheck that, during execution, the tool was changed to <code>Maven 2</code> according to the\nprovided configuration. We cover all test cases with such tests, ensuring that\nthe modules are working as expected, and that the pipeline will work properly.\nYou can test the whole pipeline if you want, but testing by modules is just an\nadditional way to simplify the testing process.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now that we’ve looked at how to test the MPL modules, it’s time to look at one\nof the key features of the MPL, which is nested libraries.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-benefits-of-nested-libraries\"><a class=\"anchor\" href=\"#the-benefits-of-nested-libraries\"></a>The benefits of nested libraries</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When working with a large company, supporting one big library makes no sense.\nEach department requires multiple configuration options and tuning for a\nsomewhat standard pipeline, which creates extra work. The MPL solves such\nproblems by introducing nested libraries. This infographic displays how a nested\nlibrary compares to just using the main library:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig04-ways-to-use-the-mpl.png\" alt=\"Fig 4. Ways to use the MPL\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>A nested library is the same as a shared library that imports the MPL and uses\nits functionality, modules, and pipelines. Also, it allows the separation of\nsome team-related logic from the company common logic. Here is the structure of\nthe MPL with nested libraries:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig05-example-of-a-companys-libraries-tree-structure.png\" alt=\"Fig 5. Example of company&#8217;s libraries tree structure\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can import the MPL in the overridden pipeline, specify the path of some\nadditional modules, override module logic, and use Jenkins power moves: there\nare no limitations. When another team needs your unique module, you can just\ncreate a change request to the basic company MPL repo, and share your functional\nmodule with the others.</p>\n</div>\n<div class=\"paragraph\">\n<p>With nested libraries, it’s possible to debug and modify MPL-provided steps\n(<code>MPLModule</code> for example) and pipelines. This is because nested libraries can\noverride low-level functionalities of the MPL or the Jenkins Pipeline. There are\nno limitations to what you can or can’t change, as these overrides only affect\nyour own pipeline. This enables experimentation to be done, and then discussed\nwith other teams to see if it will work in other nested libraries as well.</p>\n</div>\n<div class=\"paragraph\">\n<p>There are also no limits to the number of nesting levels created, but we\nrecommend using just two (MPL and nested), because additional levels make\nconfiguration and testing of the nested libraries on lower levels very\ncomplicated.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-power-of-module-overriding\"><a class=\"anchor\" href=\"#the-power-of-module-overriding\"></a>The power of module overriding</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Further into the nested libraries or project-side modules, it’s possible to\nstore a module with the same name as one in the upper-level library. This is a\ngood way to override the logic - you can just replace Build/Build.groovy with\nyour own - as the functional module will be executed instead of the upper-level\nmodule. For example, this infographic shows module overriding:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig06-mpl-modules-overriding.png\" alt=\"Fig 6. MPL modules overriding\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Even better, one of the strengths of the MPL is that you still can use the\nupper-level module! The MPL has mechanisms to prevent loops, so the same module\ncan’t be executed in the same executing branch again. However, you can easily\ncall the original module a name from another module to use the upper-level\nlogic.</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2019-01-08-mpl/fig07-petclinic-selenium-example-pipeline-structure.png\" alt=\"Fig 7. Petclinic-Selenium example pipeline structure\" width=\"800\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The Petclinic-Selenium example above uses the default <code>MPLPipeline</code> (you can\nfind it on the <a href=\"https://github.com/griddynamics/mpl/wiki\">MPL Wiki-page</a>), and\ncontains project-side modules in a <code>.jenkins</code> directory. These modules will be\ncalled before the library modules. For example, the <code>Checkout</code> module is not\nplaced on the project side, so it will be called from the MPL, but the <code>Build</code>\nmodule exists in a <code>.jenkins</code> directory on the project side, and it will be\ncalled:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">MPLPostStep('always') {\n  junit 'target/surefire-reports/*.xml'\n}\n\nMPLModule('Build', CFG)\n\nif( fileExists('Dockerfile') ) {\n  MPLModule('Docker Build', CFG)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As you can see, the <code>Build</code> module from the project registers the poststep,\ncalls the original <code>Build</code> module from the MPL, and then calls the additional\n<code>Docker Build</code> module. The following stages of the pipeline are more\ncomplicated, but all module overriding essentially works like this. Some\nprojects can be tricky, and need some small tunings for the existing modules.\nHowever, you can easily implement those changes on the project level, and think\nabout how to move the functionality to the nested library or MPL later.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"conclusion-what-the-mpl-brings-to-devops\"><a class=\"anchor\" href=\"#conclusion-what-the-mpl-brings-to-devops\"></a>Conclusion: what the MPL brings to DevOps</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Many DevOps teams and companies work with bloated, restrictive, and buggy CI/CD\nautomation platforms. These increase the learning curve for users, cause teams\nto work slower, and raise production costs. DevOps teams frequently run into\nsimilar issues on different projects, but a lack of collaboration means that\nthey have to be individually fixed each time.</p>\n</div>\n<div class=\"paragraph\">\n<p>However, with the MPL, DevOps teams have a shared, simple, and flexible CI/CD\nplatform to improve user support, collaboration, and overall project source code\nto the production process. By utilizing the MPL, your company can find an\nautomation consensus, reach cross-company collaboration goals, and reuse the\nbest practices from a large community, all with open source tools. If you’re\ninterested in building an MPL, please contact us to learn more!</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"additional-resources\"><a class=\"anchor\" href=\"#additional-resources\"></a>Additional resources</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"/doc/book/pipeline/#overview\">Jenkins Pipeline Engine</a></p>\n</li>\n<li>\n<p><a href=\"/doc/book/pipeline/shared-libraries/#extending-with-shared-libraries\">Jenkins Shared Libraries</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/griddynamics/mpl\">MPL GitHub repository</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Overview &amp; demo videos:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://youtu.be/02zCNJ20AC0\">Introduction</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/CXghkwmsoXY\">Overview</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/knXX18E-W_s\">Demo of the MPL Build</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/D72vnIBxQYE\">Demo of the Nested Library</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/Gq8RYlZjds0\">Demo of the Petclinic Pipeline</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>","id":"058588ed-0d18-5d03-bd6b-e2e62be7093b","title":"MPL - Modular Pipeline Library","date":"2019-01-08T00:00:00.000Z","slug":"/blog/2019/01/08/mpl-modular-pipeline-library/","authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8d8d8","images":{"fallback":{"src":"/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/bf8e1/sparshev.png","srcSet":"/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/914ee/sparshev.png 32w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/1c9ce/sparshev.png 64w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/bf8e1/sparshev.png 128w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/acb7c/sparshev.png 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/ef6ff/sparshev.webp 32w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/8257c/sparshev.webp 64w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/6766a/sparshev.webp 128w,\n/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/22bfc/sparshev.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}},"publicURL":"/gatsby-jenkins-io/static/47da77b67c60ffe2efee543d5593025e/sparshev.png"},"blog":"https://www.state-of-the-art.io/","github":"sparshev","html":"<div class=\"paragraph\">\n<p>Sergei is a DevOps engineer and using Jenkins as a main automation tool since 2011.\nWants to automate everything to make sure that there no more room for boring tasks.</p>\n</div>","id":"sparshev","irc":null,"linkedin":null,"name":"Sergei Parshev","slug":"/blog/authors/sparshev/","twitter":null}]}},"pageContext":{"id":"058588ed-0d18-5d03-bd6b-e2e62be7093b"}},
    "staticQueryHashes": ["1271460761","3649515864"]}