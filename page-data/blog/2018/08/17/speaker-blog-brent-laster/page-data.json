{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/08/17/speaker-blog-brent-laster/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p><span class=\"image right\"><a class=\"image\" href=\"https://www.cloudbees.com/devops-world\"><img src=\"/images/conferences/devops-world-2018.jpg\" alt=\"DevOps World | Jenkins World 2018\"></a></span></p>\n</div>\n<div class=\"paragraph\">\n<p>More and more today, continuous delivery (CD) pipelines are making use of containers.\nIn many implementations, the primary workflow/orchestration tool for CD pipelines is Jenkins.\nAnd the primary container orchestration tool is Docker.\nTogether these two applications provide a powerful, yet simple to understand and use, model for leveraging containers in your CD pipeline.</p>\n</div>\n<div class=\"paragraph\">\n<p>When creating a pipeline script in Jenkins, there are multiple ways to incorporate Docker into your CD pipeline.\nThey include:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Manually running a predefined Docker image as a separate Jenkins agent</p>\n</li>\n<li>\n<p>Automatically provisioning a Docker image, when needed, as a part of a “cloud” configuration</p>\n</li>\n<li>\n<p>Referencing a “docker” global variable that can be invoked via the Jenkins DSL</p>\n</li>\n<li>\n<p>Calling the Docker executable directly via a shell call in the Jenkins DSL</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>For this article, we’ll focus on the third item in this list given that it provides the most flexibility and convenience for Docker use in the pipeline.\nMore details on the other three can be found in the upcoming “Continuous Delivery and Containerization” workshop at Jenkins World/DevOps World 2018.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, we’ll provide some background on a couple of terms for those who may not be familiar with Jenkins 2.\nIf you already are familiar with it, feel free to skip ahead to the Global Variables section.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"background\"><a class=\"anchor\" href=\"#background\"></a>Background</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When we talk about Jenkins here, we’re referring to “Jenkins 2” - a name we use to generally refer to the 2.0 and beyond versions of Jenkins.\nJenkins 2 offers a powerful evolution of Jenkins over prior versions.\nIn particular, it provides full integration for “pipeline-as-code” (PAC).\nPAC refers to being able to write your pipeline in a scripting language, much like source code for any program.\nThe code you write becomes the program that defines your pipeline.\nIt is also the code that gets executed when your pipeline is initiated.\nListing 1 shows a simple example pipeline.\nNotice that this is very different from the classic way of creating pipelines in Jenkins.\nHere you are writing code - rather than the more traditional approaches, such as filling in web forms to configure a Freestyle job.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">// Scripted Pipeline //\nnode('worker') {\n    stage('Source') { // Get code\n        // Get code from our git repository\n        git 'git@diyvb2:/home/git/repositories/workshop.git'\n    }\n    stage('Compile') { // Compile and do unit testing\n        // Run gradle to execute compile and unit testing\n        sh \"gradle clean compileJava test\"\n    }\n}\n// Declarative //</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Listing 1: Example Jenkins 2 pipeline</p>\n</div>\n<div class=\"paragraph\">\n<p>The language that we write the Jenkins pipeline code in is a Domain-Specific Language (DSL).\nYou can think of it as the “programming language” for Jenkins pipelines.\nThere are two variants of it.\nThe style we saw in figure 1 is called “scripted syntax”.\nIt is a mixture of elements from the Groovy programming language and special Jenkins “steps”.\nThe Jenkins steps are provided by the plugins that are installed in the current system.\nA built-in tool called the Snippet Generator provides a wizard interface to allow users to pick the step and options they want.\nThen, the user can click on a button to have Jenkins automatically generate the correct DSL code in the large text box (figure 1).\nThe DSL code can be copied from there and pasted into the pipeline script.</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure1.png\" alt=\"The Snippet Generator\" width=\"800\">\n</div>\n<div class=\"title\">Figure 1. The Snippet Generator</div>\n</div>\n<div class=\"paragraph\">\n<p>A second type of syntax is called “declarative syntax.”  We won’t go into detail on it here.\nBut it is a much more structured syntax that focuses on having users declare what they want in a pipeline, rather than writing the logic to make it happen.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"global-variables\"><a class=\"anchor\" href=\"#global-variables\"></a>Global Variables</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In addition to the steps that are provided by plugins, additional functionality for pipelines can be provided by global variables.\nThe simplest way to think of a global variable is as an object with methods that can be invoked on it.\nSeveral of these are built in to Jenkins, such as the Docker global variable.\nOthers can be created by users as part of the structure of a shared source code repository called a “shared pipeline library.”</p>\n</div>\n<div class=\"paragraph\">\n<p>To get a list of the global variables that are currently available to your Jenkins instance, you can go to the Snippet Generator screen.\nImmediately below the box for the generated pipeline script is a section titled Global Variables.\nThere, within the small print, is a link to get to the actual section (figure 2).</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure2.png\" alt=\"Link to Global Variables Reference section\">\n</div>\n<div class=\"title\">Figure 2. Link to Global Variables Reference section.</div>\n</div>\n<div class=\"paragraph\">\n<p>Clicking on that link takes us to a list of currently available Global Variables.\nIf you have the Docker Pipeline Plugin installed, you will see one at the top for Docker. (Figure 3).</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure3.png\" alt=\"Docker global variable specifics\" width=\"800\">\n</div>\n<div class=\"title\">Figure 3. Docker global variable specifics.</div>\n</div>\n<div class=\"paragraph\">\n<p>Broadly, the docker global variable includes methods that can be applied to the Docker application, Docker images, and Docker containers.</p>\n</div>\n<div class=\"paragraph\">\n<p>We’ll focus first on a couple of the Docker image methods as shown in figure 4.</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure4.png\" alt=\"Key methods for getting a Docker image\">\n</div>\n<div class=\"title\">Figure 4. Key methods for getting a Docker image.</div>\n</div>\n<div class=\"paragraph\">\n<p>There are multiple ways you can use these methods to create a new image.\nListing 2 shows a basic example of assigning and pulling an image using the image method.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">myImage = docker.image(\"bclaster/jenkins-node:1.0\")\nmyImage.pull()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Listing 2: Assigning a image to a variable and pulling it down.</p>\n</div>\n<div class=\"paragraph\">\n<p>This can also be done in a single statement as shown in listing 3.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">docker.image(\"bclaster/jenkins-node:1.0\").pull()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Listing 3: Shorthand version of previous call.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also download a Dockerfile and build an image based on it.(See listing 4.)</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">node() {\n    def myImg\n    stage (\"Build image\") {\n        // download the dockerfile to build from\n        git 'git@diyvb:repos/dockerResources.git'\n\n        // build our docker image\n        myImg = docker.build 'my-image:snapshot'\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Listing 4: Pipeline code to download a Dockerfile and build an image from it.</p>\n</div>\n<div class=\"paragraph\">\n<p>Figure 5 shows the actual output from running that “Build image” stage.\nNote that the docker.build step was translated into an actual Docker build command.</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure5.png\" alt=\"Actual Docker output from running the download and build\">\n</div>\n<div class=\"title\">Figure 5. Actual Docker output from running the download and build</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-inside-command\"><a class=\"anchor\" href=\"#the-inside-command\"></a>The Inside Command</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Another powerful method available for the Docker global variable is the inside method.\nWhen executed, this method will do the following:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Get an agent and a workspace to execute on</p>\n</li>\n<li>\n<p>If the Docker image is not already present, pull it down</p>\n</li>\n<li>\n<p>Start the container with that image</p>\n</li>\n<li>\n<p>Mount the workspace from Jenkins</p>\n</li>\n<li>\n<p>Execute the build steps</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Mounting the workspace means that the Jenkins workspace will appear as a volume inside the container.\nAnd it will have the same file path.\nSo, things running in the container will have direct access to the same location.\nHowever, this can only be done if the container is running on the same underlying system - such that it can directly access the path.</p>\n</div>\n<div class=\"paragraph\">\n<p>In terms of executing the build steps, the inside method acts as a scoping method.\nThis means that the environment it sets up is in effect for any statement that happens within its scope (within the block under it bounded by {}).\nThe practical application here is that any pipeline “sh” steps (a call to the shell to execute something) are automatically run in the container.\nBehind the scenes, this is done by wrapping the calls with “docker exec”.</p>\n</div>\n<div class=\"paragraph\">\n<p>When executed, the calls with the global variable are translated (by Jenkins) into actual Docker call invocations.\nListing 5 shows an example of using this in a script, along with the output from the first invocation of the “inside” method.\nYou can see in the output the docker commands that are generated from the inside method call.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">    stage (\"Get Source\") {\n        // run a command to get the source code download\n        myImg.inside('-v /home/git/repos:/home/git/repos') {\n            sh \"rm -rf gradle-greetings\"\n            sh \"git clone --branch test /home/git/repos/gradle-greetings.git\"\n        }\n    }\n    stage (\"Run Build\") {\n        myImg.inside() {\n            sh \"cd gradle-greetings &amp;&amp; gradle -g /tmp clean build -x test\"\n        }\n    }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Listing 5: Example inside method usage.</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<img src=\"/images/post-images/2018-08-17/figure6.png\" alt=\"Example inside method Docker command output\" width=\"800\">\n</div>\n<div class=\"title\">Figure 6. Example inside method Docker command output.</div>\n</div>\n<div class=\"paragraph\">\n<p>Once completed, the inside step will stop the container,\nget rid of the storage, and create a record that this image was used for the build.\nThat record facilitates image traceability, updates, etc.</p>\n</div>\n<div class=\"paragraph\">\n<p>As you can see, the combination of using the Docker “global variable” and its “inside” method provide a simple and powerful way to spin up and work with containers in your pipeline.\nIn addition, since you are not having to make the direct Docker calls, you can invoke steps like sh within the scope of the inside method, and have them executed by Docker transparently.</p>\n</div>\n<div class=\"paragraph\">\n<p>As we mentioned, this is only one of several ways you can interact with Docker in your pipeline code.\nTo learn about the other methods and get hands-on practice, join me at DevOps World/Jenkins World in San Francisco or Nice for the workshop\n\"<a href=\"https://devopsworldjenkinsworld2018.sched.com/event/FYjP/creating-a-deployment-pipeline-with-jenkins-2\">Creating a Deployment Pipeline with Jenkins 2</a>\".\nHope to see you there!</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-warning\" title=\"Warning\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>Join the Jenkins project at\n<a href=\"https://www.cloudbees.com/devops-world\">Jenkins World</a> on September 16-19th,\nregister with the code <code>JWFOSS</code> for a 30% discount off your pass.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>","id":"003e40e9-a1b3-5859-a18a-60017d86c651","title":"Using the Docker Global Variable in Your Jenkins Pipeline","date":"2018-08-17T00:00:00.000Z","slug":"/blog/2018/08/17/speaker-blog-brent-laster/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/19e71/brentlaster.jpg","srcSet":"/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/77b35/brentlaster.jpg 32w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/d4a57/brentlaster.jpg 64w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/19e71/brentlaster.jpg 128w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/68974/brentlaster.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/ef6ff/brentlaster.webp 32w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/8257c/brentlaster.webp 64w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/6766a/brentlaster.webp 128w,\n/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/22bfc/brentlaster.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}},"publicURL":"/gatsby-jenkins-io/static/04c1d7e712c641c082c7193fa99be1e5/brentlaster.jpg"},"blog":null,"github":"brentlaster","html":"<div class=\"paragraph\">\n<p>Brent Laster is a Senior Manager in the Research and Development division at SAS in Cary, North Carolina. He manages several groups involved with release engineering processes, best practices, and tooling. He also serves as a resource for the use of open-source technologies and conducts internal training classes in technologies such as Git, Gerrit, Gradle, and Jenkins, both in the U.S. and abroad.</p>\n</div>\n<div class=\"paragraph\">\n<p>Brent Laster is the author of \"Professional Git\"\n(a comprehensive guide to Git for users ranging from beginners to advanced)\nand \"Jenkins 2 – Up and Running:  Evolve Your Pipeline for Next-Generation Automation\".</p>\n</div>","id":"brentlaster","irc":null,"linkedin":null,"name":"Brent Laster","slug":"/blog/authors/brentlaster","twitter":"brentclaster"}]}},"pageContext":{"id":"003e40e9-a1b3-5859-a18a-60017d86c651"}},
    "staticQueryHashes": ["1271460761","3649515864"]}