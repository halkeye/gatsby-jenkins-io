{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/05/15/incremental-deployment/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>A couple of weeks ago, Tyler mentioned some\n<a href=\"/blog/2018/04/27/essentials-versions-are-numbered/#developer-improvements\">developer improvements in Essentials</a>\nthat had been recently introduced:\nthe ability for\n<a href=\"https://ci.jenkins.io/\">ci.jenkins.io</a>\nbuilds to get deployed automatically to an “Incrementals” Maven repository,\nas described in\n<a href=\"https://github.com/jenkinsci/jep/blob/master/jep/305/README.adoc\">JEP-305</a>.\nFor a plugin maintainer, you just need to\n<a href=\"https://github.com/jenkinsci/incrementals-tools/blob/master/README.md#enabling-incrementals-the-easy-way\">turn on this support</a>\nand you are ready to both deploy individual Git commits from your repository\nwithout the need to run heavyweight traditional Maven releases,\nand to depend directly on similar commits of Jenkins core or other plugins.\nThis is a stepping stone toward continuous delivery, and ultimately deployment, of Jenkins itself.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here I would like to peek behind the curtain a bit at how we did this,\nsince the solution turns out to be very interesting for people thinking about security in Jenkins.\nI will gloss over the Maven arcana required to get the project version to look like <code>1.40-rc301.87ce0dd8909b</code>\n(a real example from the\n<a href=\"https://repo.jenkins-ci.org/incrementals/org/jenkins-ci/plugins/copyartifact/1.40-rc301.87ce0dd8909b/\">Copy Artifact plugin</a>)\nrather than the usual <code>1.40-SNAPSHOT</code>, and why this format is even useful.\nSuffice it to say that if you had enough permissions, you could run</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">mvn -Dset.changelist -DskipTests clean deploy</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>from your laptop to publish your latest commit.\nIndeed as\n<a href=\"https://github.com/jenkinsci/jep/blob/master/jep/305/README.adoc#automated-deployment-to-the-incrementals-repository\">mentioned in the JEP</a>,\nthe most straightforward server setup would be to run more or less that command\nfrom the <code>buildPlugin</code> function called from a typical <code>Jenkinsfile</code>,\nwith some predefined credentials adequate to upload to the Maven repository.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unfortunately, that simple solution did not look very secure.\nIf you offer deployment credentials to a Jenkins job,\nyou need to trust anyone who might configure that job (here, its <code>Jenkinsfile</code>)\nto use those credentials appropriately.\n(The <code>withCredentials</code> step will mask the password from the log file, to prevent <em>accidental</em> disclosures.\nIt in no way blocks <em>deliberate</em> misuse or theft.)\nIf your Jenkins service runs inside a protected network and works with private repositories,\nthat is probably good enough.</p>\n</div>\n<div class=\"paragraph\">\n<p>For this project, we wanted to permit incremental deployments from any pull request.\nJenkins will refuse to run <code>Jenkinsfile</code> modifications from people\nwho would not normally be able to merge the pull request or push directly,\nand those people would be more or less trustworthy Jenkins developers,\nbut that is of no help if a pull request changes <code>pom.xml</code>\nor other source files used by the build itself.\nIf the server administrator exposes a secret to a job,\nand it is bound to an environment variable while running some open-ended command like a Maven build,\nthere is no practical way to control what might happen.</p>\n</div>\n<div class=\"paragraph\">\n<p>The lesson here is that the unit of access control in Jenkins is the job.\nYou can control who can configure a job, or who can edit files it uses,\nbut you have no control over what the job <em>does</em> or how it might use any credentials.\nFor JEP-305, therefore, we wanted a way to perform deployments from builds considered as black boxes.\nThis means a division of responsibility:\nthe build produces some artifacts, however it sees fit;\nand another process picks up those artifacts and deploys them.</p>\n</div>\n<div class=\"paragraph\">\n<p>This worked was tracked in\n<a href=\"https://issues.jenkins.io/browse/INFRA-1571\">INFRA-1571</a>.\nThe idea was to create a “serverless function” in Azure\nthat would retrieve artifacts from Jenkins at the end of a build,\nperform a set of validations to ensure that the artifacts follow an expected repository path pattern,\nand finally deploy them to Artifactory using a trusted token.\nI prototyped this in Java, Tyler\n<a href=\"https://github.com/jenkins-infra/community-functions/blob/master/incrementals-publisher/README.adoc\">rewrote it in JavaScript</a>,\nand together we brought it into production.</p>\n</div>\n<div class=\"paragraph\">\n<p>The crucial bit here is what information (or misinformation!) the Jenkins build can send to the function.\nAll we actually need to know is the build URL, so the\n<a href=\"https://github.com/jenkins-infra/pipeline-library/blob/442485fc03101d4f52856ea48825a4d45acece7e/vars/infra.groovy#L227-L245\">call site from Jenkins</a>\nis quite simple.\nWhen the function is called with this URL,\nit starts off by performing input validation:\nit knows what the Jenkins base URL is,\nand what a build URL from inside an organization folder is supposed to look like:\n<code><a href=\"https://ci.jenkins.io/job/Plugins/job/git-plugin/job/PR-582/17/\" class=\"bare\">https://ci.jenkins.io/job/Plugins/job/git-plugin/job/PR-582/17/</a></code>, for example.</p>\n</div>\n<div class=\"paragraph\">\n<p>The next step is to call back to Jenkins and ask it for some metadata about that build.\nWhile we do not trust the <em>build</em>, we trust the server that ran it to be properly configured.\nAn obstacle here was that the <code>ci.jenkins.io</code> server had been configured to disable the Jenkins REST API;\nwith Tyler’s guidance I was able to amend this policy to permit API requests from registered users\n(or, in the case of the Incrementals publisher, a bot).</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to try this at home, get an\n<a href=\"https://ci.jenkins.io/me/configure\">API token</a>,\npick a build of an “incrementalified” plugin or Jenkins core,\nand run something like</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">curl -igu &lt;login&gt;:&lt;token&gt; 'https://ci.jenkins.io/job/Plugins/job/git-plugin/job/PR-582/17/api/json?pretty&amp;tree=actions[revision[hash,pullHash]]'</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You will see a <code>hash</code> or <code>pullHash</code> corresponding to the <em>main commit</em> of that build.\n(This information was added to the Jenkins REST API to support this use case in\n<a href=\"https://issues.jenkins.io/browse/JENKINS-50777\">JENKINS-50777</a>.)\nThe main commit is selected when the build starts\nand always corresponds to the version of <code>Jenkinsfile</code> in the repository for which the job is named.\nWhile a build might <code>checkout</code> any number of repositories,\n<code>checkout scm</code> always picks “this” repository in “this” version.\nTherefore the deployment function knows for sure which commit the sources came from,\nand will refuse to deploy artifacts named for some other commit.</p>\n</div>\n<div class=\"paragraph\">\n<p>Next it looks up information about the Git repository at the folder level (again from JENKINS-50777):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">curl -igu &lt;login&gt;:&lt;token&gt; 'https://ci.jenkins.io/job/Plugins/job/git-plugin/api/json?pretty&amp;tree=sources[source[repoOwner,repository]]'</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The Git repository now needs to be correlated to a list of Maven artifact paths that this component is expected to produce.\nThe\n<a href=\"https://github.com/jenkins-infra/repository-permissions-updater\">repository-permissions-updater</a>\n(RPU) tool already had a list of artifact paths used to perform permission checks on regular release deployments to Artifactory; in\n<a href=\"https://issues.jenkins.io/browse/INFRA-1598\">INFRA-1598</a>\nI extended it to also record the GitHub repository name, as can be seen\n<a href=\"https://ci.jenkins.io/job/Infra/job/repository-permissions-updater/job/master/lastSuccessfulBuild/artifact/json/github.index.json\">here</a>.\nNow the function knows that the CI build in this example may legitimately create artifacts in the <code>org/jenkins-ci/plugins/git/</code> namespace\nincluding <code>38c569094828</code> in their versions.\nThe build is expected to have produced artifacts in the same structure as <code>mvn install</code> sends to the local repository,\nso the function downloads everything associated with that commit hash:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">curl -sg 'https://ci.jenkins.io/job/Plugins/job/git-plugin/job/PR-582/17/artifact/**/*-rc*.38c569094828/*-rc*.38c569094828*/*zip*/archive.zip' | jar t</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When all the artifacts are indeed inside the expected path(s),\nand at least one POM file is included (here <code>org/jenkins-ci/plugins/git/3.9.0-rc1671.38c569094828/git-3.9.0-rc1671.38c569094828.pom</code>),\nthen the ZIP file looks good—ready to send to Artifactory.</p>\n</div>\n<div class=\"paragraph\">\n<p>One last check is whether the commit has already been deployed (perhaps this is a rebuild).\nIf it has not, the function uses the Artifactory REST API to atomically upload the ZIP file\nand uses the GitHub Status API to associate a message with the commit\nso that you can see right in your pull request that it got deployed:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image left\"><img src=\"/images/post-images/2018-05-15/incrementals-status.png\" alt=\"incrementals status\" width=\"1104\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>One more bit of caution was required.\nJust because we successfully published some bits from some PR does not mean they should be <em>used</em>!\nWe also needed a tool which lets you select the newest published version of some artifact\n<em>within a particular branch</em>, usually <code>master</code>.\nThis was tracked in\n<a href=\"https://issues.jenkins.io/browse/JENKINS-50953\">JENKINS-50953</a>\nand is available to start with as a Maven command operating on a <code>pom.xml</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">mvn incrementals:update</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This will check Artifactory for updates to relevant components.\nWhen each one is found, it will use the GitHub API to check whether the commit has been merged to the selected branch.\nOnly matches are offered for update.</p>\n</div>\n<div class=\"paragraph\">\n<p>Putting all this together, we have a system for continuously delivering components\nfrom any of the hundreds of Jenkins Git repositories\ntriggered by the simple act of filing a pull request.\nSecuring that system was a lot of work\nbut highlights how boundaries of trust interact with CI/CD.</p>\n</div>","id":"85458a0f-8ad5-53fb-a455-a4b6ae133fb4","title":"Automatic deployment of “incremental” commits to Jenkins core and plugins","date":"2018-05-15T00:00:00.000Z","slug":"/blog/2018/05/15/incremental-deployment/","links":{"discourse":""},"authors":[]}},"pageContext":{"next":"/blog/2018/05/16/pipelines-with-git-tags/","previous":"/blog/2018/05/09/security-advisory/","id":"85458a0f-8ad5-53fb-a455-a4b6ae133fb4"}},
    "staticQueryHashes": ["1271460761","3649515864"]}