{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/11/12/inspecting-binaries-with-jenkins/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>In a past blog post,\n<a href=\"/blog/2017/04/18/continuousdelivery-devops-sonarqube/\">Delivery Pipelines, with Jenkins 2, SonarQube, and Artifactory</a>,\nwe talked about pipelines which result in binaries for development versions, and in\n<a href=\"/blog/2017/07/05/continuousdelivery-devops-artifactory/\">Delivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production</a>,\nwe examined ways to consistently promote applications toward production. In this blog post, I continue on both by discussing more details on security related quality gates\nand bringing this together with the handling of Docker images.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"use-case-foster-security-on-given-containerized-business-application\"><a class=\"anchor\" href=\"#use-case-foster-security-on-given-containerized-business-application\"></a>Use case: Foster security on given, containerized business application</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Security is an overloaded term with varying meaning in different contexts. For this contribution, I consider security as the sum of rules regarding vulnerabilities\n(Common Vulnerability and Exposure, CVE), in binaries. In a past blog post, we&#8217;ve identified SonarQube already, as a very helpful tool to identify flaws\nin source code, particularly concerning reliability (bugs), vulnerabilities (security, e.g. CWE, that is common weakness enumaration, and OWASP, that is the Open Web Application Security Project), and\nmaintainability (code smells). Now it is a good time to add another tool to the chain, that is Twistlock, for inspection binaries for security issues.\nFeatures of Twistlock include</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Compliance and vulnerability management, transitively</p>\n</li>\n<li>\n<p>Runtime defense</p>\n</li>\n<li>\n<p>Cloud-native CI/CD support</p>\n</li>\n<li>\n<p>Broad coverage of supported artifact types and platforms</p>\n</li>\n<li>\n<p>API, dashboards, and Jenkins integration, with strong configuration options</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The underlying use case can be derived from several real-world security initiatives, in enterprises, based on given containerized applications. In practice, it is not a surprise that after adding such new\nquality gates, you identify historically grown issues. However, there are many good reasons to do so. You don&#8217;t need any Word documents to check any governance criteria manually, rather\nexecution and reporting are done automatically and also part of the actions are taken automatically. And above all, of course, your application is quality assured regarding known vulnerability issues, aligned with\nthe DevOps approach: development is interested in quick feedback whether their change would introduce any vulnerabilities, and operations is interested in insights whether and\nhow running applications are affected if a new CVE is discovered.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-tip\" title=\"Tip\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>The term DevSecOps was coined to explicitely add security concerns to DevOps.\nIn my opinion, security is already inherent part of DevOps.\nThus, there is no strong reason to introduce a new word. Surely, new words are catchy.\nBut they have limits.\nOr have you ever experienced NoDev, the variant of DevOps where features are suddenly falling from the sky and deployed to production automatically?</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Conceptually, container inspection is now part of the delivery pipeline and Twistlock processing is now triggered once we have produced our Docker images, see below, in order to get\nfast feedback.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/01.png\" alt=\"01\" title=\"The delivery pipeline, failing the quality gate of inspecting Docker image.\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Software is staged over different environments by configuration, without rebuilding. All changes go through the entire staging process, although defined\nexception routines may be in place, for details see Michael Hüttermann, <em>Agile ALM</em> (Manning, 2012). The staged software consists of all artifacts which\nmake up the release, consistently, including the business application, test cases, build scripts, Chef cookbooks, Dockerfiles, Jenkins files to build all\nthat in a self-contained way, for details see Michael Hüttermann, <em>DevOps for Developers</em> (Apress, 2012).</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This blog post covers sample tools. Please note, that there are also alternative tools available, and the best target architecture is aligned with concrete requirements and given basic\nconditions. Besides that, the sample toolchain is derived from couple of real world success stories, designed and implemented in the field. However, this blog post\nsimplifies and abstracts them in order to stay focussed while discussing the primitives of delivery units. For example, aggregating multiple Docker images with ASCII files, does not change the\nunderlying primitives and their handlings. For more information on all parts of the blog post, please consult the respective documentation, good books or attend fine conferences. Or go to the extremes: talk to your colleagues.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>In our sample process, we produce a web application that is packaged in a Docker image. The produced Docker images are distributed only if the dedicated quality gate passes.\nA quality gate is a stage in the overall pipeline and a sum of defined commitments, often\ncalled requirements, the unit of work must pass. In our case, the quality gate comprises inspection of produced binaries and it fails if vulnerabilities of severity 'critical' are found.\nWe can configure Twistlock according to our requirements. Have a look how we&#8217;ve integrated it into our Jenkins pipeline, with focus on detecting vulnerabilities.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Jenkinsfile (excerpt): Twistlock inspection triggered</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">stage('Twistlock: Analysis') { <i class=\"conum\" data-value=\"1\"></i><b>(1)</b>\n    String version = readFile('version.properties').trim() <i class=\"conum\" data-value=\"2\"></i><b>(2)</b>\n    println \"Scanning for version: ${version}\"\n    twistlockScan ca: '', cert: '', compliancePolicy: 'critical', \\\n        dockerAddress: 'unix:///var/run/docker.sock', \\\n        ignoreImageBuildTime: false, key: '', logLevel: 'true', \\\n        policy: 'critical', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', \\ <i class=\"conum\" data-value=\"3\"></i><b>(3)</b>\n        requirePackageUpdate: false, tag: \"$version\", timeout: 10\n}\n\nstage('Twistlock: Publish') { <i class=\"conum\" data-value=\"4\"></i><b>(4)</b>\n    String version = readFile('version.properties ').trim()\n    println \"Publishing scan results for version: ${version}\"\n    twistlockPublish ca: '', cert: '', \\\n        dockerAddress: 'unix:///var/run/docker.sock', key: '', \\\n        logLevel: 'true', repository: 'huttermann-docker-local.jfrog.io/michaelhuettermann/alpine-tomcat7', tag: \"$version\", \\\n        timeout: 10\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<table>\n<tr>\n<td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td>\n<td>Twistlock inspection as part of the sequence of stages in Jenkinsfile</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td>\n<td>Nailing down the version of the to be inspected image, dynamically</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"3\"></i><b>3</b></td>\n<td>Configuring analysis including vulnerability severity level</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"4\"></i><b>4</b></td>\n<td>Publishing the inspection results to Twistlock console, that is the dashboard</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Now let&#8217;s start with the first phase to bring our application in shape again, that is gaining insight about the security related flaws.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"phase-1-gain-insights-about-security-related-flaws\"><a class=\"anchor\" href=\"#phase-1-gain-insights-about-security-related-flaws\"></a>Phase 1: Gain insights about security related flaws</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>After we&#8217;ve introduced the new quality gate, it failed, see image above. As integration with other tools, Jenkins is the automation engine and does provide helpful context information,\nhowever, those cannot replace features and data the dedicated, triggered tool does offer. Thus, this is the moment to switch to the dedicated tool, that is Twistlock. Opening\nthe dashboard, we can navigate to the Jenkins build jobs, that is the specific run of the build, and the respective results of the Twistlock analysis. What we see now is a list\nof vulnerabilities, and we need to fix those of severity <em>critical</em> in order to pass the quality gate, and get our changes again toward production. The list shows entries of\ntype <em>jar</em>, that is a finding in a binary as part of the Docker image, in our case the WAR file we&#8217;ve deployed to a web container (Tomcat), and of type <em>OS</em>, those are issues of the underlying image itself, the\noperating system, either part of the base image, or as a package added/changed in our Dockerfile.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/02.png\" alt=\"02\" title=\"Twistlock findings: overview.\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>We can now easily zoom in and examine the vulnerabilities of the Docker layers. This really helps to structure work and identify root causes. Since, typically,\na Docker image extends a Docker base image, the findings in the base image are shown on the top, see next screenshot, grouped by severity.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/03.png\" alt=\"03\" title=\"Twistlock also displays the vulnerabilities according to Docker layers. Findings based on the base image are listed at the top.\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Other Docker layers were added to the base image, and those can add vulnerabilities too. In our case, the packaged WAR file obviously contains a vulnerability. The next image shows how we examine that finding, while this time\nexpanding the Twistlock wizard (that is the plus sign) to directly see the list of found vulnerabilities.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/04.png\" alt=\"04\" title=\"Twistlock recursively inspects embedded binaries auch as the WAR with its libraries. Here the wizard is expanded showing all vulnerabilities of this layer. On the right side, we can move over the different sections of our Dockerfile.\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Finding and visualizing the issues are a very good first step, and we&#8217;ve even made those findings actionable, so we now have to take action and address them.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"phase-2-address-the-findings\"><a class=\"anchor\" href=\"#phase-2-address-the-findings\"></a>Phase 2: Address the findings</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To address the findings, we need to split our initiative into two parts:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Fixing the critical vulnerabilities related to the Docker image (in our case largely the base image)</p>\n</li>\n<li>\n<p>Fixing the critical vulnerabilities related to the embedded deployment unit (in our case the WAR)</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s proceed bottom up, first coping with the Docker base image.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This is an easy example covering multiple scenarios particularly identifying and fixing vulnerabilities in transitive binaries, i.e. binaries contained in\nother binaries, e.g. a Docker image containing a WAR file that in turn contains libraries. To expand this vertical feasibility spike, you can easily add\nmore units of each layer, or add more abstractions, however, the idea can always be nailed down to the primitives, covered in this blog post.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s now have a look at the used Docker image by looking at the used Dockerfile.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Dockerfile: The Dockerfile based on Alpine, running OpenJDK 8</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>FROM openjdk:8-jre-alpine <i class=\"conum\" data-value=\"1\"></i><b>(1)</b>\nLABEL maintainer \"michael@huettermann.net\"\n\n# Domain of your Artifactory. Any other storage and URI download link works, just change the ADD command, see below.\nARG ARTI\nARG VER\n\n# Expose web port\nEXPOSE 8080\n\n# Tomcat Version\nENV TOMCAT_VERSION_MAJOR 9 <i class=\"conum\" data-value=\"2\"></i><b>(2)</b>\nENV TOMCAT_VERSION_FULL  9.0.6\n\n# Download, install, housekeeping\nRUN apk add --update curl &amp;&amp;\\  <i class=\"conum\" data-value=\"3\"></i><b>(3)</b>\n  apk add bash &amp;&amp;\\\n  #apk add -u libx11 &amp;&amp;\\  <i class=\"conum\" data-value=\"4\"></i><b>(4)</b>\n  mkdir /opt &amp;&amp;\\\n  curl -LO ${ARTI}/list/generic-local/apache/org/tomcat/tomcat-${TOMCAT_VERSION_MAJOR}/v${TOMCAT_VERSION_FULL}/bin/apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &amp;&amp;\\\n  gunzip -c apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz | tar -xf - -C /opt &amp;&amp;\\\n  rm -f apache-tomcat-${TOMCAT_VERSION_FULL}.tar.gz &amp;&amp;\\\n  ln -s /opt/apache-tomcat-${TOMCAT_VERSION_FULL} /opt/tomcat &amp;&amp;\\\n  rm -rf /opt/tomcat/webapps/examples /opt/tomcat/webapps/docs &amp;&amp;\\\n  apk del curl &amp;&amp;\\\n  rm -rf /var/cache/apk/*\n\n# Download and deploy the Java EE WAR\nADD http://${ARTI}/list/libs-release-local/com/huettermann/web/${VER}/all-${VER}.war /opt/tomcat/webapps/all.war <i class=\"conum\" data-value=\"5\"></i><b>(5)</b>\n\nRUN chmod 755 /opt/tomcat/webapps/*.war\n\n# Set environment\nENV CATALINA_HOME /opt/tomcat\n\n# Start Tomcat on startup\nCMD ${CATALINA_HOME}/bin/catalina.sh run</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<table>\n<tr>\n<td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td>\n<td>Base image ships OpenJDK 8, on Alpine</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td>\n<td>Defined version of web container</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"3\"></i><b>3</b></td>\n<td>Applying some defined steps to configure Alpine, according to requirements</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"4\"></i><b>4</b></td>\n<td>Updating package itself would address one vulnerability already</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"5\"></i><b>5</b></td>\n<td>Deploying the application</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>By checking available versions of the official OpenJDK Alpine image, we see that there&#8217;s a newer version 8u181 which we could use.\nWe can zoom in and study release notes and contents, or we just pragmatically switch the base image to a more recent version. Often it is a good idea\nto upgrade versions regularly, in defined intervals. This leads to the following change in the Dockerfile.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Dockerfile (excerpt): The Dockerfile based on Alpine, running OpenJDK 8u181</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>FROM openjdk:8u181-jre-alpine <i class=\"conum\" data-value=\"1\"></i><b>(1)</b>\nLABEL maintainer \"michael@huettermann.net\"</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<table>\n<tr>\n<td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td>\n<td>Base image is now OpenJDK 8u181, on Alpine</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>There are more options available to fix the issues, but let&#8217;s proceed to the second part, the vulnerabilities in the deployment unit.</p>\n</div>\n<div class=\"paragraph\">\n<p>Before we push this change to GitHub, we also address the vulnerability issue in the deployment unit, that is <em>jetty-io</em>. Here we are a bit unsure about\nwhy, in this specific use case, the library is used. To retrieve more information about dependencies, we run a <em>dependency:tree</em> command on our Maven\nbased project. We now see that jetty-io is transitively referenced by <em>org.seleniumhq.selenium:htmlunit-driver</em>. We can surely discuss why this is a compile\ndependency and the libraries are shipped as part of the WAR, but let&#8217;s consider this to be given according to requirements, thus we must take special attention now\nto version 2.29.0 of the specific library.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/05.png\" alt=\"05\" title=\"Inspecting the dependency structure, with the used build tool\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Also here we can browse release notes and content (particularly how those libs are built themselves), and come to the conclusion to\nswitch from the used version, that is <em>2.29.0</em>, to a newer version of <em>htmlunit-driver</em>, that is <em>2.31.1</em>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">pom.xml (excerpt): Build file</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-xml\" data-lang=\"xml\">    &lt;dependencies&gt; <i class=\"conum\" data-value=\"1\"></i><b>(1)</b>\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;\n            &lt;version&gt;3.14.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; <i class=\"conum\" data-value=\"2\"></i><b>(2)</b>\n            &lt;artifactId&gt;htmlunit-driver&lt;/artifactId&gt;\n            &lt;version&gt;2.31.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;4.7&lt;/version&gt;\n        &lt;/dependency&gt;</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<table>\n<tr>\n<td><i class=\"conum\" data-value=\"1\"></i><b>1</b></td>\n<td>Part of the underlying POM defining dependencies</td>\n</tr>\n<tr>\n<td><i class=\"conum\" data-value=\"2\"></i><b>2</b></td>\n<td>Definition of the dependency, causing the vulnerability finding; we use a newer version now</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>OK, now we are done. We push the changes to GitHub, and our GitHub webhook directly triggers the workflow. This time the quality gate passes, so it\nlooks like our fixes did address the root causes and eliminated those with the configured threshold severity.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/06.png\" alt=\"06\" title=\"Part of the delivery pipeline, showing the quality gate passed and Docker image inspected without findings of severity CRITICAL\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Finally, after running through our entire workflow, that is made up of different pipelines, our inspected and quality assured container does successfully\nrun in our production runtime environment, that is on Oracle Cloud.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/jenkins-devsecops/07.png\" alt=\"07\" title=\"The quality assured Docker container runs in the Oracle Cloud.\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Crisp, isn&#8217;t it?</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"summary\"><a class=\"anchor\" href=\"#summary\"></a>Summary</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>This closes our quick walkthrough of how to inject security related quality gates into a Jenkins based delivery pipeline.\nWe&#8217;ve discussed some concepts and how this can look like with sample tools.\nIn the center of our efforts, we used Jenkins, the swiss army knife of automation.\nWe enriched our ecosystem by integrating couple of platforms and tools, above all Twistlock.\nAfter this tasty appetizer you are ready to assess your own delivery pipelines,\nconcepts and tools, and to possibly invest even more attention to security.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"references\"><a class=\"anchor\" href=\"#references\"></a>References</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"http://huettermann.net/alm/\">'Agile ALM', Manning, 2011</a></p>\n</li>\n<li>\n<p><a href=\"http://huettermann.net/devops/\">'DevOps for Developers', Apress, 2012</a></p>\n</li>\n<li>\n<p><a href=\"https://www.docker.com/\">Docker, the standard to develop and ship set of changes</a></p>\n</li>\n<li>\n<p><a href=\"https://hub.docker.com/_/openjdk/\">Docker images, shipping OpenJDK</a></p>\n</li>\n<li>\n<p><a href=\"https://cloud.oracle.com/en_US/containers\">Oracle Cloud Infrastructure, for containers</a></p>\n</li>\n<li>\n<p><a href=\"https://alpinelinux.org/\">Alpine Linux</a></p>\n</li>\n<li>\n<p><a href=\"https://www.sonarqube.org/\">SonarQube, the language/platform agnostic Continuous Inspection tool</a></p>\n</li>\n<li>\n<p><a href=\"https://www.twistlock.com/\">Twistlock, the container security platform</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/michaelhuettermann/sandbox/tree/master/all/\">Sources on GitHub</a></p>\n</li>\n<li>\n<p><a href=\"https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange\">ASCII, commonly used standard to work on primitives, such as Docker (and their aggregations)</a></p>\n</li>\n<li>\n<p><a href=\"https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures\">Common Vulnerabilities and Exposures</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/jBGFjFc6Jf8?t=1427\">Holistic pipelines, Live 15-minute Jenkins Demos, Part 1, on YouTube</a></p>\n</li>\n<li>\n<p><a href=\"https://youtu.be/rS_pchiwGdM?t=95\">Holistic pipelines, Live 15-minute Jenkins Demos, Part 2, on YouTube</a></p>\n</li>\n<li>\n<p><a href=\"/blog/2017/04/18/continuousdelivery-devops-sonarqube/\">Delivery Pipelines, with Jenkins 2, SonarQube, and Artifactory</a></p>\n</li>\n<li>\n<p><a href=\"/blog/2017/07/05/continuousdelivery-devops-artifactory/\">Delivery pipelines, with Jenkins 2: how to promote Java EE and Docker binaries toward production</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>","id":"19ad29c6-3758-5c7b-bc08-31222e0bfca7","title":"The Silence of the Lambs: Inspecting binaries with Jenkins","date":"2018-11-12T00:00:00.000Z","slug":"/blog/2018/11/12/inspecting-binaries-with-jenkins/","links":{"discourse":""},"authors":[]}},"pageContext":{"next":"/blog/2018/11/13/martinda-gsoc-mentor-summit-experience/","previous":"/blog/2018/11/07/Validate-Jenkinsfile/","id":"19ad29c6-3758-5c7b-bc08-31222e0bfca7"}},
    "staticQueryHashes": ["1271460761","3649515864"]}