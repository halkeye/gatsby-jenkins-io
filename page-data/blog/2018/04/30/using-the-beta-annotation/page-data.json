{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/04/30/using-the-beta-annotation/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>This sort of slid under the radar in the middle of some bigger changes\nfor the <a href=\"https://github.com/jenkinsci/jep/tree/master/jep/202\">JEP-202</a>\nreference implementation, so I wanted to call it out now. Arguably this could\ndeserve a retroactive JEP, though I would rather fold it into a JEP for\n<a href=\"https://issues.jenkins.io/browse/JENKINS-49651\">JENKINS-49651</a> (see below).</p>\n</div>\n<div class=\"paragraph\">\n<p>As of Jenkins 2.118, or plugin parent POM 3.7, you can mark any Java member\n(<code>class</code>, <code>method</code>, <code>constructor</code>, <code>field</code>, or I suppose also interface,\n<code>enum</code>, or <code>annotation</code>) with API visibility (<code>protected</code> or <code>public</code>) with an\n<a href=\"https://github.com/kohsuke/access-modifier/pull/11\">annotation</a>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-java\" data-lang=\"java\">@Restricted(Beta.class)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The idea is to announce to potential users of the member that the API\nmay still be in flux and only code prepared to keep up should be using\nit. For an example, 2.118 added a <code>VirtualFile.toExternalURL()</code> method\nthat is being implemented in <code>artifact-manager-s3</code> and (pending some\nPR merges) called in <code>copyartifact</code> and <code>workflow-basic-steps</code>. We do\nnot necessarily want this to be called yet by unknown parties out\nthere in the Jenkins ecosystem. To enforce that, any attempt to call\nor implement <code>toExternalURL</code> will produce a build failure, unless you\nadd this property to your plugin POM, as these plugins have done:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-xml\" data-lang=\"xml\">&lt;useBeta&gt;true&lt;/useBeta&gt;</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Why? Because there is a chance the design is wrong and it might need\nto be changed—perhaps some upcoming bug fix would demand a <code>boolean</code>\nparameter be added, for example.</p>\n</div>\n<div class=\"paragraph\">\n<p>Under the conventional notion of Jenkins API deprecation and compatibility\npolicy, once an API like this makes it into a release version, that is it—we\nmight mark it <code>@Deprecated</code> but we need to maintain compatibility indefinitely,\nand find some way to migrate existing implementations / call sites.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the <code>@Beta</code> annotation, that promise is not being made. If it needs\na <code>boolean</code> parameter for some reason, that will be added and those\nthree plugins updated to match; we are not going to bother retaining\nthe original overload and somehow delegating to the new one. This\nsimplification of the developer workflow is important to the use cases\nof <a href=\"https://github.com/jenkins-infra/evergreen\">Essentials</a> (JEP-3xx), and I would expect the <code>useBeta</code> mark to\nbecome widespread among plugins included in Essentials. Such as the situation\nwhere one team needs to feel\ncomfortable refactoring code under its aegis freely, and the refactored result\nshould be deliverable as a unit to production via the Evergreen distribution\nsystem.</p>\n</div>\n<div class=\"paragraph\">\n<p>So that leaves two important questions:</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>First</strong>, is the annotation\npermanent, and if not, when should it be removed? I do not think there\nis any hard policy, but the intention is that it should be removed\nonce the API is in more or less widespread use and has held up. For\nthis example, if people start using S3 artifacts, and especially if\nsomeone successfully writes an implementation of artifact storage in\nAzure that uses the API, the concept will have been reasonably proven.\nAt that point we want the API to be used wherever it would make sense,\nand if there is some very belated realization that the design is not\nquite right, we accept the burden of deprecating the original and\nmigrating callers compatibly.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Second</strong>, it is fine and well to say that someone changing the signature\nof a beta <code>toExternalURL</code> is on the hook to update the three plugins\nusing it, but what if a Jenkins admin (<em>not</em> running Essentials, for\nshame) upgrades to (say) Jenkins 2.125 with the new signature but\ndeclines to accept the updates to those plugins (say,\n<code>workflow-basic-steps</code> 2.9) which adapt to the change? It is not\nenough to say that it is their fault for holding back on the updates\narbitrarily; the plugin manager <em>offers</em> you updates but does nothing\nto tell you when they are <em>required</em>, so suddenly throwing\n<code>NoSuchMethodError</code> is not a helpful response.</p>\n</div>\n<div class=\"paragraph\">\n<p>The solution needs to be ironed out, but my expectation is to use\n<a href=\"https://issues.jenkins.io/browse/JENKINS-49651\">JENKINS-49651</a>\nfor this. For example, <code>workflow-basic-steps</code> 2.8,\nusing <code>toExternalURL()</code>, would have declared itself compatible with\n<code>Jenkins-Version: 2.118</code>, and thus implicitly anything newer. The\ndeveloper doing the refactoring would also amend some 2.125 (and\nnewer) core metadata to say that it conflicts with anything older than\nthe 2.9 release of the plugin. The plugin manager would therefore\nblock the 2.8 plugin from even being loaded on the 2.125 core; the\nadmin would need to update before using it. In the case of an\nincompatible change made to a plugin API, rather than a core API, the\nUX is a little smoother since the plugin manager could just refuse to\nlet you update one without the other.</p>\n</div>\n<hr>\n<div class=\"paragraph\">\n<p>If you&#8217;re a plugin or core developer who is interested in using the <code>@Beta</code>\nannotations, or have questions about our motiviations, please join the\ndiscussion on\n<a href=\"https://groups.google.com/d/msgid/jenkinsci-dev/CANfRfr0Ngpm_f-F_BhTzHijyPse7pMVT8-oVazHrO%3Di_d7ZR4A%40mail.gmail.com\">this mailing list thread</a>.</p>\n</div>","id":"b56ab05f-d077-5b8d-ab93-27f00b4c8c1e","title":"Using new core APIs with the Beta annotation","date":"2018-04-30T00:00:00.000Z","slug":"/blog/2018/04/30/using-the-beta-annotation/","links":{"discourse":""},"authors":[{"avatar":null,"blog":null,"github":"jglick","html":"<div class=\"paragraph\">\n<p>Jesse has been developing Jenkins core and plugins for years.\nHe is the coauthor with Kohsuke of the core infrastructure of the Pipeline system.</p>\n</div>","id":"jglick","irc":null,"linkedin":null,"name":"Jesse Glick","slug":"blog/author/jglick","twitter":"tyvole"}]}},"pageContext":{"next":"/blog/2018/05/01/gsoc2018-projects-announcement/","previous":"/blog/2018/04/27/essentials-versions-are-numbered/","id":"b56ab05f-d077-5b8d-ab93-27f00b4c8c1e"}},
    "staticQueryHashes": ["1271460761","3649515864"]}