{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/04/25/configuring-jenkins-pipeline-with-yaml-file/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>A few years ago our CTO wrote about building a\n<a href=\"https://medium.com/wolox-driving-innovation/ruby-on-rails-continuous-integration-with-jenkins-and-docker-compose-8dfd24c3df57\">Continuous Integration server for Ruby On Rails using Jenkins and docker</a>.\nThe solution has been our CI pipeline for the past years until we recently decided to\nmake an upgrade. Why?</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Jenkins version was way out of date and it was getting difficult to\nupgrade</p>\n</li>\n<li>\n<p><a href=\"https://www.wolox.co\">Wolox</a> has grown significantly over the past years\nand we’ve been experiencing scaling issues</p>\n</li>\n<li>\n<p>Very few people knew how to fix any issues with the server</p>\n</li>\n<li>\n<p>Configuring jobs was not an easy task and that made our project\nkickoff process slower</p>\n</li>\n<li>\n<p>Making changes to the commands that each job runs was not easy and not\nmany people had permissions to do so. Wolox has a wide range of\nprojects, with a wide variety of languages which made this problem even\nbigger.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Taking into account these problems, we started digging into the newest\nversion of Jenkins to see how we could improve our CI. We needed to\nbuild a new CI that could, at least, address the following:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Projects must be built using Docker. Our projects depend on one or\nmultiple docker images to run (app, database, redis, etc)</p>\n</li>\n<li>\n<p>Easy to configure and replicate if necessary</p>\n</li>\n<li>\n<p>Easy to add a new project</p>\n</li>\n<li>\n<p>Easy to change the building steps. Everyone working on the project\nshould be able to change if they want to run <em>npm install</em> or <em>yarn\ninstall</em>.</p>\n</li>\n</ul>\n</div>\n<div class=\"sect1\">\n<h2 id=\"installing-jenkins-and-docker\"><a class=\"anchor\" href=\"#installing-jenkins-and-docker\"></a>Installing Jenkins and Docker</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Installing Jenkins is straightforward. You can visit\n<a href=\"https://jenkins.io/download/\">Jenkins Installation page</a> and choose the\noption that best suits your needs.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here are the steps we followed to install Jenkins in AWS:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">sudo rpm — import https://pkg.jenkins.io/debian/jenkins.io.key\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo\nsudo yum install java-1.8.0 -y\nsudo yum remove java-1.7.0-openjdk -y\nsudo yum install jenkins -y\nsudo yum update -y\nsudo yum install -y docker</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"automatically-adding-projects-from-github\"><a class=\"anchor\" href=\"#automatically-adding-projects-from-github\"></a>Automatically adding projects from Github</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Adding projects automatically from Github can be achieved using the\n<a href=\"https://plugins.jenkins.io/github-branch-source\">GitHub Branch Source Plugin</a>.\nIt allows Jenkins to scan a GitHub organization\nfor projects that match certain rules and add them to Jenkins\nautomatically. The only constraint that all branches must meet in order\nto be added is that they contain a Jenkinsfile that explains how to\nbuild the project.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"easy-to-change-configuration\"><a class=\"anchor\" href=\"#easy-to-change-configuration\"></a>Easy to change configuration</h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"not-so-easy-to-change-configuration\"><a class=\"anchor\" href=\"#not-so-easy-to-change-configuration\"></a>Not so easy to change configuration</h3>\n<div class=\"paragraph\">\n<p>One of the biggest pains we had with our previous Jenkins was the\ndifficulty of changing the steps necessary to build the project. If you\nlooked at a project’s build steps, you would find something like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">#!/bin/bash +x\nset -e\n\n# Remove unnecessary files\necho -e \"\\033[34mRemoving unnecessary files...\\033[0m\"\nrm -f log/*.log &amp;&gt; /dev/null || true &amp;&gt; /dev/null\nrm -rf public/uploads/* &amp;&gt; /dev/null || true &amp;&gt; /dev/null\n\n# Build Project\necho -e \"\\033[34mBuilding Project...\\033[0m\"\ndocker-compose --project-name=${JOB_NAME} build\n\n# Prepare test database\nCOMMAND=\"bundle exec rake db:drop db:create db:migrate\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\ndocker-compose --project-name=${JOB_NAME} run  \\\n\t-e RAILS_ENV=test web $COMMAND\n\n# Run tests\nCOMMAND=\"bundle exec rspec spec\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\nunbuffer docker-compose --project-name=${JOB_NAME} run web $COMMAND\n\n# Run rubocop lint\nCOMMAND=\"bundle exec rubocop app spec -R --format simple\"\necho -e \"\\033[34mRunning: $COMMAND\\033[0m\"\nunbuffer docker-compose --project-name=${JOB_NAME} run -e RUBYOPT=\"-Ku\" web $COMMAND</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And some post build steps that cleaned up the docker:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-bash\" data-lang=\"bash\">#!/bin/bash +x\ndocker-compose --project-name=${JOB_NAME} stop &amp;&gt; /dev/null || true &amp;&gt; /dev/null\ndocker-compose --project-name=${JOB_NAME} rm --force &amp;&gt; /dev/null || true &amp;&gt; /dev/null\ndocker stop `docker ps -a -q -f status=exited` &amp;&gt; /dev/null || true &amp;&gt; /dev/null\ndocker rm -v `docker ps -a -q -f status=exited` &amp;&gt; /dev/null || true &amp;&gt; /dev/null\ndocker rmi `docker images --filter 'dangling=true' -q --no-trunc` &amp;&gt; /dev/null || true &amp;&gt; /dev/null</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Although these commands are not complex, changing any of them required\nsomeone with permissions to modify the job and an understanding ofwhat\nneeded to be done.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"jenkinsfile-to-the-rescue-or-not\"><a class=\"anchor\" href=\"#jenkinsfile-to-the-rescue-or-not\"></a>Jenkinsfile to the rescue&#8230;&#8203; or not</h3>\n<div class=\"paragraph\">\n<p>With the current Jenkins version, we can take advantage of\n<a href=\"https://jenkins.io/doc/book/pipeline/\">Jenkins Pipeline</a> and model our build\nflow in a file. This file is checked into the repository and, therefore,\nanyone with access to it can change the build steps. Yay!</p>\n</div>\n<div class=\"paragraph\">\n<p>Jenkins Pipeline even has support for:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://jenkins.io/doc/book/pipeline/docker/\">Docker</a> and\n<a href=\"https://jenkins.io/doc/book/pipeline/docker/#advanced-usage-with-scripted-pipeline\">multiple\nimages</a> can be used for a build!</p>\n</li>\n<li>\n<p>Setting environment variables with <em>withEnv</em> and many other built -in\nfunctions that can be found\n<a href=\"https://jenkins.io/doc/pipeline/steps/workflow-basic-steps/\">here</a>.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This makes a perfect case for <a href=\"https://www.wolox.co\">Wolox</a>. We can have\nour build configuration in a file that’s checked into the repository and\ncan be changed by anyone with write access to it. However, a Jenkinsfile\nfor a simple rails project would look something like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\"># sample Jenkinsfile. Might not compile\nnode {\n    checkout scm\n    withEnv(['MYTOOL_HOME=/usr/local/mytool']) {\n        docker.image(\"postgres:9.2\").withRun() { db -&gt;\n            withEnv(['DB_USERNAME=postgres', 'DB_PASSWORD=', \"DB_HOST=db\", \"DB_PORT=5432\"]) {\n                docker.image(\"redis:X\").withRun() { redis -&gt;\n                    withEnv([\"REDIS_URL=redis://redis\"]) {\n                        docker.build(imageName, \"--file .woloxci/Dockerfile .\").inside(\"--link ${db.id}:postgres --link ${redis.id}:redis\") {\n                            sh \"rake db:create\"\n                            sh \"rake db:migrate\"\n                            sh \"bundle exec rspec spec\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This file is not only difficult to read, but also difficult to change.\nIt’s quite easy to break things if you’re not familiar with Groovy and\neven easier if you know nothing about how Jenkins’ pipeline works.\nChanging or adding a new Docker image isn’t straightforward and might\nlead to confusion.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"configuring-jenkins-pipeline-via-yaml\"><a class=\"anchor\" href=\"#configuring-jenkins-pipeline-via-yaml\"></a>Configuring Jenkins Pipeline via YAML</h3>\n<div class=\"paragraph\">\n<p>Personally, I’ve always envied simple configuration files for CIs and\nthis time it was our chance to build CI that could be configured using a\nYAML file. After some analysis we concluded that a YAML like this one\nwould suffice:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-yaml\" data-lang=\"yaml\">config:\n  dockerfile: .woloxci/Dockerfile\n  project_name: some-project-name\n\nservices:\n  - postgresql\n  - redis\n\nsteps:\n  analysis:\n    - bundle exec rubocop -R app spec --format simple\n    - bundle exec rubycritic --path ./analysis --minimum-score 80 --no-browser\n  setup_db:\n    - bundle exec rails db:create\n    - bundle exec rails db:schema:load\n  test:\n    - bundle exec rspec\n  security:\n    - bundle exec brakeman --exit-on-error\n  audit:\n    - bundle audit check --update\n\n\nenvironment:\n  RAILS_ENV: test\n  GIT_COMMITTER_NAME: a\n  GIT_COMMITTER_EMAIL: b\n  LANG: C.UTF-8</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It outlines some basic configuration for the project, environment\nvariables that need to be present during the run, dependentservices, and\nour build steps.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"jenkinsfile-shared-libraries-woloxci\"><a class=\"anchor\" href=\"#jenkinsfile-shared-libraries-woloxci\"></a>Jenkinsfile + Shared Libraries = WoloxCI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>After investigating for a while about Jenkins and the pipeline, we found\nthat we could extend it with\n<a href=\"https://jenkins.io/doc/book/pipeline/shared-libraries/\">shared libraries</a>.\nShared libraries are written in groovy and can be imported\ninto the pipeline and executed when necessary.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you look carefully at this Jenkinsfile,\nwe see that the code is a chain of methods calls that receive a\nclosure, where we execute another method passing a new closure to it.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\"># sample Jenkinsfile. Might not compile\nnode {\n    checkout scm\n    withEnv(['MYTOOL_HOME=/usr/local/mytool']) {\n        docker.image(\"postgres:9.2\").withRun() { db -&gt;\n            withEnv(['DB_USERNAME=postgres', 'DB_PASSWORD=', \"DB_HOST=db\", \"DB_PORT=5432\"]) {\n                docker.image(\"redis:X\").withRun() { redis -&gt;\n                    withEnv([\"REDIS_URL=redis://redis\"]) {\n                        docker.build(imageName, \"--file .woloxci/Dockerfile .\").inside(\"--link ${db.id}:postgres --link ${redis.id}:redis\") {\n                            sh \"rake db:create\"\n                            sh \"rake db:migrate\"\n                            sh \"bundle exec rspec spec\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Groovy is flexible enough to allow this same declarative code to be\ncreated at runtime, making our dream of using a YAML to configure our\njob come true!</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"introducing-wolox-ci\"><a class=\"anchor\" href=\"#introducing-wolox-ci\"></a>Introducing Wolox-CI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>That’s how <a href=\"https://github.com/Wolox/wolox-ci\">wolox-ci</a> was born- our\nshared library for Jenkins!</p>\n</div>\n<div class=\"paragraph\">\n<p>With <a href=\"https://github.com/Wolox/wolox-ci\">wolox-ci</a>, our Jenkinsfile is now\nreduced to:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">@Library('wolox-ci') _\n\nnode {\n\n  checkout scm\n\n  woloxCi('.woloxci/config.yml');\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Now it simply checks out the code and then calls wolox-ci. The library\nreads yaml file like this one</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-yaml\" data-lang=\"yaml\">config:\n  dockerfile: .woloxci/Dockerfile\n  project_name: some-project-name\n\nservices:\n  - postgresql\n  - redis\n\nsteps:\n  analysis:\n    - bundle exec rubocop -R app spec --format simple\n    - bundle exec rubycritic --path ./analysis --minimum-score 80 --no-browser\n  setup_db:\n    - bundle exec rails db:create\n    - bundle exec rails db:schema:load\n  test:\n    - bundle exec rspec\n  security:\n    - bundle exec brakeman --exit-on-error\n  audit:\n    - bundle audit check --update\n\n\nenvironment:\n  RAILS_ENV: test\n  GIT_COMMITTER_NAME: a\n  GIT_COMMITTER_EMAIL: b\n  LANG: C.UTF-8</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>and builds the Jenkinsfile to get your job running on the fly.</p>\n</div>\n<div class=\"paragraph\">\n<p>The nice part about having a shared library is that we can extend and\nfix our library in a centralized way. Once we add new code, the library\nis automatically updated in Jenkins which will notify all of our jobs\nwith the update.</p>\n</div>\n<div class=\"paragraph\">\n<p>Since we have projects in different languages we use Docker to build the\ntesting environment. WoloxCI assumes there is a Dockerfile to build and\nwill run all the specified commands inside the container.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"woloxci-config-yml\"><a class=\"anchor\" href=\"#woloxci-config-yml\"></a>Woloxci config.yml</h3>\n<div class=\"sect3\">\n<h4 id=\"config\"><a class=\"anchor\" href=\"#config\"></a>Config</h4>\n<div class=\"paragraph\">\n<p>The first part of the config.yml file specifies some basic\nconfiguration: project’s name and Dockerfile location. The Dockerfile is\nused to build the image where the commands will be run.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"services\"><a class=\"anchor\" href=\"#services\"></a>Services</h4>\n<div class=\"paragraph\">\n<p>This section describes which services will be exposed to the container.\nOut of the box, WoloxCI has support for <em>postgresql</em>, <em>mssql</em> and\n<em>redis</em>. You can also specify the docker image version you want! It is\nnot hard to add a new service. You just need to add the corresponding\nfile at</p>\n</div>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/Wolox/wolox-ci/tree/development/vars\" class=\"bare\">https://github.com/Wolox/wolox-ci/tree/development/vars</a></p>\n</div>\n<div class=\"paragraph\">\n<p>and modify how the services are parsed</p>\n</div>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/Wolox/wolox-ci/blob/development/src/com/wolox/parser/ConfigParser.groovy#L76\" class=\"bare\">https://github.com/Wolox/wolox-ci/blob/development/src/com/wolox/parser/ConfigParser.groovy#L76</a></p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"steps\"><a class=\"anchor\" href=\"#steps\"></a>Steps</h4>\n<div class=\"paragraph\">\n<p>The listed commands in this section will run inside the Docker\ncontainer. As a result, you’ll see each of the steps on the Jenkins UI.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"https://cdn-images-1.medium.com/max/2000/0*SlHf1JHAAvEvZQ74.\" alt=\"image\"></span></p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"environment\"><a class=\"anchor\" href=\"#environment\"></a>Environment</h4>\n<div class=\"paragraph\">\n<p>If you need some environment variables during your build, you can\nspecify them here. Whatever variable you set will be available inside\nthe Docker container when your commands listed in the <strong>steps</strong> section\ndescribed above.</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"wrapping-up\"><a class=\"anchor\" href=\"#wrapping-up\"></a>Wrapping up</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>WoloxCI is still being tested with a not-so-small sample of our\nprojects. The possibility of changing the build steps through a YAML\nfile makes it accessible for everyone and that is a great improvement in\nour CI workflow.</p>\n</div>\n<div class=\"paragraph\">\n<p>Docker gives us the possibility of easily changing the programming\nlanguage without making any changes to our Jenkins installation and\nJenkins’ Github Organization feature automatically adds new projects\nwhen a new repository with a Jenkinsfile is detected.</p>\n</div>\n<div class=\"paragraph\">\n<p>All of these improvements have reduced the time we spend maintaining\nJenkins significantly and give us the possibility of easily scaling\nwithout any extra configuration.</p>\n</div>\n<div class=\"paragraph\">\n<p>This library is working in our CI but it still can be improved.\nIf you would like to add features, feel free to\n<a href=\"https://github.com/Wolox/wolox-ci\">contribute</a>!</p>\n</div>\n</div>\n</div>","id":"e34fdb6b-09c7-5772-a251-10cec0ccef26","title":"Configuring a Jenkins Pipeline using a YAML file","date":"2018-04-25T00:00:00.000Z","slug":"/blog/2018/04/25/configuring-jenkins-pipeline-with-yaml-file/","links":{"discourse":""},"authors":[{"avatar":null,"blog":null,"github":"mdesanti","html":"<div class=\"paragraph\">\n<p>Head of Infrastructure &amp; Cloud at <a href=\"https://www.wolox.com.ar\">Wolox</a></p>\n</div>","id":"mdesanti","irc":null,"linkedin":null,"name":"Matias De Santi","slug":"/blog/authors/mdesanti/","twitter":"mdsanti"}]}},"pageContext":{"id":"e34fdb6b-09c7-5772-a251-10cec0ccef26"}},
    "staticQueryHashes": ["1271460761","3649515864"]}