{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2018/07/02/whats-new-declarative-piepline-13x-sequential-stages/",
    "result": {"data":{"blog":{"html":"<div class=\"paragraph\">\n<p>We recently released version 1.3 of Declarative Pipelines, which includes a couple significant new features. We&#8217;re\ngoing to cover these features in separate blog posts. The next post will show the new ability to restart a completed\nPipeline run starting from a stage partway through the Pipeline, but first, let&#8217;s look at the new sequential stages\nfeature.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"sequential-stages\"><a class=\"anchor\" href=\"#sequential-stages\"></a>Sequential Stages</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In Declarative 1.2, we added <a href=\"/doc/book/pipeline/syntax#parallel\">the ability to define stages to run in parallel</a>\nas part of the Declarative syntax. Now in Declarative 1.3, we&#8217;ve added another way to specify stages nested within other\nstages, which we&#8217;re calling \"sequential stages\".</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"running-multiple-stages-in-a-parallel-branch\"><a class=\"anchor\" href=\"#running-multiple-stages-in-a-parallel-branch\"></a>Running Multiple Stages in a Parallel Branch</h3>\n<div class=\"paragraph\">\n<p>One common use case is running build and tests on multiple platforms. You could already do that with <code>parallel</code> stages,\nbut now you can run multiple stages in each <code>parallel</code> branch giving you more visibility into the progress of your\nPipeline without having to check the logs to see exactly which step is currently running where, etc.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/images/post-images/2018-07-02/sequential_stages.png\" alt=\"sequential stages\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>You can also\nuse stage directives, including <code>post</code>, <code>when</code>, <code>agent</code>, and all the others covered in the\n<a href=\"/doc/book/pipeline/syntax\">Pipeline Syntax reference</a>\nin your sequential stages, letting you control behavior for different parts of each <code>parallel</code> branch.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the example below, we are running builds on both Windows and Linux, but only want to deploy if we&#8217;re on the master branch.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n    agent none\n\n    stages {\n        stage(\"build and deploy on Windows and Linux\") {\n            parallel {\n                stage(\"windows\") {\n                    agent {\n                        label \"windows\"\n                    }\n                    stages {\n                        stage(\"build\") {\n                            steps {\n                                bat \"run-build.bat\"\n                            }\n                        }\n                        stage(\"deploy\") {\n                            when {\n                                branch \"master\"\n                            }\n                            steps {\n                                bat \"run-deploy.bat\"\n                            }\n                        }\n                    }\n                }\n\n                stage(\"linux\") {\n                    agent {\n                        label \"linux\"\n                    }\n                    stages {\n                        stage(\"build\") {\n                            steps {\n                                sh \"./run-build.sh\"\n                            }\n                        }\n                        stage(\"deploy\") {\n                             when {\n                                 branch \"master\"\n                             }\n                             steps {\n                                sh \"./run-deploy.sh\"\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"running-multiple-stages-with-the-same-agent-or-environment-or-options\"><a class=\"anchor\" href=\"#running-multiple-stages-with-the-same-agent-or-environment-or-options\"></a>Running Multiple Stages with the Same <code>agent</code>, or <code>environment</code>, or <code>options</code></h3>\n<div class=\"paragraph\">\n<p>While the sequential stages feature was originally driven by users wanting to have multiple stages in <code>parallel</code> branches,\nwe&#8217;ve found that being able to group multiple stages together with the same <code>agent</code>, <code>environment</code>, <code>when</code>, etc has a lot\nof other uses. For example, if you are using multiple agents in your Pipeline, but would like to be sure that stages using\nthe same agent use the same workspace, you can use a parent <code>stage</code> with an <code>agent</code> directive on it, and then all the stages\ninside its <code>stages</code> directive will run on the same executor, in the same workspace. Another example is that until now, you\ncould only set a timeout for the entire Pipeline or an individual stage. But by using a parent <code>stage</code> with nested <code>stages</code>,\nyou can define a timeout in the parent&#8217;s <code>options</code> directive, and that timeout will be applied for the execution of the\nparent, including its nested stages. You may also want to conditionally control the execution of multiple stages. For example,\nyour deployment process may be spread across multiple stages, and you don&#8217;t want to run any of those stages unless you&#8217;re on\na certain branch or some other criteria is satisified. Now you can group all those related stages together in a parent\n<code>stage</code>, within its <code>stages</code> directive, and have a single <code>when</code> condition on that parent, rather than having to copy an\nidentical <code>when</code> condition to each of the relevant stages.</p>\n</div>\n<div class=\"paragraph\">\n<p>One of my favorite use cases is shown in the example below. In Declarative 1.2.6, we added the <code>input</code> directive for stages.\nThis will pause the execution of the Pipeline until a user confirms that the Pipeline should continue, using the Scripted\nPipeline <code>input</code> step. The <code>input</code> directive is evaluated before the stage enters its agent, if it has one specified, and\nbefore the stage&#8217;s <code>when</code> condition, if specified, is evaluated. But if you&#8217;re using a top-level agent for most of your\nstages, you&#8217;re still going to be using that agent&#8217;s executor while waiting for input, which can be a waste of resources.\nWith sequential stages, you can instead use <code>agent none</code> at the top-level of the Pipeline, and group the stages using a common\nagent and running before the stage with the <code>input</code> directive together under a parent <code>stage</code> with the required <code>agent</code>\nspecified. Then, when your Pipeline reaches the stage with <code>input</code>, it will no longer be using an agent&#8217;s executor.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n    agent none\n\n    stages {\n        stage(\"build and test the project\") {\n            agent {\n                docker \"our-build-tools-image\"\n            }\n            stages {\n               stage(\"build\") {\n                   steps {\n                       sh \"./build.sh\"\n                   }\n               }\n               stage(\"test\") {\n                   steps {\n                       sh \"./test.sh\"\n                   }\n               }\n            }\n            post {\n                success {\n                    stash name: \"artifacts\", includes: \"artifacts/**/*\"\n                }\n            }\n        }\n\n        stage(\"deploy the artifacts if a user confirms\") {\n            input {\n                message \"Should we deploy the project?\"\n            }\n            agent {\n                docker \"our-deploy-tools-image\"\n            }\n            steps {\n                sh \"./deploy.sh\"\n            }\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>These are just a few example of the power of the new sequential stages feature in Declarative 1.3.\nThis new feature adds another set of significant use cases that can be handled smoothly using Declarative Pipeline.\nIn my next post, I&#8217;ll show the another highly requested feature - the new ability to restart a Pipeline run from any stage in that Pipeline.</p>\n</div>\n</div>\n</div>\n</div>","id":"44cd4bd6-4c8f-5fdd-8f54-c99da078882e","title":"What's New in Declarative Pipeline 1.3: Sequential Stages","date":"2018-07-02T00:00:00.000Z","slug":"/blog/2018/07/02/whats-new-declarative-piepline-13x-sequential-stages/","links":{"discourse":""},"authors":[]}},"pageContext":{"next":"/blog/2018/07/05/remoting-over-message-bus-alpha-release/","previous":"/blog/2018/07/02/new-api-token-system/","id":"44cd4bd6-4c8f-5fdd-8f54-c99da078882e"}},
    "staticQueryHashes": ["1271460761","3649515864"]}