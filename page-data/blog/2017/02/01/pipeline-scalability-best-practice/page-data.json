{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2017/02/01/pipeline-scalability-best-practice/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This is a guest post by <a href=\"https://github.com/svanoort\">Sam Van Oort</a>,\nSoftware Engineer at <a href=\"https://cloudbees.com\">CloudBees</a> and contributor to\nthe Jenkins project.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Today I&#8217;m going to show you best practices to write scalable and robust Jenkins Pipelines. This is drawn from a\ncombination of work with the internals of Pipeline and observations with large-scale users.</p>\n</div>\n<div class=\"paragraph\">\n<p>Pipeline code works beautifully for its intended role of automating\nbuild/test/deploy/administer tasks.  As it is pressed into more complex roles\nand unanticipated uses, some users hit issues.  In these cases, applying the\nbest practices can make the difference between:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>A single controller running\n<a href=\"https://www.cloudbees.com/so-you-want-build-worlds-biggest-jenkins-cluster\">hundreds\nof concurrent builds</a> on low end hardware (4 CPU cores and 4 GB of\nheap)</p>\n</li>\n<li>\n<p>Running a couple dozen builds and bringing a controller to its knees or\ncrashing it&#8230;&#8203;even with 16+ CPU cores and 20+ GB of heap!</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This has been seen in the wild.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"fundamentals\"><a class=\"anchor\" href=\"#fundamentals\"></a>Fundamentals</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To understand Pipeline behavior you must understand a few points about\nhow it executes.</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Except for the steps themselves, all of the Pipeline logic, the Groovy conditionals, loops, etc execute on the controller. Whether simple <em>or</em> complex! Even inside a <code>node</code> block!</p>\n</li>\n<li>\n<p><em>Steps</em> may use executors to do work where appropriate, but each\nstep has a small on-controller overhead too.</p>\n</li>\n<li>\n<p>Pipeline code is written as Groovy but the execution model is\nradically transformed at compile-time to Continuation Passing Style\n(CPS).</p>\n</li>\n<li>\n<p>This transformation provides valuable safety and durability\nguarantees for Pipelines, but it comes with trade-offs:</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Steps can invoke Java and execute fast and efficiently, but Groovy\nis <em>much</em> slower to run than normal.</p>\n</li>\n<li>\n<p>Groovy logic requires far more memory, because an object-based\nsyntax/block tree is kept in memory.<br></p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p>Pipelines persist the program and its state frequently to be able to\nsurvive failure of the controller.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>From these we arrive at a set of best practices to make pipelines more\neffective.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"best-practices-for-Pipeline-code\"><a class=\"anchor\" href=\"#best-practices-for-Pipeline-code\"></a>Best Practices For Pipeline Code</h2>\n<div class=\"sectionbody\">\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><strong>Think of Pipeline code as glue:</strong> just enough Groovy code to connect\ntogether the Pipeline steps and integrate tools, and no more.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>This makes code easier to maintain, more robust against bugs, and\nreduces load on controllers.</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Keep it simple:</strong> limit the amount of complex logic embedded in the\nPipeline itself (similarly to a shell script) and avoid treating it as a\ngeneral-purpose programming language.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Pipeline restricts all variables to <code>Serializable</code> types, so keeping\nPipeline logic simple helps avoid a <code>NotSerializableException</code> - see\nappendix at the bottom.</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Use <code>@NonCPS</code>-annotated functions for slightly more complex work.</strong>\nThis means more involved processing, logic, and transformations. This\nlets you leverage additional Groovy &amp; functional features for more\npowerful, concise, and performant code.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>This still runs on controllers so be mindful of complexity, but is much\nfaster than native Pipeline code because it doesn’t provide durability\nand uses a faster execution model. Still, be mindful of the CPU cost and\noffload to executors for complex work (see below).</p>\n</li>\n<li>\n<p><code>@NonCPS</code> functions can use a much broader subset of the Groovy\nlanguage, such as iterators and functional features, which makes them\nmore terse and fast to write.</p>\n</li>\n<li>\n<p><code>@NonCPS</code> functions should not use Pipeline steps internally, however\nyou can store the result of a Pipeline step to a variable and use it\nthat as the input to a <code>@NonCPS</code> function.</p>\n<div class=\"olist lowerroman\">\n<ol class=\"lowerroman\" type=\"i\">\n<li>\n<p><strong>Gotcha:</strong> It’s not guaranteed that use of a step will generate an\nerror (there is an open RFE to implement that), but you should not rely\non that behavior. You may see improper handling of exceptions, in\nparticular.</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p>While normal Pipeline is restricted to serializable local variables\n(see appendix at bottom), <code>@NonCPS</code> functions can use more complex,\nnonserializable types internally (for example regex matchers, etc). Parameters\nand return types should still be Serializable, however.</p>\n<div class=\"olist lowerroman\">\n<ol class=\"lowerroman\" type=\"i\">\n<li>\n<p><strong>Gotcha:</strong> improper usages are not guaranteed to raise an error with\nnormal Pipeline (optimizations may mask the issue), but it is unsafe to\nrely on this behavior.</p>\n</li>\n</ol>\n</div>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Prefer external scripts/tools for complex or CPU-expensive\nprocessing</strong> rather than Groovy language features. This offloads work\nfrom the controller to external executors, allowing for easy scale-out of\nhardware resources. It is also generally easier to test because these\ncomponents can be tested in isolation without the full on-controller\nexecution environment.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Many software vendors will provide easy command-line clients for\ntheir tools in various programming languages. These are often robust,\nperformant, and easy to use. Plugins offer another option (see below).</p>\n</li>\n<li>\n<p>Shell or batch steps are often the easiest way to integrate these\ntools, which can be written in any language. For example: <code>sh “java -jar\nclient.jar $endPointUrl $inputData”</code> for a Java client, or <code>sh “python\njiraClient.py $issueId $someParam”</code> for a Python client.<br></p>\n</li>\n<li>\n<p><strong>Gotcha: especially avoid Pipeline XML or JSON parsing using Groovy&#8217;s <code>XmlSlurper</code> and <code>JsonSlurper</code>!  Strongly prefer command-line tools or scripts.</strong></p>\n<div class=\"olist lowerroman\">\n<ol class=\"lowerroman\" type=\"i\">\n<li>\n<p>The Groovy implementations are complex and as a result more brittle in Pipeline use.</p>\n</li>\n<li>\n<p><code>XmlSlurper</code> and <code>JsonSlurper</code> can carry a high memory and CPU cost in pipelines</p>\n</li>\n<li>\n<p>xmllint and xmlstartlet are command-line tools offering XML extraction via xpath</p>\n</li>\n<li>\n<p><a href=\"https://stedolan.github.io/jq/\">jq</a> offers the same functionality for JSON</p>\n</li>\n<li>\n<p>These extraction tools may be coupled to curl or wget for fetching information from an HTTP API</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p>Examples of other places to use command-line tools:</p>\n<div class=\"olist lowerroman\">\n<ol class=\"lowerroman\" type=\"i\">\n<li>\n<p>Templating large files</p>\n</li>\n<li>\n<p>Nontrivial integration with external APIs (for bigger vendors,\nconsider a Jenkins plugin if a quality offering exists)</p>\n</li>\n<li>\n<p>Simulations/complex calculations</p>\n</li>\n<li>\n<p>Business logic</p>\n</li>\n</ol>\n</div>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Consider existing plugins for external integrations.</strong> Jenkins has a\nwealth of plugins, especially for source control, artifact management,\ndeployment systems, and systems automation. These can greatly reduce the\namount of Pipeline code to maintain. Well-written plugins may be\nfaster and more robust than Pipeline equivalents.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Consider both plugins and command-line clients (above)&#8201;&#8212;&#8201;one may be\neasier than the other.</p>\n</li>\n<li>\n<p>Plugins may be of widely varying quality. Look at the number of installations and how frequently and recently updates appear in the changelog. Poorly-maintained plugins\nwith limited installations may actually be worse than writing a little\ncustom Pipeline code.</p>\n</li>\n<li>\n<p>As a last resort, if there is a good-quality plugin that is not\nPipeline-enabled, it is <a href=\"/blog/2016/05/25/update-plugin-for-pipeline/\">fairly easy to write a Pipeline wrapper</a> to\nintegrate it or write a custom step that will invoke it.</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>Assume things will go wrong:</strong> don’t rely on workspaces being clean\nof the remnants from previous executions, clean explicitly where needed.\nMake use of timeouts and retry steps (that’s what they’re there for).</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>Within a git repository, <code>git clean -fdx</code> is a good way to\naccomplish this and reduces the amount of SCM cloning</p>\n</li>\n</ol>\n</div>\n</li>\n<li>\n<p><strong>DO use parameterized Pipelines and variables to make your Pipeline\nscripts more reusable.</strong> Passing in parameters is especially helpful for\nhandling different environments and should be preferred to applying\nconditional lookup logic; however, try to limit parameterized pipelines invoking each other.</p>\n</li>\n<li>\n<p><strong>Try to limit business logic embedded in Pipelines.</strong> To some extent\nthis is inevitable, but try to focus on tasks to complete instead,\nbecause this yields more maintainable, reusable, and often more\nperformant Pipeline code.</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>One code smell that points to a problem is many hard-coded\nconstants. Consider taking advantage of the options above to refactor\ncode for better composability.</p>\n</li>\n<li>\n<p>For complex cases, consider using Jenkins integration options\n(plugins, Jenkins API calls, invoking input steps externally) to offload\nimplementation of more complex business rules to an external system if\nthey fit more naturally there.</p>\n</li>\n</ol>\n</div>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Please, think of these as guidelines, not strict rules – Jenkins\nPipeline provides a great deal of power and flexibility, and it&#8217;s there\nto be used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Breaking enough of these rules at scale can cause controllers to fail by\nplacing an unsustainable load on them.</p>\n</div>\n<div class=\"paragraph\">\n<p>For additional guidance, I also recommend\n<a href=\"https://www.cloudbees.com/need-speed-building-Pipelines-be-faster\">this\nJenkins World talk</a>\non how to engineer Pipelines for speed and performance:</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"appendix-serializable-vs.-non-serializable-types\"><a class=\"anchor\" href=\"#appendix-serializable-vs.-non-serializable-types\"></a>Appendix: Serializable vs. Non-Serializable Types:</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To assist with Pipeline development, here are common serializable and\nnon-serializable types, to assist with deciding if your logic can be CPS\nor should be in a <code>@NonCPS</code> function to avoid issues.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Common Serializable Types (safe everywhere):</strong></p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>All primitive types and their object wrappers: byte, boolean, int,\ndouble, short, char</p>\n</li>\n<li>\n<p>Strings</p>\n</li>\n<li>\n<p>enums</p>\n</li>\n<li>\n<p>Arrays of serializable types</p>\n</li>\n<li>\n<p>ArrayLists and normal Groovy Lists</p>\n</li>\n<li>\n<p>Sets: HashSet</p>\n</li>\n<li>\n<p>Maps: normal Groovy Map, HashMap, TreeMap</p>\n</li>\n<li>\n<p>Exceptions</p>\n</li>\n<li>\n<p>URLs</p>\n</li>\n<li>\n<p>Dates</p>\n</li>\n<li>\n<p>Regex Patterns (compiled patterns)</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p><strong>Common non-Serializable Types (only safe in <code>@NonCPS</code> functions):</strong></p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Iterators: this is a common problem. You need to use C-style loop, i.e.\n<code>for(int i=0; i&lt;max; i++){</code></p>\n</li>\n<li>\n<p>Regex Matchers (you can use the\nbuilt-in functions in String, etc, just not the Matcher itself)</p>\n</li>\n<li>\n<p><strong>Important:</strong> <code>JsonObject</code>, <code>JsonSlurper</code>, etc in Groovy 2+ (used in some 2.x+\nversions of Jenkins).</p>\n<div class=\"olist loweralpha\">\n<ol class=\"loweralpha\" type=\"a\">\n<li>\n<p>This is due to an internal implementation change&#8201;&#8212;&#8201;earlier versions may serialize.</p>\n</li>\n</ol>\n</div>\n</li>\n</ol>\n</div>\n</div>\n</div>","id":"aa509c7b-3f24-5cce-8519-dda84cd1233e","title":"Best Practices for Scalable Pipeline Code","date":"2017-02-01T00:00:00.000Z","slug":"/blog/2017/02/01/pipeline-scalability-best-practice/","links":{"discourse":""},"authors":[{"avatar":null,"blog":null,"github":"svanoort","html":"","id":"svanoort","irc":null,"linkedin":null,"name":"Sam Van Oort","slug":"/blog/author/svanoort","twitter":null}]}},"pageContext":{"next":"/blog/2017/02/01/security-updates/","previous":"/blog/2017/01/27/blueocean-dev-log-jan4/","id":"aa509c7b-3f24-5cce-8519-dda84cd1233e"}},
    "staticQueryHashes": ["1271460761","3649515864"]}