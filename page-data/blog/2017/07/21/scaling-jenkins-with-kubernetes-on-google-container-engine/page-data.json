{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2017/07/21/scaling-jenkins-with-kubernetes-on-google-container-engine/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\nThis is a guest post by Guillaume Laforge,\nDeveloper Advocate for <a href=\"https://cloud.google.com/\">Google Cloud</a>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Last week, I had the pleasure to speak at the\n<a href=\"https://jcd-paris.jfrog.com/\">Jenkins Community Day conference</a>, in Paris,\norganized by my friends from <a href=\"https://www.jfrog.com/\">JFrog</a>,\nprovider of awesome tools for software management and distribution.\nI covered how to scale Jenkins with <a href=\"https://kubernetes.io/\">Kubernetes</a> on\n<a href=\"https://cloud.google.com/container-engine/\">Google Container Engine</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>For the impatient, here are the slides of the presentation I’ve given:</p>\n</div>\n<div class=\"imageblock\">\n<div class=\"content\">\n<a class=\"image\" href=\"https://speakerdeck.com/glaforge/scaling-jenkins-with-kubernetes-on-google-container-engine\"><img src=\"/images/post-images/jenkins-k8s-gke.png\" alt=\"Scaling Jenkins with Kubernetes on Google Container Engine\" width=\"500\"></a>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>But let’s step back a little. In this article, I’d like to share with you why you would want to run Jenkins in the cloud,\nas well as give you some pointers to interesting resources on the topic.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"why-running-jenkins-in-the-cloud\"><a class=\"anchor\" href=\"#why-running-jenkins-in-the-cloud\"></a>Why running Jenkins in the cloud?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>So why running Jenkins in the cloud? First of all, imagine your small team, working on a single project.\nYou have your own little server, running under a desk somewhere, happily building your application on each commit,\na few times a day. So far so good, your build machine running Jenkins isn’t too busy, and stays idle most of the day.</p>\n</div>\n<div class=\"paragraph\">\n<p>Let’s do some bottom of the napkin calculations. Let’s say you have a team of 3 developers,\ncommitting roughly 4 times a day, on one single project, and the build takes roughly 10 minutes to go.</p>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">3 developers * 4 commits / day / developer * 10 minutes build time * 1 project = 1 hour 20 minutes</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>So far so good, your server indeed stays idle most of the day. Usually, at most,\nyour developers will wait just 10 minutes to see the result of their work.</p>\n</div>\n<div class=\"paragraph\">\n<p>But your team is growing to 10 persons, the team is still as productive, but the project becoming bigger,\nthe build time goes up to 15 minutes:</p>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">10 developers * 4 commits / day / developer * 15 minutes build time * 1 project = 10 hours</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You’re already at 10 hours build time, so your server is busy the whole day, and at times,\nyou might have several build going on at the same time, using several CPU cores in parallel.\nAnd instead of building in 15 minutes, sometimes, the build might take longer, or your build might be queued.\nSo in theory, it might be 15 minutes, but in practice, it could be half an hour because of the length of the queue\nor the longer time to build parallel projects.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now, the company is successful, and has two projects instead of one (think a backend and a mobile app).\nYour teams grow further up to 20 developers per project. The developers are a little less productive\nbecause of the size of the codebase and project, so they only commit 3 times a day.\nThe build takes more time too, at 20 minutes (in ideal time). Let’s do some math again:</p>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">20 developers * 3 commits / day / developer * 20 minutes build time * 2 projects = 40 hours</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Woh, that’s already 40 hours of total build time, if all the builds are run serially.\nFortunately, our server is multi-core, but still, there are certainly already many builds that are enqueued,\nand many of them, perhaps up to 2-3 or perhaps even 4 could be run in parallel.\nBut as we said, the build queue increases further, the real effective time of build is certainly longer than 30 minutes.\nPerhaps at times, developers won’t see the result of their developments before at least an hour, if not more.</p>\n</div>\n<div class=\"paragraph\">\n<p>One last calculation? With team sizes of 30 developers, decreased productivity of 2 commits, 25 build time,\nand 3 projects? And you’ll get 75 hours total build time. You may start creating a little build farm,\nwith a controller and several build agents. But you also increase the burden of server management.\nAlso, if you move towards a full Continuous Delivery or Continuous Deployment approach,\nyou may further increase your build times to go up to deployment, make more but smaller commits, etc.\nYou could think of running builds less often, or even on a nightly basis, to cope with the demand, but then,\nyour company is less agile, and the time-to-market for fixes of new features might increase,\nand your developers may also become more frustrated because they are developing in the blind,\nnot knowing before the next day if their work was successful or not.</p>\n</div>\n<div class=\"paragraph\">\n<p>With my calculations, you might think that it makes more sense for big companies, with tons of projects and developers.\nThis is quite true, but when you’re a startup, you also want to avoid taking care of local server management,\nprovisioning, etc. You want to be agile, and use only compute resources you need for the time you need them.\nSo even if you’re a small startup, a small team, it might still make sense to take advantage of the cloud.\nYou pay only for the actual time taken by your builds as the build agent containers are automatically provisioned\nand decommissioned. The builds can scale up via Kubernetes, as you need more (or less) CPU time for building everything.</p>\n</div>\n<div class=\"paragraph\">\n<p>And this is why I was happy to dive into scaling Jenkins in the cloud. For that purpose,\nI decided to go with building with containers, with Kubernetes, as my app was also containerized as well.\nGoogle Cloud offers Container Engine, which is basically just Kubernetes in the cloud.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"useful-pointers\"><a class=\"anchor\" href=\"#useful-pointers\"></a>Useful pointers</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>I based my presentation and demo on some great solutions that are published on the Google Cloud documentation portal.\nLet me give you some pointers.</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://cloud.google.com/solutions/jenkins-on-container-engine\">Overview of Jenkins on Container Engine</a></p>\n</li>\n<li>\n<p><a href=\"https://cloud.google.com/solutions/jenkins-on-container-engine-tutorial\">Setting up Jenkins on Container Engine</a></p>\n</li>\n<li>\n<p><a href=\"https://cloud.google.com/solutions/configuring-jenkins-container-engine\">Configuring Jenkins for Container Engine</a></p>\n</li>\n<li>\n<p><a href=\"https://cloud.google.com/solutions/continuous-delivery-jenkins-container-engine\">Continuous Deployment to Container Engine using Jenkins</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes\">Lab: Build a Continuous Deployment Pipeline with Jenkins and Kubernetes</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The latter one is the tutorial I actually followed for the demo that I presented during the conference.\nIt’s a simple Go application, with a frontend and backend.\nIt’s continuously build, on each commit (well, every minute to check if there’s a new commit),\nand deployed automatically in different environments: dev, canary, production.\nThe sources of the project are stored in Cloud Source Repository (it can be mirrored from Github, for example).\nThe containers are stored in Cloud Container Registry.\nAnd both the Jenkins controller and agents, as well as the application are running inside Kubernetes clusters in Container Engine.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"summary-and-perspective\"><a class=\"anchor\" href=\"#summary-and-perspective\"></a>Summary and perspective</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Don’t bother with managing servers! Quickly, you’ll run out of CPU cycles,\nand you’ll have happier developers with builds that are super snappy!</p>\n</div>\n<div class=\"paragraph\">\n<p>And for the record, at Google, dev teams are also running Jenkins!\nThere was a presentation (<a href=\"https://www.youtube.com/watch?v=7ERV9C20GSE\">video</a> and\n<a href=\"https://www.cloudbees.com/sites/default/files/2016-jenkins-world-jenkins_inside_google.pdf\">slides</a>\navailable) given last year by David Hoover at Jenkins World\ntalking about how developers inside Google are running hundreds of build agents to build projects on various platforms.</p>\n</div>\n</div>\n</div>","id":"215b578b-be74-5ce1-b9f3-38b9bfc35f5c","title":"Scaling Jenkins with Kubernetes on Google Container Engine","date":"2017-07-21T00:00:00.000Z","slug":"/blog/2017/07/21/scaling-jenkins-with-kubernetes-on-google-container-engine/","links":{"discourse":""},"authors":[]}},"pageContext":{"next":"/blog/2017/07/26/powershell-pipeline/","previous":"/blog/2017/07/17/speaker-blog-care/","id":"215b578b-be74-5ce1-b9f3-38b9bfc35f5c"}},
    "staticQueryHashes": ["1271460761","3649515864"]}