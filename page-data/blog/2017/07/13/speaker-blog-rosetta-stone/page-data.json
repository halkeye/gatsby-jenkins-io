{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2017/07/13/speaker-blog-rosetta-stone/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\nThis is a guest post by Kevin Burnett, DevOps Lead at\n<a href=\"https://rosettastone.com\">Rosetta Stone</a>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Have you experienced that thing where you make a change in an app, and when you\ngo to check on the results of the build, you find an error that really doesn&#8217;t\nseem relevant to your change? And then you notice that your build is the first\nin over a year. And then you realize that you have accidentally become the\nsubject matter expert in this app.</p>\n</div>\n<div class=\"paragraph\">\n<p>You have no clue what change caused this failure or when that change occurred.\nDid one Jenkins agent become a\n<a href=\"https://martinfowler.com/bliki/SnowflakeServer.html\">snowflake server</a>,\naccruing cruft on the file system that is not cleaned up before each build?\nDid some unpinned external dependency upgrade in a backwards-incompatible fashion?\nDid the credentials the build plan was using to connect to source control get rotated?\nDid a dependent system go offline?\nOr - and I realize that this is unthinkable - did you legitimately break a test?</p>\n</div>\n<div class=\"paragraph\">\n<p>Not only is this type of archaeological expedition often a bad time for the\nperson who happened to commit to this app (\"No good deed goes unpunished\"), but\nit&#8217;s also unnecessary. There&#8217;s a simple way to reduce the cognitive load it\ntakes to connect cause and effect: <strong>build more frequently</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>One way we achieve this is by writing scripts to maintain our apps. When we\nbuild, the goal is that an equivalent artifact should be produced unless there\nwas a change to the app in source control. As such, we pin all of our\ndependencies to specific versions. But we also don&#8217;t want to languish on old\nversions of dependencies, whether internal or external. So we also have an\n<code>auto-maintain</code> script that bumps all of these versions and commits the result.</p>\n</div>\n<div class=\"paragraph\">\n<p>I&#8217;ll give an example. We use docker to build and deploy our apps, and each app\ndepends on a base image that we host in a docker registry. So a <code>Dockerfile</code> in\none of our apps would have a line like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>FROM our.registry.example.com/rosettastone/sweet-repo:jenkins-awesome-project-sweet-repo-5</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We build our base images in Jenkins and tag them with the Jenkins <code>$BUILD_TAG</code>,\nso this app is using build 5 of the <code>rosettastone/sweet-repo</code> base image.\nLet&#8217;s say we updated our <code>sweet-repo</code> base image to use ubuntu 16.04 instead of 14.04\nand this resulted in build 6 of the base image. Our auto-maintain script takes\ncare of upgrading an app that uses this base image to the most recent version.\nThe steps in the auto-maintain script look like this:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Figure out what base image tag you&#8217;re using.</p>\n</li>\n<li>\n<p>Find the newest version of that base image tag by querying the docker registry.</p>\n</li>\n<li>\n<p>If necessary, update the <code>FROM</code> line in the app&#8217;s <code>Dockerfile</code> to pull in the most recent version.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>We do the same thing with library dependencies.\nIf our <code>Gemfile.lock</code> is referencing an old library, running <code>auto-maintain</code> will update things.\nThe same applies to the <code>Jenkinsfile</code> for each app. If we decide to implement a new policy where we\ndiscard old builds, we update <code>auto-maintain</code> so that it will bring each app into\ncompliance with the policy, by changing, for example, this <code>Jenkinsfile</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Jenkinsfile (Before)</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n  agent { label 'docker' }\n  stages {\n    stage('commit_stage') {\n      steps {\n        sh('./bin/ci')\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>to this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Jenkinsfile (After)</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n  agent { label 'docker' }\n  options {\n    buildDiscarder(logRotator(numToKeepStr: '100'))\n  }\n  stages {\n    stage('commit_stage') {\n      steps {\n        sh('./bin/ci')\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>We try to account for these sorts of things (everything that we can) in our\n<code>auto-maintain</code> script rather than updating apps manually, since this reduces the\nfriction in keeping apps standardized.</p>\n</div>\n<div class=\"paragraph\">\n<p>Once you create an <code>auto-maintain</code> script (start small), you just have to run it.\nWe run ours based on both \"actions\" and \"non-actions.\" When an internal library\nchanges, we kick off app builds, so a library&#8217;s <code>Jenkinsfile</code> might look like\nthis:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Jenkinsfile</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n  agent { label 'docker' }\n  stages {\n    stage('commit_stage') {\n      steps {\n        sh('./bin/ci')\n      }\n    }\n    stage('auto_maintain_things_that_might_be_using_me') {\n      steps {\n        build('hot-project/auto-maintain-all-apps/master')\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When <code>auto-maintain</code> updates something in an app, we have it commit the change\nback to the app, which in turn triggers a build of that app, and&#8212;&#8203;if all is\nwell&#8212;&#8203;a production deployment.</p>\n</div>\n<div class=\"paragraph\">\n<p>The only missing link then for avoiding one-year build droughts is to get around\nthe problem where <code>auto-maintain</code> isn&#8217;t actually updating anything in a certain app.\nIf no dependencies are changing, or if the technology in question is not\nreceiving much attention, <code>auto-maintain</code> might not do anything for an\nextended period of time, even if the script is run on a schedule using\n<a href=\"https://en.wikipedia.org/wiki/Cron\"><code>cron</code></a>. For those cases, putting\na <code>cron</code> trigger in the Pipeline for each app will ensure that builds still happen periodically:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Jenkinsfile</div>\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">pipeline {\n  agent { label 'docker' }\n  triggers {\n    cron('@weekly')\n  }\n  stages {\n    stage('commit_stage') {\n      steps {\n        sh('./bin/ci')\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In most cases, these periodic builds won&#8217;t do anything different from the last\nbuild, but when something does break, this strategy will allow you to decide\nwhen you find out about it (by making your cron <code>@weekly</code>, <code>@daily</code>, etc)\ninstead of letting some poor developer find out about it when they do\nsomething silly like commit code to an infrequently-modified app.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-warning\" title=\"Warning\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>Kevin will be\n<a href=\"https://jenkinsworld20162017.sched.com/event/AK3m/how-we-do-devops-at-rosetta-stone\">presenting</a>\nmore on this topic at\n<a href=\"https://www.cloudbees.com/jenkinsworld/home\">Jenkins World</a> in August,\nregister with the code <code>JWFOSS</code> for a 30% discount off your pass.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>","id":"00ad337a-5c86-5032-be3e-f6f4934de80d","title":"Automated Software Maintenance","date":"2017-07-13T00:00:00.000Z","slug":"/blog/2017/07/13/speaker-blog-rosetta-stone/","authors":[{"avatar":null,"blog":null,"github":null,"html":"","id":"hinman","irc":null,"linkedin":null,"name":"Hannah Inman","slug":"/blog/authors/hinman/","twitter":null}]}},"pageContext":{"id":"00ad337a-5c86-5032-be3e-f6f4934de80d"}},
    "staticQueryHashes": ["1271460761","3649515864"]}