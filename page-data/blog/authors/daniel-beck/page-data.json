{
    "componentChunkName": "component---src-templates-author-blog-list-template-js",
    "path": "/blog/authors/daniel-beck/",
    "result": {"data":{"author":{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null},"allBlog":{"edges":[{"node":{"date":"2020-11-04T00:00:00.000Z","id":"507874d6-f29d-5e57-82cd-0383757359fc","slug":"/blog/2020/11/04/codeql/","strippedHtml":"A little over a month ago, GitHub announced the general availability of its code scanning solution.\nIt’s based on CodeQL, which makes it pretty easy to write queries for it and run them using the CodeQL GitHub action, CodeQL command line tools, or on lgtm.com.\n\nMany of the security vulnerabilities discovered in Jenkins plugins are fairly similar to each other, and unfortunately they’re usually specific to Jenkins, which means existing generic tools would not be able to discover them.\nSo I decided to write CodeQL queries for Jenkins-specific issues and invited maintainers to sign their plugins up for a \"private beta\" of code scanning for these issues.\n\nToday’s security advisory is the first one that includes findings discovered through that initiative.\nAll these issues were discovered with assistance by this tooling:\n\nSECURITY-2101 in AWS Global Configuration Plugin,\n\nSECURITY-2102 and SECURITY-2103 in Kubernetes Plugin,\n\nSECURITY-2104 and SECURITY-2115 in Mercurial Plugin,\n\nSECURITY-2110 in Azure Key Vault Plugin, and\n\nSECURITY-2126 in Active Directory Plugin\n\nWhile there were of course also false positives we had to review and mark as ignored, the integration with the GitHub UI made this pretty straightforward.\nOverall I’m very happy with the results so far, especially considering how new this initiative is.\n\nInterested in making the plugin you are maintaining more secure?\nSign up now by filing an INFRA issue in the github component and list the plugin repositories you’d like to have scanned.","title":"First results from using GitHub CodeQL to discover security vulnerabilities in Jenkins plugins","tags":["jenkins","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2020-07-15T00:00:00.000Z","id":"ea6acacc-eca1-580a-a013-eb8a8cacca6c","slug":"/blog/2020/07/15/xss-severity/","strippedHtml":"Eagle-eyed readers of today’s security advisory may already have noticed that we consider the cross-site scripting (XSS) vulnerabilities to be 'High' severity.\nThis is a change from previous security advisories, in which similar vulnerabilities got a 'Medium' score.\n\nWe follow the guidelines of CVSS version 3.0 for the severity we assign to these issues.\nTheir examples for XSS vulnerabilities, as well as XSS vulnerabilities in other software, consider the most severe, immediate impact to be a modification of the HTML output, possibly also the extraction of the session cookie (something Jenkins prevents by declaring it to be HttpOnly).\n\nUnfortunately, this does not adequately model the impact that a successful XSS exploitation in Jenkins can have:\nJenkins administrators can perform far more sensitive actions than e.g. the admins of most content management systems could, as it is designed to allow users to execute code to build, test, and deploy their software.\nSo this kind of vulnerability, that allows attackers to do anything their victims have permission to do, in Jenkins can mean execution of arbitrary code, perhaps via the script console, if the victim has the Overall/Administer permission.\nNone of this requires chaining different actions in an attack, a well-chosen XSS payload will accomplish this.\n\nTherefore, starting today, we score XSS vulnerabilities by the highest immediate impact a successful attack can have, which is a complete system compromise if admins can be attacked.\nFor stored XSS requiring some permissions, like the ability to configure jobs, a typical score would be 8.0.\nReflected XSS, which don’t require any permissions to exploit, will usually score 8.8.","title":"Severity of cross-site scripting vulnerabilities","tags":["security","announcement"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2019-05-05T00:00:00.000Z","id":"7783e32b-2866-5124-b6e5-a89740fbfd19","slug":"/blog/2019/05/05/telemetry-success/","strippedHtml":"Half a year ago we delivered a security fix for Jenkins that had the potential to break the entire Jenkins UI.\nWe needed to change how Jenkins, through the Stapler web framework, handled HTTP requests, tightening the rules around what requests would be processed by Jenkins.\nIn the six months since, we didn’t receive notable reports of problems resulting from this change, and it’s thanks to the telemetry we gathered beforehand.\n\nThe Problem\n\nJenkins uses the Stapler web framework for HTTP request handling.\nStapler’s basic premise is that it uses reflective access to code elements matching its naming conventions.\nFor example, any public method whose name starts with get, and that has a String, int, long, or no argument can be invoked this way on objects that are reachable through these means.\nAs these naming conventions closely match common code patterns in Java, accessing crafted URLs could invoke methods never intended to be invoked this way.\n\nA simple example of that is a URL every Jenkins user would be familiar with: /job/jobname.\nThis ends up invoking a method called #getJob(String), with the argument being\"jobname\", on the root application object, and having it handle the rest of the URL, if any.\nOf course, this is a URL intended to be accessed this way.\nHow about invoking Object#getClass(), followed by Class#getClassLoader(), by accessing the URL /class/classLoader?\nWhile this particular chain would not result in a useful response, this doesn’t change that the methods were invoked.\nWe identified a number of URLs that could be abused to access otherwise inaccessible jobs, or even invoke internal methods in the web application server to invalidate all sessions.\nThe security advisory provides an overview of the issues we’d identified by then.\n\nThe Idea\n\nTo solve this problem inherent in the Stapler framework’s design, we defined rules that restrict invocation beyond what would be allowed by Stapler.\nFor example, the declared return type of getters now needed to be one defined in Jenkins core or a Jenkins plugin and have either clearly Stapler-related methods (with Stapler annotations, parameter types, etc.) or Stapler-related resource files associated with it.\nOtherwise, the type wouldn’t be aware of Stapler, and couldn’t produce a meaningful response anyway.\n\nThis meant that getters just declaring Object (or List, Map, etc.) would no longer be allowed by default.\nIt was clear to the developers working on this problem that we needed the ability to be able to override the default rules for specific getters.\nBut allowing plugin developers to adapt their plugins after we published the fix wasn’t going to cut it;\nJenkins needed to ship with a comprehensive default whitelist for methods known to not conform to the new rules, so that updating would not result in problems for users.\n\nThe Solution\n\nWhile there is tooling like Plugin Compatibility Tester and Acceptance Test Harness, many Jenkins plugins do not have comprehensive tests of their UI — the Jenkins UI is fairly stable after all.\nWe did not expect to have sufficient test coverage to deliver a change like this with confidence.\nThe only way we would be able to build such a comprehensive whitelist would be to add telemetry to Jenkins.\n\nWhile Jenkins instances periodically report usage statistics to the Jenkins project, the information included is very bare bones and mostly useful to know the number of installations, the popularity of plugins, and the general size of Jenkins instances through number and types of jobs and agents.\nWe also didn’t want to just collect data without a clear goal, so we set ourselves some limitations — collect as little data as possible, no personally identifiable information, have a specific purpose for each kind of information we would collect, and define an end date for the collection in advance.\nWe defined all of this in JEP-214, created the Uplink service that would receive submissions, and added the basic client framework to Jenkins.\nThe implementation is fairly basic — we just submit an arbitrary JSON object with some added metadata to a service.\nThis system would inform tweaks to a security fix we were anxious to get out, after all.\n\nStarting in mid October for weekly releases, and early November for LTS, tens of thousands of Jenkins instances would submit Stapler request dispatch telemetry daily, and we would keep identifying code incompatible with the new rules and amending the fix.\nUltimately, the whitelist would include a few dozen entries, preventing serious regressions in popular plugins like Credentials Plugin, JUnit Plugin, or the Pipeline plugins suite, down to Google Health Check Plugin, a plugin with just 80 installations when we published the fix.\n\nLearning what requests would result in problems also allowed us to write better developer documentation — we already knew what code patterns would break, and how popular each of them was in the plugin ecosystem.\n\nThe Overhaul\n\nI wrote above:\n\nFor example, the declared return type of getters now needed to be one defined in Jenkins core or a Jenkins plugin and have either clearly Stapler-related methods (with Stapler annotations, parameter types, etc.) or Stapler-related resource files associated with it.\n\nWhile this was true for the fix during most of development, it isn’t how the fix that we published actually works.\nAbout a month before the intended release date, internal design/code review feedback criticized the complicated and time-consuming implementation that at the time required scanning the class path of Jenkins and all plugins and looking for related resources, and suggested a different approach.\n\nSo we tried to require that the declared type or any of its ancestors be annotated with the new annotation @StaplerAccessibleType, annotated a bunch of types in Jenkins itself ( ModelObject being the obvious first choice), and ran our scripts that check to see whether Stapler would be allowed to dispatch methods identified in telemetry.\nWe’d long since automated the daily update of dispatch telemetry processing, so it was a simple matter of changing which Jenkins build we were working with.\n\nAfter a few iterations of adding the annotation to more classes, the results were very positive: Very few additional types needed whitelisting, while many more were no longer (unnecessarily) allowed to be dispatched to.\nThis experiment, late during development, ended up being essentially the fix we delivered.\nWe didn’t need to perform costly scanning of the class path on startup — we didn’t need to scan the class path at all — , and the rules governing request dispatch in Stapler, while different from before, are still pretty easy to understand and independent of how components are packaged.\n\nThe Outcome\n\nAs usual when delivering a fix we expect could result in regressions in plugins, we created a wiki page that users could report problems on.\nRight now, there’s one entry on that wiki page.\nIt is one we were aware of well before release, decided against whitelisting it, and the affected, undocumented feature in Git Plugin ended up being removed.\nThe situation in our issue tracker is only slightly worse, with two apparently minor issues having been reported in Jira.\n\nWithout telemetry, delivering a fix like this one would have been difficult to begin with.\nTinkering with the implementation just a few weeks before release and having any confidence in the result?\nNot causing any significant regressions?\nI think this would simply be impossible.","title":"First successful use of Jenkins telemetry","tags":["core","security","telemetry"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2019-04-03T00:00:00.000Z","id":"1e16c395-d668-5169-973c-ecab9af0f1b0","slug":"/blog/2019/04/03/security-advisory/","strippedHtml":"Today we published a security advisory that mostly informs about issues in Jenkins plugins that have no fixes.\nWhat’s going on?\n\nThe Jenkins security team triages incoming reports both to Jira and our non-public mailing list.\nOnce we’ve determined it is a plugin not maintained by any Jenkins security team members, we try to inform the plugin maintainer about the issue, offering our help in developing, reviewing, and publishing any fixes.\nSometimes the affected plugin is unmaintained, or maintainers don’t respond in a timely manner to the notifications or the followup emails we send.\n\nIn such cases, we publish security advisories informing users about these issues, even if there’s no new release with a fix.\nDoing so allows administrators to make an informed decision about the continued use of plugins with unresolved security vulnerabilities.\nToday’s advisory is overwhelmingly such an advisory.\n\nSee a plugin you love on this list and want to help out? Learn about adopting plugins.","title":"Security spring cleaning","tags":["plugins","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2019-02-21T00:00:00.000Z","id":"ee6f71b5-7195-56bb-8a9e-87e021747a53","slug":"/blog/2019/02/21/credentials-masking/","strippedHtml":"In the Jenkins project, we ask that people report security issues to our private issue tracker.\nThis allows us to review issues and prepare fixes in private, often resulting in better, safer security fixes.\n\nAs a side effect of that, we also learn about common misconceptions and usability problems related to security in Jenkins.\nThis post is intended to address one of those:\nThe goal and limitations of credentials masking.\n\nThe Problem\n\nOne very common example of that is the role of credentials masking in Jenkins, typically involving a pipeline snippet that looks like this:\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh './deploy.sh' // requires PWD and USR to be set\n}\n// Declarative //\n\nCredentials that are in scope are made available to the pipeline without limitation.\nTo prevent accidental exposure in the build log, credentials are masked from regular output, so an invocation of env (Linux) or set (Windows), or programs printing their environment or parameters would not reveal them in the build log to users who would not otherwise have access to the credentials.\n\nThe misconception here is that Jenkins will prevent other, perhaps deliberate ways to reveal the password.\nSome examples:\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh 'echo $PWD | base64' // will print e.g. dDBwczNjcjN0Cg= which is trivially converted back to the top secret password\n}\n// Declarative //\n\n// Scripted //\nwithCredentials([usernamePassword(credentialsId: 'topSecretCredentials', passwordVariable: 'PWD', usernameVariable: 'USR')])\n  sh 'echo $PWD > myfile'\n  archiveArtifacts 'myfile' // then browse archived artifacts from the Jenkins UI\n}\n// Declarative //\n\nBoth of these snippets circumvent credentials masking in the build log, and show that people with control over the build script can use credentials in ways not necessarily intended or approved by admins.\n\nObviously these are just the most straightforward examples illustrating the problem.\nOthers could involve the proc file system, sending it to an HTTP server in response to a 401 authentication challenge, embedding it in the (otherwise legitimate) build result, etc.\n\nIt would be great if Jenkins could allow the flexible use of credentials with no risk of exposing them through straightforward build script modifications, but realistically, it is impossible for Jenkins to police use of the credential by a build script without the support of a very specific environment setup (e.g. restrictive network configuration).\n\nIt should also be noted that credentials aren’t just at risk from users able to control the pipeline, typically by editing the Jenkinsfile.\nActual build scripts invoked by pipelines, either shell scripts as in the example above, or more standard build tools such as Maven (controlled by pom.xml) are just as much of a risk if they are run inside a withCredentials block, or executing on the same agent as another block that passed such credentials.\n\nDisclosure of secrets can also happen inadvertently:\nJenkins will prevent exact matches of the password or other secret to appear in the log file.\nConsider that the secret may contain shell metacharacters that bash +x would escape by adding a \\ before those characters.\nThe sequence of characters to be printed is no longer identical to the secret, so would not be masked.\n\nThe Solution\n\nCredentials can be defined in different scopes:\nCredentials defined on the root Jenkins store (the default) will be available to all jobs on the instance.\nThe only exception are credentials with System scope, intended for the global configuration only, for example, to connect to agents.\nCredentials defined in a folder are only available within that folder (transitively, i.e. also in folders inside this folder).\n\nThis allows defining sensitive credentials, such as deployment credentials, on specific folders whose contents only users trusted with those credentials are allowed to configure:\nDirectly in Jenkins using Matrix Authorization Plugin and by limiting write access to repositories defining pipelines as code.\n\nPipelines inside this folder can use the (e.g. deployment) credentials without limitation, while they’re inaccessible to pipelines outside the folder.\nThose would need to use the build step or similar approaches to invoke the pipelines inside the folder to deploy their output.\n\nCaveats\n\nWhile the previous section outlines a solution to the problem of restricting access to credentials, care needs to be taken so that credentials are not captured anyway.\nFor example, a deployment pipeline that allows its users to define where to deploy to as a build parameter might still be used to send credentials to a maliciously set up host to capture them.\nA blog post explaining the design of some Jenkins project infrastructure discusses some of these concerns around trust.\n\nIt should also be noted that credential domains are a UI hint only — defining a credential to only be valid for github.com does not actually prevent its use elsewhere.","title":"Limitations of Credentials Masking","tags":["security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2018-12-05T00:00:00.000Z","id":"f0b2bc67-df2c-5d35-83cb-1f19d82bdcd8","slug":"/blog/2018/12/05/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.154 and LTS 2.150.1, that fix multiple security vulnerabilities.\nSince 2.150.1 is the first release in the new LTS line, we also released 2.138.4, a security update for the previous LTS line.\nThis allows administrators to install today’s security fixes without having to upgrade to the new LTS line immediately.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes, see our LTS 2.138.4 upgrade guide.\n\nA note on previously released changes related to this fix\n\nIn the Jenkins core security updates released in August and October, we also included security improvements that can be disabled by setting various system properties.\nThose changes are an essential part of the SECURITY-595 fix, so we strongly recommend not disabling them for any reason.\nPreviously published documentation has been updated.","title":"Important security updates for Jenkins","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2018-10-10T00:00:00.000Z","id":"c142077a-cf17-5ac3-a33f-2658b51ec566","slug":"/blog/2018/10/10/security-updates/","strippedHtml":"We just released security updates to Jenkins, versions 2.146 and 2.138.2, that fix multiple security vulnerabilities.\n\nFor an overview of what was fixed, see the security advisory.\nFor an overview on the possible impact of these changes on upgrading Jenkins LTS, see our LTS upgrade guide.\n\nFurther improvements\n\nIn addition to the security fixes listed in the security advisory, we also applied multiple improvements that make future security vulnerabilities more difficult, or even impossible to exploit.\n\nOne such improvement concerns cross-site scripting vulnerabilities, and comes with a risk of regressions.\n\nJenkins uses a fork of Jelly for the vast majority of the views it renders.\nSince 2011, it includes a feature that lets view authors opt in or out of automatic escaping of variable values for rendering in HTML, and since 2016, the plugin build tooling requires that views explicitly specify whether to apply this automatic escaping.\nDetails are available in the developer documentation.\n\nUntil now, if views do not declare whether to automatically escape, they were rendered without automatic escaping, and developers were expected to explicitly escape every variable reference that was not supposed to contain markup.\nThis has resulted in a number of cross-site scripting (XSS) vulnerabilities, most recently SECURITY-1130 in Job Config History Plugin.\n\nFor that reason, we have decided to enable this automatic escaping by default if plugins do not specify a preference.\nThis can result in problems with some plugins if they need their output to remain unescaped.\nWe expect that those plugins will adapt pretty quickly to this change, as the fix is typically straightforward.\nWe track known affected plugins and their status on the Jenkins wiki.\n\nIn the mean time, users can set the system property org.kohsuke.stapler.jelly.CustomJellyContext.escapeByDefault to false to disable this additional protection.","title":"Important security updates for Jenkins","tags":["core","security"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}},{"node":{"date":"2018-10-09T00:00:00.000Z","id":"5b555e56-ade0-57d9-9cb9-c98ec50c81bf","slug":"/blog/2018/10/09/telemetry/","strippedHtml":"One of the major strengths of Jenkins is its customizability and extensibility.\nWith its plugin ecosystem and long list of (possibly hidden) options, Jenkins can be used for a wide range of use cases.\n\nThe downside of all this flexibility is that, not knowing how people use Jenkins, we mostly rely on issues filed in our bug tracker to know when things go wrong.\nAnd over the years, quite a few things have gone wrong.\nThe worst of these have been security fixes that have had unintended side effects.\nUnlike regular changes, it’s not really feasible to roll back security fixes, so users have sometimes had to choose between security and functionality.\nBut even changes developed in the open, such as the introduction of JEP-200, haven’t gone as smoothly as we hoped.\nWith big changes in the works, it’s more important than ever for us to have a better idea how Jenkins is used, so that we can deliver major changes safely.\n\nJenkins Evergreen solves this to some degree by being always connected to the Jenkins project and reporting back telemetry (mostly errors) allowing us to quickly react and provide fixes.\nBut that project is still pretty new, and its goal of being a more standardized Jenkins does not represent the breadth of configurations of the general user base.\n\nUplink telemetry\n\nSo we recently extended the existing, very limited anonymous usage statistics by adding a simple, extensible telemetry reporting client.\nWe’re calling it Uplink telemetry, based on the name of the service it reports its data to.\nIt made its debut in Jenkins 2.143.\n\nUplink telemetry is designed to collect data in trials, which are defined as:\n\na well defined set of technical data with a specific purpose\n\na start and end date of the collection\n\nDetailed information explaining the scope and purpose of currently active trials is available in the inline help for the usage statistics control in the global configuration.\n\nOf course, opting out of anonymous usage statistics there also disables the submission of Uplink telemetry.\nAnd while Uplink trials report a per-instance UUID to help with collation (e.g. removal of duplicate submissions), that UUID is exclusively used for this purpose, and independent of all other properties of an instance.\nThis prevents us from correlating reported data with specific instances.\nThese measures are in place to strike a balance between the need to understand how Jenkins is used and respecting users' privacy.\n\nImproving Jenkins through real-world data\n\nWe’re already created our first trial.\nJenkins 2.143 includes a trial to gather information about how common it is for instances to use Java system properties to disable (parts of) security fixes.\nWhen we publish a security fix and we’re not completely certain it is safe to apply for everyone, we add another of these options — just in case.\nAs you can imagine, quite a few of these hidden options exist.\nUntil now, user feedback in our issue tracker was the only way we could estimate the need for any of these options.\nWith Uplink, Jenkins will report that information to us.\n\nThe trial is scheduled to run for the next six weeks, enough to hopefully gather this information from a large number of users of both LTS and weekly releases.\nOur hope is that we will be able to remove some of these options entirely, as they might not be needed after all.\nFor others, we might need to consider elevating them to supported features, or finding better solutions obviating the need for them.\n\nIn the future, I will publish of some of what we have learned from the first trial running through Uplink telemetry.\nI look forward to Jenkins continuing to improve with real-world data informing our future decisions.","title":"Improving Jenkins Release Quality using Uplink Telemetry\n","tags":["core"],"authors":[{"avatar":null,"blog":null,"github":"daniel-beck","html":"<div class=\"paragraph\">\n<p>Daniel is a Jenkins core maintainer and, as security officer, leads the <a href=\"/security/#team\">Jenkins security team</a>.\nHe sometimes contributes to developer documentation and project infrastructure.</p>\n</div>","id":"daniel-beck","irc":null,"linkedin":null,"name":"Daniel Beck","slug":"/blog/authors/daniel-beck/","twitter":null}]}}]}},"pageContext":{"author":"daniel-beck","limit":8,"skip":0,"numPages":7,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}