{
    "componentChunkName": "component---src-templates-author-blog-list-template-js",
    "path": "/blog/authors/sgleske",
    "result": {"data":{"author":{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#c8c8b8","images":{"fallback":{"src":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png","srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/914ee/sgleske.png 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/1c9ce/sgleske.png 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/acb7c/sgleske.png 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/ef6ff/sgleske.webp 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/8257c/sgleske.webp 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/6766a/sgleske.webp 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/22bfc/sgleske.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"samrocketman","html":"<div class=\"paragraph\">\n<p>A Senior Software Engineer at <a href=\"https://integralads.com/\">Integral Ad\nScience</a>, he develops a Jenkins solution to scale CI/CD onboarding for the\nentire company.  To aide in this cause he has been developing\n<a href=\"https://github.com/samrocketman/jervis/wiki\">Jervis: Jenkins as a service</a>\nwhich strongly focuses on onboarding people and not just technology or projects\ninto Jenkins.  When not at work he enjoys contributing to open source software,\nlike the Jenkins project, solely through volunteer time.</p>\n</div>","id":"sgleske","irc":null,"linkedin":null,"name":"Sam Gleske","slug":"/blog/authors/sgleske","twitter":"sag47"},"allBlog":{"edges":[{"node":{"date":"2019-12-02T00:00:00.000Z","id":"85ad92d1-eb99-59b8-9bbf-3b4f6309d6df","slug":"/blog/2019/12/02/matrix-building-with-scripted-pipeline/","strippedHtml":"Table of Contents\n\nMatrix building with scripted pipeline\nScreenshot of matrix pipeline\nAdding static choices\nAdding dynamic choices\nFull pipeline example with dynamic choices\nBackground: How does it work?\nExposing a shared library pipeline step\nSummary\n\nWith the recent announcement about matrix building you can perform\nMatrix builds\nwith declarative pipeline.  However, if you must use scripted pipeline, then\nI’m going to cover how to matrix build platforms and tools using scripted\npipeline.  The examples in this post are modeled after the declarative pipeline\nmatrix examples.\n\nMatrix building with scripted pipeline\n\nThe following Jenkins scripted pipeline will build combinations across two\nmatrix axes.  However, adding more axes to the matrix is just as easy as adding\nanother entry to the Map matrix_axes.\n\nJenkinsfile\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\n@NonCPS\nList getMatrixAxes(Map matrix_axes) {\n    List axes = []\n    matrix_axes.each { axis, values ->\n        List axisList = []\n        values.each { value ->\n            axisList << [(axis): value]\n        }\n        axes !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\n// parallel task map\nMap tasks = [failFast: false]\n\nfor(int i = 0; i\"${k}=${v}\"\n    }\n    // let's say you have diverse agents among Windows, Mac and Linux all of\n    // which have proper labels for their platform and what browsers are\n    // available on those agents.\n    String nodeLabel = \"os:${axis['PLATFORM']} && browser:${axis['BROWSER']}\"\n    tasks[axisEnv.join(', ')] = { ->\n        node(nodeLabel) {\n            withEnv(axisEnv) {\n                stage(\"Build\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n                stage(\"Test\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n            }\n        }\n    }\n}\n\nstage(\"Matrix builds\") {\n    parallel(tasks)\n}\n\nMatrix axes contain the following combinations:\n\n[PLATFORM=linux, BROWSER=firefox]\n[PLATFORM=windows, BROWSER=firefox]\n[PLATFORM=mac, BROWSER=firefox]\n[PLATFORM=linux, BROWSER=chrome]\n[PLATFORM=windows, BROWSER=chrome]\n[PLATFORM=mac, BROWSER=chrome]\n[PLATFORM=windows, BROWSER=safari]\n[PLATFORM=mac, BROWSER=safari]\n[PLATFORM=windows, BROWSER=edge]\n\nIt is worth noting that Jenkins agent labels can contain a colon ( :).  So\nos:linux and browser:firefox are both valid agent labels.  The node\nexpression os:linux && browser:firefox will search for Jenkins agents which\nhave both labels.\n\nScreenshot of matrix pipeline\n\nThe following is a screenshot of the pipeline code above running in a sandbox\nJenkins environment.\n\nAdding static choices\n\nIt is useful for users to be able to customize building matrices when a build\nis triggered.  Adding static choices requires only a few changes to the above\nscript.  Static choices as in we hard code the question and matrix filters.\n\nJenkinsfile\n\n(response['PLATFORM'] == 'all' || response['PLATFORM'] == axis['PLATFORM']) &&\n    (response['BROWSER'] == 'all' || response['BROWSER'] == axis['BROWSER']) &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nThe pipeline code then renders the following choice dialog.\n\nWhen a user chooses the customized options, the pipeline reacts to the\nrequested options.\n\nAdding dynamic choices\n\nDynamic choices means the choice dialog for users to customize the build is\ngenerated from the Map matrix_axes rather than being something a pipeline\ndeveloper hard codes.\n\nFor user experience (UX), you’ll want your choices to automatically reflect the\nmatrix axis options you have available.  For example, let’s say you want to add\na new dimension for Java to the matrix.\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    JAVA: ['openjdk8', 'openjdk10', 'openjdk11'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\nTo support dynamic choices, your choice and matrix axis filter needs to be\nupdated to the following.\n\nchoice(\n                choices: ['all'] + options.sort(),\n                description: \"Choose a single ${key.toLowerCase()} or all to run tests.\",\n                name: key)\n        })\n}\n\n// filter the matrix axes since\n// Safari is not available on Linux and\n// Edge is only available on Windows\nList axes = getMatrixAxes(matrix_axes).findAll { axis ->\n    response.every { key, choice ->\n        choice == 'all' || choice == axis[key]\n    } &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nIt will dynamically generate choices based on available matrix axes and will\nautomatically filter if users customize it.  Here’s an example dialog and\nrendered choice when the pipeline executes.\n\nFull pipeline example with dynamic choices\n\nThe following script is the full pipeline example which contains dynamic\nchoices.\n\n// you can add more axes and this will still work\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n    JAVA: ['openjdk8', 'openjdk10', 'openjdk11'],\n    BROWSER: ['firefox', 'chrome', 'safari', 'edge']\n]\n\n@NonCPS\nList getMatrixAxes(Map matrix_axes) {\n    List axes = []\n    matrix_axes.each { axis, values ->\n        List axisList = []\n        values.each { value ->\n            axisList << [(axis): value]\n        }\n        axes \nchoice(\n                choices: ['all'] + options.sort(),\n                description: \"Choose a single ${key.toLowerCase()} or all to run tests.\",\n                name: key)\n        })\n}\n\n// filter the matrix axes since\n// Safari is not available on Linux and\n// Edge is only available on Windows\nList axes = getMatrixAxes(matrix_axes).findAll { axis ->\n    response.every { key, choice ->\n        choice == 'all' || choice == axis[key]\n    } &&\n    !(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\n// parallel task map\nMap tasks = [failFast: false]\n\nfor(int i = 0; i\"${k}=${v}\"\n    }\n    // let's say you have diverse agents among Windows, Mac and Linux all of\n    // which have proper labels for their platform and what browsers are\n    // available on those agents.\n    String nodeLabel = \"os:${axis['PLATFORM']} && browser:${axis['BROWSER']}\"\n    tasks[axisEnv.join(', ')] = { ->\n        node(nodeLabel) {\n            withEnv(axisEnv) {\n                stage(\"Build\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n                stage(\"Test\") {\n                    echo nodeLabel\n                    sh 'echo Do Build for ${PLATFORM} - ${BROWSER}'\n                }\n            }\n        }\n    }\n}\n\nstage(\"Matrix builds\") {\n    parallel(tasks)\n}\n\nBackground: How does it work?\n\nThe trick is in axes.combinations()*.sum().  Groovy combinations are a quick\nand easy way to perform a\ncartesian product.\n\nHere’s a simpler example of how cartesian product works.  Take two simple lists\nand create combinations.\n\nList a = ['a', 'b', 'c']\nList b = [1, 2, 3]\n\n[a, b].combinations()\n\nThe result of [a, b].combinations() is the following.\n\n[\n    ['a', 1],\n    ['b', 1],\n    ['c', 1],\n    ['a', 2],\n    ['b', 2],\n    ['c', 2],\n    ['a', 3],\n    ['b', 3],\n    ['c', 3]\n]\n\nInstead of a, b, c and 1, 2, 3 let’s do the same example again but instead using matrix maps.\n\nList java = [[java: 8], [java: 10]]\nList os = [[os: 'linux'], [os: 'freebsd']]\n\n[java, os].combinations()\n\nThe result of [java, os].combinations() is the following.\n\n[\n    [ [java:8],  [os:linux]   ],\n    [ [java:10], [os:linux]   ],\n    [ [java:8],  [os:freebsd] ],\n    [ [java:10], [os:freebsd] ]\n]\n\nIn order for us to easily use this as a single map we must add the maps\ntogether to create a single map.  For example, adding\n[java: 8] + [os: 'linux'] will render a single hashmap\n[java: 8, os: 'linux'].  This means we need our list of lists of maps to\nbecome a simple list of maps so that we can use them effectively in pipelines.\n\nTo accomplish this we make use of the\nGroovy spread\noperator ( *. in axes.combinations()*.sum()).\n\nLet’s see the same java / os example again but with the spread operator being\nused.\n\nList java = [[java: 8], [java: 10]]\nList os = [[os: 'linux'], [os: 'freebsd']]\n\n[java, os].combinations()*.sum()\n\nThe result is the following.\n\n[\n    [ java: 8,  os: 'linux'],\n    [ java: 10, os: 'linux'],\n    [ java: 8,  os: 'freebsd'],\n    [ java: 10, os: 'freebsd']\n]\n\nWith the spread operator the end result of a list of maps which we can\neffectively use as matrix axes.  It also allows us to do neat matrix filtering\nwith the findAll {} Groovy List method.\n\nExposing a shared library pipeline step\n\nThe best user experience is to expose the above code as a shared library\npipeline step.  As an example, I have added\nvars/getMatrixAxes.groovy\nto Jervis.  This provides a flexible shared library step which you can copy\ninto your own shared pipeline libraries.\n\nThe step becomes easy to use in the following way with a simple one dimension matrix.\n\nJenkinsfile\n\nMap matrix_axes = [\n    PLATFORM: ['linux', 'windows', 'mac'],\n]\n\nList axes = getMatrixAxes(matrix_axes)\n\n// alternately with a user prompt\n//List axes = getMatrixAxes(matrix_axes, user_prompt: true)\n\nHere’s a more complex example using a two dimensional matrix with filtering.\n\nJenkinsfile\n\n!(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nAnd again with a three dimensional matrix with filtering and prompting for user\ninput.\n\nJenkinsfile\n\n!(axis['BROWSER'] == 'safari' && axis['PLATFORM'] == 'linux') &&\n    !(axis['BROWSER'] == 'edge' && axis['PLATFORM'] != 'windows')\n}\n\nThe script approval is not necessary for\nShared Libraries.\n\nIf you don’t want to provide a shared step.  In order to expose matrix building\nto end-users, you must allow the following method approval in the script\napproval configuration.\n\nScript approval\n\nstaticMethod org.codehaus.groovy.runtime.DefaultGroovyMethods combinations java.util.Collection\n\nSummary\n\nWe covered how to perform matrix builds using scripted pipeline as well as how\nto prompt users for customizing the matrix build.  Additionally, an example was\nprovided where we exposed getting buildable matrix axes to users as an easy to\nuse Shared Library\nstep via vars/getMatrixAxes.groovy.  Using a shared library step is\ndefinitely the recommended way for admins to support users rather than trying\nto whitelist groovy methods.\n\nJervis shared pipeline library has supported matrix building since 2017 in Jenkins scripted pipelines.\n( see here and\nhere\nfor an example).","title":"Matrix building in scripted pipeline","tags":["matrix","pipeline","plugins","scripted"],"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#c8c8b8","images":{"fallback":{"src":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png","srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/914ee/sgleske.png 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/1c9ce/sgleske.png 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/bf8e1/sgleske.png 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/acb7c/sgleske.png 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/ef6ff/sgleske.webp 32w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/8257c/sgleske.webp 64w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/6766a/sgleske.webp 128w,\n/gatsby-jenkins-io/static/383551e873ffc7c72da8547e3d05f878/22bfc/sgleske.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}}},"blog":null,"github":"samrocketman","html":"<div class=\"paragraph\">\n<p>A Senior Software Engineer at <a href=\"https://integralads.com/\">Integral Ad\nScience</a>, he develops a Jenkins solution to scale CI/CD onboarding for the\nentire company.  To aide in this cause he has been developing\n<a href=\"https://github.com/samrocketman/jervis/wiki\">Jervis: Jenkins as a service</a>\nwhich strongly focuses on onboarding people and not just technology or projects\ninto Jenkins.  When not at work he enjoys contributing to open source software,\nlike the Jenkins project, solely through volunteer time.</p>\n</div>","id":"sgleske","irc":null,"linkedin":null,"name":"Sam Gleske","slug":"/blog/authors/sgleske","twitter":"sag47"}]}}]}},"pageContext":{"author":"sgleske","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}