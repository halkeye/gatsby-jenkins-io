{
    "componentChunkName": "component---src-templates-author-blog-list-template-js",
    "path": "/blog/authors/gabloe",
    "result": {"data":{"author":{"avatar":null,"blog":null,"github":"gabloe","html":"","id":"gabloe","irc":null,"linkedin":null,"name":"Gabriel Loewen","slug":"/blog/authors/gabloe","twitter":null},"allBlog":{"edges":[{"node":{"date":"2017-07-26T00:00:00.000Z","id":"a5452093-8b55-5ee4-8314-15bc7e02cd41","slug":"/blog/2017/07/26/powershell-pipeline/","strippedHtml":"I am pleased to announce Microsoft PowerShell support for Jenkins Pipeline!\nAs of Durable Task 1.14 and\nPipeline Nodes and Processes Plugin 2.12, you will now be able to run Microsoft PowerShell scripts\ndirectly in your Jenkins Pipeline projects.  This blog post covers the basics\nof getting started with Microsoft PowerShell in Pipeline and provides some\nbasic examples.\n\nIntroduction to Microsoft PowerShell\n\nPowerShell is Microsoftâ€™s open source and cross platform command line shell, as\nwell as an automation and configuration tool/framework which has a broad user\nbase. PowerShell can be used to perform common system administration tasks in\nWindows, macOS, and Linux environments. It can also be used as a general\npurpose scripting language. Now that Jenkins Pipeline supports PowerShell, you\ncan enjoy the rich set of features in PowerShell for your daily DevOps work.\n\nBefore diving into using PowerShell in your Pipeline, I recommend reading the\nWindows\nPowerShell Reference as well as the\nPowerShell Team Blog for an\nintroduction to PowerShell features, utilities, and as a quick look into the\nPowerShell language.  Microsoft also has an active\nPowerShell community on GitHub,\nwhich I highly recommend visiting to submit feature requests and bug\nreports as you see fit. Jenkins Pipeline currently supports Microsoft\nPowerShell 3.0 or higher, so also be sure to check which version of PowerShell\nis installed on your system in order to take advantage of PowerShell in your\nPipeline.  Please note that we recommend that you upgrade to the latest stable\nversion of PowerShell available, which as of this writing is version 5.1.14393.\n\nThe powershell step\n\nnode {\n    powershell 'Write-Output \"Hello, World!\"'\n}\n\nUsing Microsoft PowerShell in Pipeline\n\nWriting PowerShell code as part of your pipeline is incredibly simple. The step that you will use is\nsimply powershell, and it includes the same optional parameters as the\nWindows Batch ( bat) step, including:\n\nreturnStdout: Returns the standard output stream with a default encoding of UTF-8 (alternative encoding is optional)\n\nreturnStatus: Returns the exit status (integer) of the PowerShell script\n\nExamples\n\nCapture exit status of a PowerShell script\n\nnode {\n    def status = powershell(returnStatus: true, script: 'ipconfig')\n    if (status == 0) {\n        // Success!\n    }\n}\n\nCapture and print the output of a PowerShell script\n\nnode {\n    def msg = powershell(returnStdout: true, script: 'Write-Output \"PowerShell is mighty!\"')\n    println msg\n}\n\nWhich streams get returned when I use returnStdout?\n\nUntil the release of PowerShell 5, there were five distinct output streams. PowerShell 5 introduced a sixth stream for pushing \"informational\" content,\nwith the added benefit of being able to capture messages sent to Write-Host. Each row of the following table describes a PowerShell stream along with\nthe corresponding Cmdlet used for writing to the stream for that particular row. Please keep in mind that stream 6 and associated cmdlets either\ndo not exist or exhibit alternate behavior in versions of PowerShell earlier than version 5.\n\nStream\nDescription\nCmdlet\n\n1\nOutput stream (e.g. stdOut)\nWrite-Output\n\n2\nError stream (e.g. stdErr)\nWrite-Error\n\n3\nWarning stream\nWrite-Warning\n\n4\nVerbose stream\nWrite-Verbose\n\n5\nDebug stream\nWrite-Debug\n\n6\nInformation stream\nWrite-Information (or Write-Host with caveats)\n\nIf you are using the returnStdout option of the powershell Pipeline step\nthen only stream 1 will be returned, while streams 2-6 will be redirected to\nthe console output. For example:\n\nWrite to all available streams and return the standard output\n\nnode {\n    def stdout = powershell(returnStdout: true, script: '''\n        # Enable streams 3-6\n        $WarningPreference = 'Continue'\n        $VerbosePreference = 'Continue'\n        $DebugPreference = 'Continue'\n        $InformationPreference = 'Continue'\n\n        Write-Output 'Hello, World!'\n        Write-Error 'Something terrible has happened!'\n        Write-Warning 'Warning! There is nothing wrong with your television set'\n        Write-Verbose 'Do not attempt to adjust the picture'\n        Write-Debug 'We will control the horizontal.  We will control the vertical'\n        Write-Information 'We can change the focus to a soft blur or sharpen it to crystal clarity.'\n    ''')\n    println stdout\n}\n\nConsole output:\n\n[Pipeline] {\n[Pipeline] powershell\n[TestStreams] Running PowerShell script\n\\workspace\\TestStreams@tmp\\durable-4d924c2d\\powershellScript.ps1 : Something terrible has\nhappened!\nAt \\workspace\\TestStreams@tmp\\durable-4d924c2d\\powershellMain.ps1:2 char:1\n+ & ' \\workspace\\TestStreams@tmp\\durable-4d924c ...\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : NotSpecified: (:) [Write-Error], WriteErrorException\n    + FullyQualifiedErrorId : Microsoft.PowerShell.Commands.WriteErrorException,powershellScript.ps1\n\nWarning! There is nothing wrong with your television set\nDo not attempt to adjust the picture\nWe will control the horizontal.  We will control the vertical\nWe can change the focus to a soft blur or sharpen it to crystal clarity.\nHello, World!\n[Pipeline] }\n[Pipeline] // node\n[Pipeline] End of Pipeline\nERROR: script returned exit code 1\nFinished: FAILURE\n\nNote that \"Hello, World!\" gets printed last even though it is the first output\nstatement in my script.  Another interesting aspect of this example is that the\npowershell step failed, which ultimately caused the job to fail. The failure\nin this example is due to the PowerShell error stream being non-empty, which\ntherefore caused the step to result in a non-zero exit status. However, as you\nwill soon discover, there are a variety of causes for a failing powershell\nstep.\n\nWhat causes a failing exit status?\n\nWhen you execute a powershell step, it may produce a non-zero exit code and\nfail your pipeline build.  This is very similar to other shell steps with some\ninteresting caveats. Your powershell step may produce a failing exit status\nin the following instances:\n\nSomething in your PowerShell script has thrown an exception\n\nYour PowerShell script explicitly calls exit with a non-zero exit code\n\nYour PowerShell script calls a native application that produces a non-zero $LastExitCode\n\n$LastExitCode is an automatic variable that is set after executing a native application\n\nYour PowerShell script results in a non-empty error stream (with or without throwing an exception)\n\nOverriding the exit status behavior of your powershell step can be achieved\nby explicitly exiting from your script as long as the failure was not caused by\nan unhandled exception. For example:\n\nUnavoidable failure caused by an unhandled exception\n\nnode {\n    powershell '''\n        throw 'Error! Problem Exists Between Keyboard And Chair'\n        exit 0  # Unreachable code\n    '''\n}\n\nFailed step caused by a non-empty error stream\n\nnode {\n    powershell '''\n        Write-Error 'Error! Problem Exists Between Keyboard And Chair'\n    '''\n}\n\nFailure prevented by an explicit exit\n\nnode {\n    powershell '''\n        Write-Error 'Error! Problem Exists Between Keyboard And Chair'\n        exit 0\n    '''\n}\n\nScripts vs. Cmdlets\n\nA Cmdlet is a small lightweight utility written in either C#, and compiled, or\nwritten in PowerShell directly. Depending on what your goal is in your pipeline\nyou can make use of Cmdlets directly in your pipeline code, call a self\ncontained PowerShell script, or some mixture of the two. If your strategy is to\nkeep each powershell step as short and succinct as possible then it may make\nsense for you to write a library of Cmdlets, but if you have monolithic scripts\nthen it may make sense for you to call those scripts directly from your\npipeline. The choice is entirely up to you, as both scenarios are supported.\n\nThanks for reading, and have fun!\n\nI sincerely hope that this post has encouraged you to try using PowerShell in\nyour Jenkins Pipeline. Please do not hesitate to file an issue against the\ndurable-task\nplugin on\nJIRA\nif you have discovered any problem that you suspect is related to the\npowershell step.  For general PowerShell related issues or inquiries\nplease route your questions to the\nPowerShell community.","title":"Microsoft PowerShell Support for Pipeline","tags":["durable-task","powershell"],"authors":[{"avatar":null,"blog":null,"github":"gabloe","html":"","id":"gabloe","irc":null,"linkedin":null,"name":"Gabriel Loewen","slug":"/blog/authors/gabloe","twitter":null}]}}]}},"pageContext":{"author":"gabloe","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}