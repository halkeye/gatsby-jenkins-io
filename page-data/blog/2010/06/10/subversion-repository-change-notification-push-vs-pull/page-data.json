{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2010/06/10/subversion-repository-change-notification-push-vs-pull/",
    "result": {"data":{"blog":{"html":"<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nPeople often configure https://en.wikipedia.org/wiki/Hudson%20%28software%29[Hudson] to start a new build whenever a change is made to the repository. In fact, this is often considered central to the practice of continuous integration. +\n +</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nThere are two ways to achieve this. One is the \"pull\" model, where Hudson periodically reaches out to a Subversion repository to see if there is any changes. The other is the \"push\" model, where you make the Subversion repository reach out to Hudson. +\n +</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nBoth approaches have trade-offs. The pull model is easier to configure, since you can do this entirely from Hudson. But this comes at the expense of increased load to the Subversion server. Even though the overhead of Subversion polling is relatively low, as you add more projects to Hudson and increase the polling frequency, the overhead may get non-trivial (imagine the number of Hudson pollings that the poor https://java.net[java.net] Subversion server gets, for example.) A more serious downside, in my opinion, is that this increases the delay from your commit to a build. For example, if your build just takes 5 mins, then even if you poll every minute, you pay on average 30 seconds delay before a build starts â€” a 10% overhead! +\n +</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nThe push approach eliminates those two downsides, but it requires a post-commit hook configuration in the Subversion repository, which has to be done manually by the administrator, because those scripts are not exposed to external systems like Hudson. +\n +</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nWith that said, if you do have an access to the Subversion repository post-commit hook, I highly recommend the push approach, and in Hudson we made it as easy as possible to configure the set up. Here's the script you'll need in your post-commit hook: +\n +\n`+ REPOS=\"$1\" REV=\"$2\" UUID=\\`svnlook uuid $REPOS\\` /usr/bin/wget \\   --header \"Content-Type:text/plain;charset=UTF-8\" \\   --post-data \"\\`svnlook changed --revision $REV $REPOS\\`\" \\   --output-document \"-\" \\   https://server/hudson/subversion/${UUID}/notifyCommit?rev=$REV+` +\n +</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nThis script basically just tells Hudson that there was a change in a repository. Hudson will then check this information against all the jobs that have a polling configured, and schedule the builds accordingly. The beauty of this approach is two-folds: +\n +</pre>\n</div>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>The script doesn&#8217;t change when you add/remove/rename jobs.<br></p>\n</li>\n<li>\n<p>The overhead is constant regardless of the number of jobs.<br></p>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\">+\n+</pre>\n</div>\n</div>\n<div class=\"literalblock\">\n<div class=\"content\">\n<pre class=\"nowrap\"> +\nIf you haven't configured a push setup yet, now is the time to do so! +</pre>\n</div>\n</div>\n</li>\n</ul>\n</div>","id":"47ba57bf-9dea-510b-9ec1-8e71951d4fd8","title":"Subversion repository change notification: push vs pull","date":"2010-06-10T00:00:00.000Z","slug":"/blog/2010/06/10/subversion-repository-change-notification-push-vs-pull/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/edb43/kohsuke.jpg","srcSet":"/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/f81fe/kohsuke.jpg 32w,\n/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/01b1b/kohsuke.jpg 64w,\n/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/edb43/kohsuke.jpg 128w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/035c3/kohsuke.webp 32w,\n/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/273f8/kohsuke.webp 64w,\n/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/e3840/kohsuke.webp 128w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":148}},"publicURL":"/gatsby-jenkins-io/static/dd191cfa3b1158515bff16d455e6117b/kohsuke.jpeg"},"blog":null,"github":"kohsuke","html":"<div class=\"paragraph\">\n<p>Kohsuke is the creator of Jenkins.</p>\n</div>","id":"kohsuke","irc":null,"linkedin":null,"name":"Kohsuke Kawaguchi","slug":"/blog/authors/kohsuke","twitter":"kohsukekawa"}]}},"pageContext":{"id":"47ba57bf-9dea-510b-9ec1-8e71951d4fd8"}},
    "staticQueryHashes": ["1271460761","3649515864"]}