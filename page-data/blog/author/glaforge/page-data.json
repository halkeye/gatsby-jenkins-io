{
    "componentChunkName": "component---src-templates-author-blog-list-template-js",
    "path": "/blog/author/glaforge",
    "result": {"data":{"author":{"avatar":null,"blog":"https://glaforge.appspot.com/","github":"glaforge","html":"","id":"glaforge","irc":null,"linkedin":null,"name":"Guillaume Laforge","slug":"blog/author/glaforge","twitter":"glaforge"},"allBlog":{"edges":[{"node":{"date":"2017-07-21T00:00:00.000Z","id":"215b578b-be74-5ce1-b9f3-38b9bfc35f5c","slug":"/blog/2017/07/21/scaling-jenkins-with-kubernetes-on-google-container-engine/","strippedHtml":"This is a guest post by Guillaume Laforge,\nDeveloper Advocate for Google Cloud\n\nLast week, I had the pleasure to speak at the\nJenkins Community Day conference, in Paris,\norganized by my friends from JFrog,\nprovider of awesome tools for software management and distribution.\nI covered how to scale Jenkins with Kubernetes on\nGoogle Container Engine.\n\nFor the impatient, here are the slides of the presentation I’ve given:\n\nBut let’s step back a little. In this article, I’d like to share with you why you would want to run Jenkins in the cloud,\nas well as give you some pointers to interesting resources on the topic.\n\nWhy running Jenkins in the cloud?\n\nSo why running Jenkins in the cloud? First of all, imagine your small team, working on a single project.\nYou have your own little server, running under a desk somewhere, happily building your application on each commit,\na few times a day. So far so good, your build machine running Jenkins isn’t too busy, and stays idle most of the day.\n\nLet’s do some bottom of the napkin calculations. Let’s say you have a team of 3 developers,\ncommitting roughly 4 times a day, on one single project, and the build takes roughly 10 minutes to go.\n\n3 developers * 4 commits / day / developer * 10 minutes build time * 1 project = 1 hour 20 minutes\n\nSo far so good, your server indeed stays idle most of the day. Usually, at most,\nyour developers will wait just 10 minutes to see the result of their work.\n\nBut your team is growing to 10 persons, the team is still as productive, but the project becoming bigger,\nthe build time goes up to 15 minutes:\n\n10 developers * 4 commits / day / developer * 15 minutes build time * 1 project = 10 hours\n\nYou’re already at 10 hours build time, so your server is busy the whole day, and at times,\nyou might have several build going on at the same time, using several CPU cores in parallel.\nAnd instead of building in 15 minutes, sometimes, the build might take longer, or your build might be queued.\nSo in theory, it might be 15 minutes, but in practice, it could be half an hour because of the length of the queue\nor the longer time to build parallel projects.\n\nNow, the company is successful, and has two projects instead of one (think a backend and a mobile app).\nYour teams grow further up to 20 developers per project. The developers are a little less productive\nbecause of the size of the codebase and project, so they only commit 3 times a day.\nThe build takes more time too, at 20 minutes (in ideal time). Let’s do some math again:\n\n20 developers * 3 commits / day / developer * 20 minutes build time * 2 projects = 40 hours\n\nWoh, that’s already 40 hours of total build time, if all the builds are run serially.\nFortunately, our server is multi-core, but still, there are certainly already many builds that are enqueued,\nand many of them, perhaps up to 2-3 or perhaps even 4 could be run in parallel.\nBut as we said, the build queue increases further, the real effective time of build is certainly longer than 30 minutes.\nPerhaps at times, developers won’t see the result of their developments before at least an hour, if not more.\n\nOne last calculation? With team sizes of 30 developers, decreased productivity of 2 commits, 25 build time,\nand 3 projects? And you’ll get 75 hours total build time. You may start creating a little build farm,\nwith a controller and several build agents. But you also increase the burden of server management.\nAlso, if you move towards a full Continuous Delivery or Continuous Deployment approach,\nyou may further increase your build times to go up to deployment, make more but smaller commits, etc.\nYou could think of running builds less often, or even on a nightly basis, to cope with the demand, but then,\nyour company is less agile, and the time-to-market for fixes of new features might increase,\nand your developers may also become more frustrated because they are developing in the blind,\nnot knowing before the next day if their work was successful or not.\n\nWith my calculations, you might think that it makes more sense for big companies, with tons of projects and developers.\nThis is quite true, but when you’re a startup, you also want to avoid taking care of local server management,\nprovisioning, etc. You want to be agile, and use only compute resources you need for the time you need them.\nSo even if you’re a small startup, a small team, it might still make sense to take advantage of the cloud.\nYou pay only for the actual time taken by your builds as the build agent containers are automatically provisioned\nand decommissioned. The builds can scale up via Kubernetes, as you need more (or less) CPU time for building everything.\n\nAnd this is why I was happy to dive into scaling Jenkins in the cloud. For that purpose,\nI decided to go with building with containers, with Kubernetes, as my app was also containerized as well.\nGoogle Cloud offers Container Engine, which is basically just Kubernetes in the cloud.\n\nUseful pointers\n\nI based my presentation and demo on some great solutions that are published on the Google Cloud documentation portal.\nLet me give you some pointers.\n\nOverview of Jenkins on Container Engine\n\nSetting up Jenkins on Container Engine\n\nConfiguring Jenkins for Container Engine\n\nContinuous Deployment to Container Engine using Jenkins\n\nLab: Build a Continuous Deployment Pipeline with Jenkins and Kubernetes\n\nThe latter one is the tutorial I actually followed for the demo that I presented during the conference.\nIt’s a simple Go application, with a frontend and backend.\nIt’s continuously build, on each commit (well, every minute to check if there’s a new commit),\nand deployed automatically in different environments: dev, canary, production.\nThe sources of the project are stored in Cloud Source Repository (it can be mirrored from Github, for example).\nThe containers are stored in Cloud Container Registry.\nAnd both the Jenkins controller and agents, as well as the application are running inside Kubernetes clusters in Container Engine.\n\nSummary and perspective\n\nDon’t bother with managing servers! Quickly, you’ll run out of CPU cycles,\nand you’ll have happier developers with builds that are super snappy!\n\nAnd for the record, at Google, dev teams are also running Jenkins!\nThere was a presentation ( video and\nslides\navailable) given last year by David Hoover at Jenkins World\ntalking about how developers inside Google are running hundreds of build agents to build projects on various platforms.","title":"Scaling Jenkins with Kubernetes on Google Container Engine","tags":["jenkins","kubernetes","jenkins-community-day-paris"],"authors":[{"avatar":null,"blog":"https://glaforge.appspot.com/","github":"glaforge","html":"","id":"glaforge","irc":null,"linkedin":null,"name":"Guillaume Laforge","slug":"blog/author/glaforge","twitter":"glaforge"}]}},{"node":{"date":"2016-04-11T00:00:00.000Z","id":"71b50dae-de34-5505-957d-a9c0f8d10044","slug":"/blog/2016/04/11/run-your-api-tests-continuously-with-jenkins-and-dhc/","strippedHtml":"This is a guest post by Guillaume Laforge.\nWell known for his contribution to the Apache Groovy project,\nGuillaume is also the \"Product Ninja and Advocate\" of Restlet,\na company focusing on Web APIs:\nwith DHC (an API testing client),\nRestlet Studio (an API designer),\nAPISpark (an API platform in the cloud),\nand the Restlet Framework\nopen source project for developing APIs.\n\nModern mobile apps, single-page web sites and applications, are more and more relying on Web APIs,\nas the nexus of the interaction between the frontend and the backend services.\nWeb APIs are also central to third-party integration, when you want to share your services with others,\nor when you need to consume existing APIs to build your own solution on top of their shoulders.\n\nWith APIs being a key element of your architecture and big picture,\nit’s obviously important to assess that this API is functioning the way it should, thanks to proper testing.\nYour framework of choice, regardless of the technology stack or programming language used,\nwill hopefully offer some facilities for testing your code,\nwhether in the form of unit tests, or ideally with integration tests.\n\nCoding Web API tests\n\nFrom a code perspective, as I said, most languages and frameworks provide approaches to testing APIs built with them.\nThere’s one I wanted to highlight in particular, which is one developed with a DSL approach (Domain-Specific Language),\nusing the Apache Groovy programming language, it’s\nAccuREST.\n\nTo get started, you can have a look at the introduction,\nand the usage guide.\nIf you use the contract DSL,\nyou’ll be able to write highly readable examples of requests you want to issue against your API,\nand the assertions that you expect to be true when getting the response from that call.\nHere’s a concrete example from the documentation:\n\nGroovyDsl.make {\n    request {\n        method 'POST'\n        urlPath('/users') {\n            queryParameters {\n                parameter 'limit': 100\n                parameter 'offset': containing(\"1\")\n                parameter 'filter': \"email\"\n            }\n        }\n        headers {\n            header 'Content-Type': 'application/json'\n        }\n        body '''{ \"login\" : \"john\", \"name\": \"John The Contract\" }'''\n    }\n    response {\n        status 200\n        headers {\n            header 'Location': '/users/john'\n        }\n    }\n}\n\nNotice that the response is expected to return a status code 200 OK, and a Location header pointing at /users/john.\nIndeed, a very readable way to express the requests and responses!\n\nTooling to test your APIs\n\nFrom a tooling perspective, there are some interesting tools that can be used to test Web APIs,\nlike Paw (on Macs),\nAdvanced REST client,\nPostman or\nInsomnia.\n\nBut in this article, I’ll offer a quick look at DHC,\na handy visual tool, that you can use both manually to craft your tests and assertions,\nand whose test scenarios you can export and integrate in your build and continuous integration pipeline,\nthanks to Maven and Jenkins.\n\nAt the end of this post, you should be able to see the following reporting in your Jenkins dashboard,\nwhen visualising the resulting API test execution:\n\nIntroducing DHC\n\nDHC is a Chrome extension, that you can\ninstall from the Chrome Web Store,\nin your Chrome browser. There’s also an online service available, with some limitations.\nFor the purpose of this article, we’ll use the Chrome extension.\n\nIn the main area, you can create your request, define the URL to call, specify the various request headers or params,\nchose the method you want to use, and then, you can click the send button to issue the request.\n\nIn the left pane, that’s where you’ll be able to see your request history, create and save your project in the cloud,\nor also set context variables.\n\nThe latter is important when testing your Web API, as you’ll be able to insert variables like for example\n{localhost} for testing locally on your machine or {staging} and {prod} to run your tests in different environments.\n\nIn the bottom pane, you have access to actual raw HTTP exchange, as well as the assertions pane.\n\nAgain, a very important pane to look at! With assertions, you’ll be able to ensure that your Web API works as expected.\nFor instance, you can check the status code of the call, check the payload contains a certain element,\nby using JSON Path or XPath to go through the JSON or XML payload respectively.\n\nBeyond assertions, what’s also interesting is that you can chain requests together.\nA call request can depend on the outcome of a previous request!\nFor example, in a new request, you could pass a query parameter whose value would be the value of some element\nof the JSON payload of a previously executed request.\nAnd by combining assertions, linked requests and context variables together, you can create full-blown test scenarios,\nthat you can then save in the cloud, but also export as a JSON file.\n\nTo export that test scenario, you can click on the little export icon in the bottom left hand corner,\nand you’ll be able to select exactly what you want to export:\n\nRunning your Web API tests with Maven\n\nNow things become even more interesting, as we’ll proceed to using Maven and Jenkins!\nAs the saying goes, there’s a Maven plugin for that! For running those Web API tests in your build!\nEven if your Web API is developed in another technology than Java, you can still create a small Maven build\njust for your Web API tests.\nAnd the icing on the cake, when you configure Jenkins to run this build, as the plugin outputs JUnit-friendly test reports,\nyou’ll be able to see the details of your successful and failed tests, just like you would see JUnit’s!\n\nLet’s sketch your Maven POM:\n\n4.0.0\n\ncom.example\nmy-first-api-test\n1.2.3\n\ncom.restlet.dhc\ndhc-maven-plugin\n1.1\n\ntest\n\ntest\n\ncompanies-scenario.json\n\nrestlet-maven\nRestlet public Maven repository Release Repository\nhttps://maven.restlet.com\n\nVisualizing Web API test executions in Jenkins\n\nOnce you’ve configured your Jenkins server to launch the test goal of this Maven project,\nyou’ll be able to see nice test reports for your Web API scenarios, like in the screenshot in introduction of this article!\n\nNext, you can easily run your Web API tests when developers commit changes to the API,\nor schedule regular builds with Jenkins to monitor an online Web API.\n\nFor more information, be sure to read the tutorial on\ntesting Web APIs with DHC.\nThere are also some more resources like a\nscreencast,\nas well as the\nuser guide, if you want to learn more.\nAnd above all, happy testing!","title":"Run Your API Tests Continuously with Jenkins and DHC","tags":["development","webapis","testing"],"authors":[{"avatar":null,"blog":"https://glaforge.appspot.com/","github":"glaforge","html":"","id":"glaforge","irc":null,"linkedin":null,"name":"Guillaume Laforge","slug":"blog/author/glaforge","twitter":"glaforge"}]}}]}},"pageContext":{"author":"glaforge","limit":8,"skip":0,"numPages":1,"currentPage":1}},
    "staticQueryHashes": ["3649515864"]}