{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2016/04/14/replay-with-pipeline/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This is a cross-post of\n<a href=\"https://www.cloudbees.com/blog/replay-pipeline\">an article</a> authored by\nPipeline plugin maintainer <a href=\"https://github.com/jglick\">Jesse Glick</a> on the\n<a href=\"https://www.cloudbees.com/blog/\">CloudBees blog</a>.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>For those of you not checking their <em>Updates</em> tab obsessively, Pipeline 1.14 [up\nto 2.1 now] was\n<a href=\"https://github.com/jenkinsci/workflow-plugin/blob/master/CHANGES.md#114-feb-25-2016\">released\na couple of weeks ago</a> and I wanted to highlight the major feature in this\nrelease: <a href=\"https://issues.jenkins.io/browse/JENKINS-32727\">JENKINS-32727</a>,\nor <em>replay</em>. Some folks writing \"Jenkinsfiles\" in the field had grumbled that it\nwas awkward to develop the script incrementally, especially compared to jobs\nusing inline scripts stored in the Jenkins job configuration: to try a change to\nthe script, you had to edit <code>Jenkinsfile</code> in SCM, commit it (perhaps to a\nbranch), and then go back to Jenkins to follow the output. Now this is a little\neasier. If you have a Pipeline build which did not proceed exactly as you\nexpected, for reasons having to do with Jenkins itself (say, inability to find &amp;\npublish test results, as opposed to test failures you could reproduce locally),\ntry clicking the <strong>Replay</strong> link in the build’s sidebar. The quickest way to try\nthis for yourself is to run the\n<a href=\"https://hub.docker.com/r/jenkinsci/workflow-demo/\">stock CD demo</a> in its\nlatest release:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>$ docker run --rm -p 2222:2222 -p 8080:8080 -p 8081:8081 -p 9418:9418 -ti jenkinsci/workflow-demo:1.14-3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you see <a href=\"http://localhost:8080/job/cd/branch/master/1/replay/\">the page <strong>Replay\n#1</strong></a>, you are shown two\n(Groovy) editor boxes: one for the main\n<a href=\"https://github.com/jenkinsci/workflow-aggregator-plugin/blob/master/demo/repo/Jenkinsfile\"><code>Jenkinsfile</code></a>, one for a library script\nit loaded\n(<a href=\"https://github.com/jenkinsci/workflow-aggregator-plugin/blob/de1d61b651220200ca6ae7a7d7c4da6a924d05d4/demo/repo/servers.groovy\"><code>servers.groovy</code></a>, introduced to help demonstrate this feature). You\ncan make edits to either or both. For example, the original demo allocates a\ntemporary web application with a random name like\n<code>9c89e9aa-6ca2-431c-a04a-6599e81827ac</code> for the duration of the functional tests.\nPerhaps you wished to prefix the application name with <code>tmp-</code> to make it obvious\nto anyone encountering the <a href=\"http://localhost:8081/\">Jetty index page</a> that these\nURLs are transient. So in the second text area, find the line</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>def id = UUID.randomUUID().toString()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>and change it to read</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>def id = \"tmp-${UUID.randomUUID()}\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>then click <strong>Run</strong>. In\n<a href=\"http://localhost:8080/job/cd/branch/master/2/console\">the new build’s log</a>\nyou will now see</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>Replayed #1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>and later something like</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>… test -Durl=http://localhost:8081/tmp-812725bb-74c6-41dc-859e-7d9896b938c3/ …</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>with the improved URL format. Like the result? You will want to make it\npermanent. So jump to the [second build’s index\npage](<a href=\"http://localhost:8080/job/cd/branch/master/2/\" class=\"bare\">http://localhost:8080/job/cd/branch/master/2/</a>) where you will see a note\nthat this build &gt; Replayed #1 (diff) If you\n<a href=\"http://localhost:8080/job/cd/branch/master/2/replay/diff\">click on <strong>diff</strong></a> you\nwill see:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-diff\" data-lang=\"diff\">--- old/Script1\n+++ new/Script1\n@@ -8,7 +8,7 @@\n }\n\n def runWithServer(body) {\n-    def id = UUID.randomUUID().toString()\n+    def id = \"tmp-${UUID.randomUUID()}\"\n     deploy id\n     try {\n         body.call id</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>so you can know exactly what you changed from the last-saved version. In fact if you replay #2 and change <code>tmp</code> to <code>temp</code> in the loaded script, in the diff view for #3 you will see the diff from the <em>first</em> build, the aggregate diff:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-diff\" data-lang=\"diff\">--- old/Script1\n+++ new/Script1\n@@ -8,7 +8,7 @@\n }\n\n def runWithServer(body) {\n-    def id = UUID.randomUUID().toString()\n+    def id = \"temp-${UUID.randomUUID()}\"\n     deploy id\n     try {\n         body.call id</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>At this point you could touch up the patch to refer to <code>servers.groovy</code>\n(<a href=\"https://issues.jenkins.io/browse/JENKINS-31838\">JENKINS-31838</a>), <code>git\napply</code> it to a clone of your repository, and commit. But why go to the trouble\nof editing Groovy in the Jenkins web UI and then manually copying changes back\nto your IDE, when you could stay in your preferred development environment from\nthe start?</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code>$ git clone git://localhost/repo\nCloning into 'repo'...\nremote: Counting objects: 23, done.\nremote: Compressing objects: 100% (12/12), done.\nremote: Total 23 (delta 1), reused 0 (delta 0)\nReceiving objects: 100% (23/23), done.\nResolving deltas: 100% (1/1), done.\nChecking connectivity... done.\n$ cd repo\n$ $EDITOR servers.groovy\n# make the same edit as previously described\n$ git diff\ndiff --git a/servers.groovy b/servers.groovy\nindex 562d92e..63ea8d6 100644\n--- a/servers.groovy\n+++ b/servers.groovy\n@@ -8,7 +8,7 @@ def undeploy(id) {\n }\n\n def runWithServer(body) {\n-    def id = UUID.randomUUID().toString()\n+    def id = \"tmp-${UUID.randomUUID()}\"\n     deploy id\n     try {\n         body.call id\n$ ssh -p 2222 -o StrictHostKeyChecking=no localhost replay-pipeline cd/master -s Script1 &lt; servers.groovy\nWarning: Permanently added '[localhost]:2222' (RSA) to the list of known hosts.\n# follow progress in Jenkins (see JENKINS-33438)\n$ git checkout -b webapp-naming\nM                                                                              servers.groovy\nSwitched to a new branch 'webapp-naming'\n$ git commit -a -m 'Adjusted transient webapp name.'\n[webapp-naming …] Adjusted transient webapp name.\n 1 file changed, 1 insertion(+), 1 deletion(-)\n$ git push origin webapp-naming\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 330 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nTo git://localhost/repo\n * [new branch]      webapp-naming -&gt; webapp-naming</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Using the <code>replay-pipeline</code> CLI command (in this example <a href=\"https://wiki.jenkins.io/display/JENKINS/Jenkins+SSH#JenkinsSSH-JenkinsCLIvsJenkinsSSH\">via\nSSH</a>)\nyou can prepare, test, and commit changes to your Pipeline script code without\ncopying anything to or from a browser. That is all for now. Enjoy!</p>\n</div>","id":"44aa3a43-715d-549b-b0d2-cc5c5bd94725","title":"Replay a Pipeline with script edits","date":"2016-04-14T00:00:00.000Z","slug":"/blog/2016/04/14/replay-with-pipeline/","authors":[]}},"pageContext":{"id":"44aa3a43-715d-549b-b0d2-cc5c5bd94725"}},
    "staticQueryHashes": ["1271460761","3649515864"]}