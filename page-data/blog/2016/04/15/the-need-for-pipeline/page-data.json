{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2016/04/15/the-need-for-pipeline/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This is a cross-post of\n<a href=\"https://www.cloudbees.com/blog/need-jenkins-pipeline\">an article</a> authored\nby <a href=\"https://github.com/vfarcic\">Viktor Farcic</a> on the\n<a href=\"https://www.cloudbees.com/blog/\">CloudBees blog</a>. Viktor is also the author\nof <a href=\"https://leanpub.com/the-devops-2-toolkit\">The DevOps 2.0 Toolkit</a>, which\nexplores Jenkins, the <a href=\"/doc/pipeline\">Pipeline plugin</a>, and the ecosystem\naround it in much more detail.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image right\"><img src=\"/images/angry-jenkins_128.png\" alt=\"angry jenkins 128\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Over the years, Jenkins has become the undisputed ruler among continuous\nintegration (CI), delivery and deployment (CD) tools. It, in a way, defined the\nCI/CD processes we use today. As a result of its leadership, many other products\nhave tried to overthrow it from its position. Among others, we got Bamboo and\nTeam City attempting to get a piece of the market. At the same time, new\nproducts emerged with a service approach (as opposed to on-premises). Some of\nthem are Travis, CircleCI and Shippable. Be that as it may, none managed to get\neven close to Jenkins' adoption. Today, depending on the source we use, Jenkins\nholds between 50-70% of the whole CI/CD tools market. The reason behind such a\nhigh percentage is its dedication to open source principles set from the very\nbeginning by <a href=\"https://github.com/kohsuke\">Kohsuke Kawaguchi</a>. Those same principles were the reason he forked\nJenkins from Hudson. The community behind the project, as well as commercial\nentities behind enterprise versions, are continuously improving the way it works\nand adding new features and capabilities. They are redefining not only the way\nJenkins behaves but also the CI/CD practices in a much broader sense. One of\nthose new features is the Jenkins <a href=\"/doc/pipeline\">Pipeline plugin</a>. Before we\ndive into it, let us take a step back and discuss the reasons that led us to\ninitiate the move away from Freestyle jobs and towards the Pipeline.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"the-need-for-change\"><a class=\"anchor\" href=\"#the-need-for-change\"></a>The Need for Change</h3>\n<div class=\"paragraph\">\n<p>Over time, Jenkins, like most other self-hosted CI/CD tools, tends to accumulate\na vast number of jobs. Having a lot of them causes quite an increase in\nmaintenance cost. Maintaining ten jobs is easy. It becomes a bit harder (but\nstill bearable) to manage a hundred. When the number of jobs increases to\nhundreds or even thousands, managing them becomes very tedious and time\ndemanding.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are not proficient with Jenkins (or other CI/CD tools) or you do not work\nfor a big project, you might think that hundreds of jobs is excessive. The truth\nis that such a number is reached over a relatively short period when teams\nare practicing continuous delivery or deployment. Let&#8217;s say that an average\nCD flow has the following set of tasks that should be run on each commit:\nbuilding, pre-deployment testing, deployment to a staging environment,\npost-deployment testing and deployment to production. That&#8217;s five groups of\ntasks that are often divided into, at least, five separate Jenkins jobs. In\nreality, there are often more than five jobs for a single CD flow, but let\nus keep it an optimistic estimate. How many different CD flows does a medium\nsized company have? With twenty, we are already reaching a three digits\nnumber. That&#8217;s quite a lot of  jobs to cope with even though the estimates\nwe used are too optimistic for all but the smallest entities.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now, imagine that we need to change all those jobs from, let&#8217;s say, Maven to\nGradle. We can choose to start modifying them through the Jenkins UI, but that\ntakes too much time. We can apply changes directly to Jenkins XML files that\nrepresent those jobs but that is too complicated and error prone. Besides,\nunless we write a script that will do the modifications for us, we would\nprobably not save much time with this approach. There are quite a few plugins\nthat can help us to apply changes to multiple jobs at once, but none of them is\ntruly successful (at least among free plugins). They all suffer from one\ndeficiency or another. The problem is not whether we have the tools to perform\nmassive changes to our jobs, but whether jobs are defined in a way that they can\nbe easily maintained.</p>\n</div>\n<div class=\"paragraph\">\n<p>Besides the sheer number of Jenkins jobs, another critical Jenkins' pain point\nis centralization. While having everything in one location provides a lot of\nbenefits (visibility, reporting and so on), it also poses quite a few\ndifficulties. Since the emergence of agile methodologies, there&#8217;s been a huge\nmovement towards self-sufficient teams. Instead of horizontal organization with\nseparate development, testing, infrastructure, operations and other groups, more\nand more companies are moving (or already moved) towards self-sufficient teams\norganized vertically. As a result, having one centralized place that defines all\nthe CD flows becomes a liability and often impedes us from splitting teams\nvertically based on projects. Members of a team should be able to collaborate\neffectively without too much reliance on other teams or departments. Translated\nto CD needs, that means that each team should be able to define the deployment\nflow of the application they are developing.</p>\n</div>\n<div class=\"paragraph\">\n<p>Finally, Jenkins, like many other tools, relies heavily on its UI. While that is\nwelcome and needed as a way to get a visual overview through dashboards and\nreports, it is suboptimal as a way to define the delivery and deployment flows.\nJenkins originated in an era when it was fashionable to use UIs for everything.\nIf you worked in this industry long enough you probably saw the swarm of tools\nthat rely completely on UIs, drag &amp; drop operations and a lot of forms that\nshould be filled. As a result, we got tools that produce artifacts that cannot\nbe easily stored in a code repository and are hard to reason with when anything\nbut simple operations are to be performed. Things changed since then, and now we\nknow that many things (deployment flow being one of them) are much easier to\nexpress through code. That can be observed when, for example, we try to define a\ncomplex flow through many Jenkins jobs. When deployment complexity requires\nconditional executions and some kind of a simple intelligence that depends on\nresults of different steps, chained jobs are truly complicated and often\nimpossible to create.</p>\n</div>\n<div class=\"paragraph\">\n<p>All things considered, the major pain points Jenkins had until recently are as\nfollows.</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Tendency to create a vast number of jobs</p>\n</li>\n<li>\n<p>Relatively hard and costly maintenance</p>\n</li>\n<li>\n<p>Centralization of everything</p>\n</li>\n<li>\n<p>Lack of powerful and easy ways to specify deployment flow through code</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This list is, by no means, unique to Jenkins. Other CI/CD tools have at least\none of the same problems or suffer from deficiencies that Jenkins solved a long\ntime ago. Since the focus of this article is Jenkins, I won&#8217;t dive into a\ncomparison between the CI/CD tools.</p>\n</div>\n<div class=\"paragraph\">\n<p>Luckily, all those, and many other deficiencies are now a thing of the past.\nWith the emergence of the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Pipeline+Plugin\">Pipeline\nplugin</a> and many others that were created on\ntop of it, Jenkins entered a new era and proved itself as a dominant player in\nthe CI/CD market. A whole new ecosystem was born, and the door was opened for\nvery exciting possibilities in the future.</p>\n</div>\n<div class=\"paragraph\">\n<p>Before we dive into the Jenkins Pipeline and the toolset that surrounds it, let\nus quickly go through the needs of a modern CD flow.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"continuous-delivery-or-deployment-flow-with-jenkins\"><a class=\"anchor\" href=\"#continuous-delivery-or-deployment-flow-with-jenkins\"></a>Continuous Delivery or Deployment Flow with Jenkins</h3>\n<div class=\"paragraph\">\n<p>When embarking on the CD journey for the first time, newcomers tend to think\nthat the tasks that constitute the flow are straightforward and linear. While\nthat might be true with small projects, in most cases things are much more\ncomplicated than that. You might think that the flow consists of building,\ntesting and deployment, and that the approach is linear and follows the\nall-or-nothing rule. Build invokes testing and testing invokes deployment. If\none of them fails, the developer gets a notification, fixes the problem and\ncommits the code that will initiate the repetition of the process.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><a class=\"image\" href=\"/images/post-images/need-for-pipeline/simple-cd-flow.png\"><img src=\"/images/post-images/need-for-pipeline/simple-cd-flow-small.png\" alt=\"simple cd flow small\" title=\"A simple and, in most cases, insufficient CD flow\"></a></span></p>\n</div>\n<div class=\"paragraph\">\n<p>In most instances, the process is far more complex. There are many tasks to run,\nand each of them might produce a failure. In some cases, a failure should only\nstop the process. However, more often than not, some additional logic should be\nexecuted as part of the after-failure cleanup. For example, what happens if\npost-deployment tests fail after a new release was deployed to production? We\ncannot just stop the flow and declare the build a failure. We might need to\nrevert to the previous release, rollback the proxy, de-register the service and\nso on. I won&#8217;t go into many examples of situations that require complex flow\nwith many tasks, conditionals that depend on results, parallel execution and so\non. Instead, I&#8217;ll share a diagram of one of the flows I worked on.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><a class=\"image\" href=\"/images/post-images/need-for-pipeline/complex-cd-flow.png\"><img src=\"/images/post-images/need-for-pipeline/complex-cd-flow-small.png\" alt=\"complex cd flow small\" title=\"A more compelx CD flow\"></a></span></p>\n</div>\n<div class=\"paragraph\">\n<p>Some tasks are run in one of the testing servers (yellow) while others are run\non the production cluster (blue). While any task might produce an error, in some\ncases such an outcome triggers a separate set of tasks. Some parts of the flow\nare not linear and depend on task results. Some tasks should be executed in\nparallel to improve the overall time required to run them. The list goes on and\non. Please note that this discussion is not about the best way to execute the\ndeployment flow but only a demonstration that the complexity can be, often, very\nhigh and cannot be solved by a simple chaining of Freestyle jobs. Even in cases\nwhen such chaining is possible, the maintenance cost tends to be very high.</p>\n</div>\n<div class=\"paragraph\">\n<p>One of the CD objectives we are unable to solve through chained jobs, or is\nproved to be difficult to implement, is conditional logic. In many cases, it is\nnot enough to simply chain jobs in a linear fashion. Often, we do not want only\nto create a job A that, once it&#8217;s finished running, executes job B, which, in\nturn, invokes job C. In real-world situations, things are more complicated than\nthat. We want to run some tasks (let&#8217;s call them job A), and, depending on the\nresult, invoke jobs B1 or B2, then run in parallel C1, C2 and C3, and, finally,\nexecute job D only when all C jobs are finished successfully. If this were a\nprogram or a script, we would have no problem accomplishing something like that,\nsince all modern programming languages allow us to employ conditional logic in a\nsimple and efficient way. Chained Jenkins jobs, created through its UI, pose\ndifficulties to create even a simple conditional logic. Truth be told, some\nplugins can help us with conditional logic. We have Conditional Build Steps,\nParameterised Trigger, Promotions and others. However, one of the major issues\nwith these plugins is configuration. It tends to be scattered across multiple\nlocations, hard to maintain and with little visibility.</p>\n</div>\n<div class=\"paragraph\">\n<p>Resource allocation needs a careful thought and is, often, more complicated than\na simple decision to run a job on a predefined agent. There are cases when agent\nshould be decided dynamically, workspace should be defined during runtime and\ncleanup depends on a result of some action.</p>\n</div>\n<div class=\"paragraph\">\n<p>While a continuous deployment process means that the whole pipeline ends with\ndeployment to production, many businesses are not ready for such a goal or have\nuse-cases when it is not appropriate. Any other process with a smaller scope, be\nit continuous delivery or continuous integration, often requires some human\ninteraction. A step in the pipeline might need someone&#8217;s confirmation, a failed\nprocess might require a manual input about reasons for the failure, and so on.\nThe requirement for human interaction should be an integral part of the pipeline\nand should allow us to pause, inspect and resume the flow. At least, until we\nreach the true continuous deployment stage.</p>\n</div>\n<div class=\"paragraph\">\n<p>The industry is, slowly, moving towards microservices architectures. However,\nthe transformation process might take a long time to be adopted, and even more\nto be implemented. Until then, we are stuck with monolithic applications that\noften require a long time for deployment pipelines to be fully executed. It is\nnot uncommon for them to run for a couple of hours, or even days. In such cases,\nfailure of the process, or the whole node the process is running on, should not\nmean that everything needs to be repeated. We should have a mechanism to\ncontinue the flow from defined checkpoints, thus avoiding costly repetition,\npotential delays and additional costs. That is not to say that long-running\ndeployment flows are appropriate or recommended. A well-designed CD process\nshould run within minutes, if not seconds. However, such a process requires not\nonly the flow to be designed well, but also the architecture of our applications\nto be changed. Since, in many cases, that does not seem to be a viable option,\nresumable points of the flow are a time saver.</p>\n</div>\n<div class=\"paragraph\">\n<p>All those needs, and many others, needed to be addressed in Jenkins if it was to\ncontinue being a dominant CI/CD tool. Fortunately, developers behind the project\nunderstood those needs and, as a result, we got the Jenkins Pipeline plugin. The\nfuture of Jenkins lies in a <strong>transition from Freestyle chained jobs to a single\npipeline expressed as code</strong>. Modern delivery flows cannot be expressed and easily\nmaintained through UI drag 'n drop features, nor through chained jobs. They can\nneither be defined through YAML (Yet Another Markup Language) definitions\nproposed by some of the newer tools (which I&#8217;m not going to name). <strong>We need to go\nback to code as a primary way to define not only the applications and services\nwe are developing but almost everything else</strong>. Many other types of tools adopted\nthat approach, and it was time for us to get that option for CI/CD processes as\nwell.</p>\n</div>\n</div>","id":"fa2f2d1b-91d5-5e2e-9783-72c7059face6","title":"The Need For Jenkins Pipeline","date":"2016-04-15T00:00:00.000Z","slug":"/blog/2016/04/15/the-need-for-pipeline/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":null},"blog":"http://unethicalblogger.com","github":"rtyler","html":"<div class=\"paragraph\">\n<p>R&#46; Tyler Croy has been part of the Jenkins project for the past seven years.\nWhile avoiding contributing any Java code, Tyler is involved in many of the\nother aspects of the project which keep it running, such as this website,\ninfrastructure, governance, etc.</p>\n</div>","id":"rtyler","irc":null,"linkedin":null,"name":"R. Tyler Croy","slug":"blog/author/rtyler","twitter":"agentdero"}]}},"pageContext":{"next":"/blog/2016/04/21/dsl-plugins/","previous":"/blog/2016/04/14/replay-with-pipeline/","id":"fa2f2d1b-91d5-5e2e-9783-72c7059face6"}},
    "staticQueryHashes": ["1271460761","3649515864"]}