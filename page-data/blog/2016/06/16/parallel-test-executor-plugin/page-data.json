{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2016/06/16/parallel-test-executor-plugin/",
    "result": {"data":{"blog":{"html":"<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\nThis is a guest post by <a href=\"https://github.com/bitwiseman\">Liam Newman</a>,\nTechnical Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>In this blog post, I’ll show you how to speed up your pipeline by using the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Parallel+Test+Executor+Plugin\">Parallel Test Executor Plugin</a>.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"so-much-to-do-so-little-time\"><a class=\"anchor\" href=\"#so-much-to-do-so-little-time\"></a>So much to do, so little time&#8230;&#8203;</h3>\n<div class=\"paragraph\">\n<p>In my career, I&#8217;ve helped many teams move to continuous integration and delivery. One problem\nwe always encounter is how to run all the tests needed to ensure high-quality\nchanges while still keeping pipeline times reasonable and changes flowing\nsmoothly. More tests mean greater confidence, but also longer wait times.\nBuild systems may or may not support running tests in parallel, but they still only use one\nmachine even while other lab machines sit idle. In these cases, parallelizing\ntest execution across multiple machines is a great way to speed up pipelines.\nThe Parallel Test Executor plugin lets us leverage Jenkins do just that with no\ndisruption to the rest of the build system.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"serial-test-execution\"><a class=\"anchor\" href=\"#serial-test-execution\"></a>Serial Test Execution</h3>\n<div class=\"paragraph\">\n<p>For this post, I’ll be running a pipeline based on the\n<a href=\"https://github.com/jenkinsci/git-plugin\">Jenkins Git Plugin</a>. I&#8217;ve modified\nthe Jenkinsfile from that project to allow us to compare execution times to our\nlater changes, and I&#8217;ve truncated the \"mvn\" utility method since it remains\nunchanged.  You can find the original file\n<a href=\"https://github.com/jenkinsci/git-plugin/blob/7a31858e61d2ca2e752b0e4f1285bddcb7a75c4d/Jenkinsfile\">here</a>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">node {\n  stage 'Checkout'\n  checkout scm\n\n  stage 'Build'\n\n  /* Call the Maven build without tests. */\n  mvn \"clean install -DskipTests\"\n\n  stage 'Test'\n  runTests()\n\n  /* Save Results. */\n  stage 'Results'\n\n  /* Archive the build artifacts */\n  archive includes: 'target/*.hpi,target/*.jpi'\n}\n\nvoid runTests(def args) {\n  /* Call the Maven build with tests. */\n  mvn \"install -Dmaven.test.failure.ignore=true\"\n\n  /* Archive the test results */\n  junit '**/target/surefire-reports/TEST-*.xml'\n}\n\n/* Run Maven */\nvoid mvn(def args) { /* ... */ }</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<i class=\"fa icon-note\" title=\"Note\"></i>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This pipeline expects to be run from a <code>Jenkinsfile</code> in SCM.\nTo copy and paste it directly into a Jenkins Pipeline job, replace the <code>checkout scm</code> step with\n<code>git 'https://github.com/jenkinsci/git-plugin.git'</code>.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>This is a Maven project, so the Jenkinsfile is pretty simple.\nI’ve split the Maven build into separate “Build” and “Test”\nstages. Maven doesn’t support this split very well, it wants to run all\nthe steps of the lifecycle in order every time. So, I have to call Maven twice:\nfirst using the “skipTests” property to do only build steps in the first call,\nand then a second time with out that property to run tests.</p>\n</div>\n<div class=\"paragraph\">\n<p>On my quad-core machine, executing this pipeline takes about 13 minutes and 30\nseconds.  Of that time, it takes 13 minutes to run about 2.7 thousand tests in\nserial.</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2016-06-16/serial.png\" alt=\"Serial Test Pipeline\">\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"parallel-test-execution\"><a class=\"anchor\" href=\"#parallel-test-execution\"></a>Parallel Test Execution</h3>\n<div class=\"paragraph\">\n<p>This looks like an ideal project for parallel test execution: a short build\nfollowed by a large number of serially executed tests that consume the most of\nthe pipeline time. There are a number of things I could try to speed this up.\nFor example, I could modify test harness to look for ways to parallelize\nthe test execution on this single machine. Or I could try speed up the tests\nthemselves. Both of those can be time-consuming and both risk destabilizing the\ntests. I&#8217;d need to know more about the project to do it well.</p>\n</div>\n<div class=\"paragraph\">\n<p>I&#8217;ll avoid that risk by using Jenkins and the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Parallel+Test+Executor+Plugin\">Parallel Test Executor Plugin</a> to\nparallelize the tests across multiple nodes instead. This will isolate the tests\nfrom each other, while still giving us speed gains from parallel execution.</p>\n</div>\n<div class=\"paragraph\">\n<p>The plugin reads the list of tests from the results archived in the previous execution of this\njob and splits that list into a specified number of sublists. I can then use\nthose sublists to execute the tests in parallel, passing a different sublist to\neach node.</p>\n</div>\n<div class=\"paragraph\">\n<p>Let’s look at how this changes the pipeline:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">node { /* ...unchanged... */ }\n\nvoid runTests(def args) {\n  /* Request the test groupings.  Based on previous test results. */\n  /* see https://wiki.jenkins.io/display/JENKINS/Parallel+Test+Executor+Plugin and demo on github\n  /* Using arbitrary parallelism of 4 and \"generateInclusions\" feature added in v1.8. */\n  def splits = splitTests parallelism: [$class: 'CountDrivenParallelism', size: 4], generateInclusions: true\n\n  /* Create dictionary to hold set of parallel test executions. */\n  def testGroups = [:]\n\n  for (int i = 0; i &lt; splits.size(); i++) {\n    def split = splits[i]\n\n    /* Loop over each record in splits to prepare the testGroups that we'll run in parallel. */\n    /* Split records returned from splitTests contain { includes: boolean, list: List&lt;String&gt; }. */\n    /*     includes = whether list specifies tests to include (true) or tests to exclude (false). */\n    /*     list = list of tests for inclusion or exclusion. */\n    /* The list of inclusions is constructed based on results gathered from */\n    /* the previous successfully completed job. One additional record will exclude */\n    /* all known tests to run any tests not seen during the previous run.  */\n    testGroups[\"split-${i}\"] = {  // example, \"split3\"\n      node {\n        checkout scm\n\n        /* Clean each test node to start. */\n        mvn 'clean'\n\n        def mavenInstall = 'install -DMaven.test.failure.ignore=true'\n\n        /* Write includesFile or excludesFile for tests.  Split record provided by splitTests. */\n        /* Tell Maven to read the appropriate file. */\n        if (split.includes) {\n          writeFile file: \"target/parallel-test-includes-${i}.txt\", text: split.list.join(\"\\n\")\n          mavenInstall += \" -Dsurefire.includesFile=target/parallel-test-includes-${i}.txt\"\n        } else {\n          writeFile file: \"target/parallel-test-excludes-${i}.txt\", text: split.list.join(\"\\n\")\n          mavenInstall += \" -Dsurefire.excludesFile=target/parallel-test-excludes-${i}.txt\"\n        }\n\n        /* Call the Maven build with tests. */\n        mvn mavenInstall\n\n        /* Archive the test results */\n        junit '**/target/surefire-reports/TEST-*.xml'\n      }\n    }\n  }\n  parallel testGroups\n}\n\n/* Run Maven */\nvoid mvn(def args) { /* ... */ }</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>That’s it!  The change is significant but it is all encapsulated in this one\nmethod in the <code>Jenkinsfile</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"great-ish-success\"><a class=\"anchor\" href=\"#great-ish-success\"></a>Great (ish) Success!</h3>\n<div class=\"paragraph\">\n<p>Here&#8217;s the results for the new pipeline with parallel test execution:</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/2016-06-16/serial-vs-parallel.png\" alt=\"Pipeline Duration Comparison\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The tests ran almost twice as fast, without changes outside pipeline.  Great!</p>\n</div>\n<div class=\"paragraph\">\n<p>However, I used 4 test executors, so why am I not seeing a 4x? improvement.\nA quick review of the logs shows the problem: A small number of tests are taking up\nto 5 minutes each to complete! This is actually good news. It means that I\nshould be able to see further improvement in pipeline throughput just by refactoring\nthose few long running tests into smaller parts.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\"></a>Conclusion</h3>\n<div class=\"paragraph\">\n<p>While I would like to have seen closer to a 4x improvement to match to number\nof executors, 2x is still perfectly respectable. If I were working on a group of projects\nwith similar pipelines, I&#8217;d be completely comfortable reusing these same changes\non my other project and I&#8217;d expect to similar improvement without any disruption to\nother tools or processes.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"links\"><a class=\"anchor\" href=\"#links\"></a>Links</h3>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/Parallel+Test+Executor+Plugin\" class=\"bare\">https://wiki.jenkins.io/display/JENKINS/Parallel+Test+Executor+Plugin</a></p>\n</li>\n</ul>\n</div>\n</div>","id":"9d5b4fb7-1151-5470-985c-045b0dd79455","title":"Faster Pipelines with the Parallel Test Executor Plugin","date":"2016-06-16T00:00:00.000Z","slug":"/blog/2016/06/16/parallel-test-executor-plugin/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#382818","images":{"fallback":{"src":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/19e71/lnewman.jpg","srcSet":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/77b35/lnewman.jpg 32w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/d4a57/lnewman.jpg 64w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/19e71/lnewman.jpg 128w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/68974/lnewman.jpg 256w","sizes":"(min-width: 128px) 128px, 100vw"},"sources":[{"srcSet":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/ef6ff/lnewman.webp 32w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/8257c/lnewman.webp 64w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/6766a/lnewman.webp 128w,\n/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/22bfc/lnewman.webp 256w","type":"image/webp","sizes":"(min-width: 128px) 128px, 100vw"}]},"width":128,"height":128}},"publicURL":"/gatsby-jenkins-io/static/9717c5c33fe8f4903eec2f2b5a8d1532/lnewman.jpeg"},"blog":null,"github":"bitwiseman","html":"<div class=\"paragraph\">\n<p>Liam started his software career as a tester, which might explain why he&#8217;s such a fan of CI/CD and Pipeline as Code.\nHe has spent the majority of his software engineering career implementing Continuous Integration systems at companies big and small.\nHe is a Jenkins project contributor and an expert in Jenkins Pipeline, both Scripted and Declarative.\nLiam currently works as a Jenkins Evangelist at <a href=\"https://cloudbees.com\">CloudBees</a>.\nWhen not at work, he enjoys testing gravity by doing Aikido.</p>\n</div>","id":"lnewman","irc":null,"linkedin":null,"name":"Liam Newman","slug":"/blog/authors/lnewman","twitter":"bitwiseman"}]}},"pageContext":{"id":"9d5b4fb7-1151-5470-985c-045b0dd79455"}},
    "staticQueryHashes": ["1271460761","3649515864"]}