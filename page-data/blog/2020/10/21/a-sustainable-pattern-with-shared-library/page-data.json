{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/blog/2020/10/21/a-sustainable-pattern-with-shared-library/",
    "result": {"data":{"blog":{"html":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#context\">Context</a></li>\n<li><a href=\"#the-problems\">The Problems</a></li>\n<li><a href=\"#the-solution\">The Solution</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#shared-library\">Shared Library</a></li>\n<li><a href=\"#duplication\">Duplication</a></li>\n<li><a href=\"#documentation\">Documentation</a></li>\n<li><a href=\"#scalability\">Scalability</a></li>\n<li><a href=\"#installation-agnostic\">Installation Agnostic</a></li>\n<li><a href=\"#feature-toggling\">Feature Toggling</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>This post will describe how I use a <a href=\"/doc/book/pipeline/shared-libraries/\">shared library</a> in Jenkins. Typically when using multibranch pipeline.</p>\n</div>\n<div class=\"paragraph\">\n<p>If possible (if not forced to) I implement the pipelines without multibranch. I previously wrote about how I do that with my <a href=\"/blog/2019/12/14/generic-webhook-trigger-plugin/\">Generic Webhook Trigger Plugin in a previous post</a>. But this will be my second choice, If I am not allowed to remove the <code>Jenkinsfile</code>:s from the repositories entirely.</p>\n</div>\n<div class=\"sect1\">\n<h2 id=\"context\"><a class=\"anchor\" href=\"#context\"></a>Context</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Within an organization, you typically have a few different kinds of repositories. Each repository versioning one application. You may use different techniques for different kinds of applications. The <a href=\"https://github.com/jenkinsci\">Jenkins organization on GitHub</a> is an example with 2300 repositories.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-problems\"><a class=\"anchor\" href=\"#the-problems\"></a>The Problems</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Large <strong>Jenkinsfiles in every repository containing duplicated code</strong>. It seems common that the <code>Jenkinsfile</code>:s in every repository contains much more than just the things that are unique for that repository. The <a href=\"/doc/book/pipeline/shared-libraries/\">shared libraries</a> feature may not be used, or it is used but not with an optimal pattern.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Installation specific Jenkinsfile:s</strong> that only work with one specific Jenkins installation. Sometimes I see multiple <code>Jenkinsfile</code>:s, one for each purpose or Jenkins installation.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>No documentation</strong> and/or no natural place to write documentation.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Development is slow</strong>. Adding new features to repositories is a time consuming task. I want to be able to push features to 1000+ repositories without having to update their <code>Jenkinsfile</code>:s.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>No flexible way of doing feature toggling</strong>. When maintaining a large number of repositories it is sometimes nice to introduce a feature to a subset of those repositories. If that works well, the feature is introduced to all repositories.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"the-solution\"><a class=\"anchor\" href=\"#the-solution\"></a>The Solution</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>My solution is a pattern that is inspired by how the <a href=\"https://github.com/jenkinsci\">Jenkins organization on GitHub</a> does it with its <a href=\"https://github.com/jenkins-infra/pipeline-library/blob/master/vars/buildPlugin.groovy\">buildPlugin()</a>. But it is not exactly the same.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"shared-library\"><a class=\"anchor\" href=\"#shared-library\"></a>Shared Library</h3>\n<div class=\"paragraph\">\n<p>Here is how I organize my <a href=\"/doc/book/pipeline/shared-libraries/\">shared libraries</a>.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"jenkinsfile\"><a class=\"anchor\" href=\"#jenkinsfile\"></a>Jenkinsfile</h4>\n<div class=\"paragraph\">\n<p>I put this in the <code>Jenkinsfile</code>:s:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">buildRepo()</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"default-configuration\"><a class=\"anchor\" href=\"#default-configuration\"></a>Default Configuration</h4>\n<div class=\"paragraph\">\n<p>I provide a default configuration that any repository will get, if no other configuration is given in <code>buildRepo()</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>I create a <code>vars/getConfig.groovy</code> with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">def call(givenConfig = [:]) {\n  def defaultConfig = [\n    /**\n      * The Jenkins node, or label, that will be allocated for this build.\n      */\n    \"jenkinsNode\": \"BUILD\",\n    /**\n      * All config specific to NPM repo type.\n      */\n    \"npm\": [\n      /**\n        * Whether or not to run Cypress tests, if there are any.\n        */\n      \"cypress\": true\n    ],\n    \"maven\": [\n      /**\n        * Whether or not to run integration tests, if there are any.\n        */\n      \"integTest\": true\n    ]\n  ]\n  // https://e.printstacktrace.blog/how-to-merge-two-maps-in-groovy/\n  def effectiveConfig merge(defaultConfig, givenConfig)\n  println \"Configuration is documented here: https://whereverYouHos/getConfig.groovy\"\n  println \"Default config: \" + defaultConfig\n  println \"Given config: \" + givenConfig\n  println \"Effective config: \" + effectiveConfig\n  return effectiveConfig\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"build-plan\"><a class=\"anchor\" href=\"#build-plan\"></a>Build Plan</h4>\n<div class=\"paragraph\">\n<p>I construct a build plan as early as possible. Taking decisions on what will be done in this build. So that the rest of the code becomes more streamlined.</p>\n</div>\n<div class=\"paragraph\">\n<p>I try to rely as much as possible on conventions. I may provide configuration that lets users turn off features, but they are otherwise turned on if they are detected.</p>\n</div>\n<div class=\"paragraph\">\n<p>I create a <code>vars/getBuildPlan.groovy</code> with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">def call(effectiveConfig = [:]) {\n  def derivedBuildPlan = [\n    \"repoType\": \"NOT DETECTED\"\n    \"npm\": [],\n    \"maven\": []\n  ]\n\n  node {\n    deleteDir()\n    checkout([$class: 'GitSCM',\n      branches: [[name: '*/branchName']],\n      extensions: [\n          [$class: 'SparseCheckoutPaths',\n            sparseCheckoutPaths:\n            [[$class:'SparseCheckoutPath', path:'package.json,pom.xml']]\n          ]\n      ],\n      userRemoteConfigs: [[credentialsId: 'someID',\n      url: 'git@link.git']]\n    ])\n\n    if (fileExists('package.json')) {\n      def packageJSON = readJSON file: 'package.json'\n      derivedBuildPlan.repoType = \"NPM\"\n      derivedBuildPlan.npm.cypress = effectiveConfig.npm.cypress &amp;&amp; packageJSON.devDependencies.cypress\n      derivedBuildPlan.npm.eslint = packageJSON.devDependencies.eslint\n      derivedBuildPlan.npm.tslint = packageJSON.devDependencies.tslint\n    } else if (fileExists('pom.xml')) {\n      derivedBuildPlan.repoType = \"MAVEN\"\n      derivedBuildPlan.maven.integTest = effectiveConfig.maven.integTest &amp;&amp; fileExists('src/integtest')\n    } else {\n      throw RuntimeException('Unable to detect repoType')\n    }\n\n    println \"Build plan: \" + derivedBuildPlan\n    deleteDir()\n  }\n  return derivedBuildPlan\n}</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"public-api\"><a class=\"anchor\" href=\"#public-api\"></a>Public API</h4>\n<div class=\"paragraph\">\n<p>This is the public API, this is what I want the users of this library to actually invoke.</p>\n</div>\n<div class=\"paragraph\">\n<p>I implement a <code>buildRepo()</code> method that will use that default configuration. It can also be called with a subset of the default configuration to tweak it.</p>\n</div>\n<div class=\"paragraph\">\n<p>I create a <code>vars/buildRepo.groovy</code> with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">def call(givenConfig = [:]) {\n  def effectiveConfig = getConfig(givenConfig)\n  def buildPlan = getBuildPlan(effectiveConfig)\n\n  if (effectiveConfig.repoType == 'MAVEN')\n    buildRepoMaven(buildPlan);\n  } else if (effectiveConfig.repoType == 'NPM')\n    buildRepoNpm(buildPlan);\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>A user can get all the default behavior with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">buildRepo()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>A user can also choose not to run Cypress, even if it exists in the repository:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">buildRepo([\n  \"npm\": [\n    \"cypress\": false\n  ]\n])</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"supporting-methods\"><a class=\"anchor\" href=\"#supporting-methods\"></a>Supporting Methods</h4>\n<div class=\"paragraph\">\n<p>This is usually much more complex, but I put some code here just to have a complete implementation.</p>\n</div>\n<div class=\"paragraph\">\n<p>I create a <code>vars/buildRepoNpm.groovy</code> with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">def call(buildPlan = [:]) {\n  node(buildPlan.jenkinsNode) {\n    stage(\"Install\") {\n      sh \"npm install\"\n    }\n    stage(\"Build\") {\n      sh \"npm run build\"\n    }\n    if (buildPlan.npm.tslint) {\n      stage(\"TSlint\") {\n        sh \"npm run tslint\"\n      }\n    }\n    if (buildPlan.npm.eslint) {\n      stage(\"ESlint\") {\n        sh \"npm run eslint\"\n      }\n    }\n    if (buildPlan.npm.cypress) {\n      stage(\"Cypress\") {\n        sh \"npm run e2e:cypress\"\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>I create a <code>vars/buildRepoMaven.groovy</code> with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight nowrap\"><code class=\"language-groovy\" data-lang=\"groovy\">def call(buildPlan = [:]) {\n  node(buildPlan.jenkinsNode) {\n    if (buildPlan.maven.integTest) {\n      stage(\"Verify\") {\n        sh \"mvn verify\"\n      }\n    } else {\n      stage(\"Package\") {\n        sh \"mvn package\"\n      }\n    }\n  }\n}</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"duplication\"><a class=\"anchor\" href=\"#duplication\"></a>Duplication</h3>\n<div class=\"paragraph\">\n<p>The <code>Jenkinsfile</code>:s are kept extremely small. It is only when they, for some reason, diverge from the default config that they need to be changed.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"documentation\"><a class=\"anchor\" href=\"#documentation\"></a>Documentation</h3>\n<div class=\"paragraph\">\n<p>There is one single point where documentation is written, the <code>getConfig.groovy</code>-file. It can be referred to whenever someone asks for documentation.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"scalability\"><a class=\"anchor\" href=\"#scalability\"></a>Scalability</h3>\n<div class=\"paragraph\">\n<p>This is a highly scalable pattern. Both with regards to performance and maintainability in code.</p>\n</div>\n<div class=\"paragraph\">\n<p>It scales in performance because the <code>Jenkinsfile</code>:s can be used by any Jenkins installation. So that you can scale by adding several completely separate Jenkins installations, not only nodes.</p>\n</div>\n<div class=\"paragraph\">\n<p>It scales in code because it adds just a tiny <code>Jenkinsfile</code> to repositories. It relies on conventions instead, like the existence of attributes in <code>package.json</code> and location of integration tests in <code>src/integtest</code>.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"installation-agnostic\"><a class=\"anchor\" href=\"#installation-agnostic\"></a>Installation Agnostic</h3>\n<div class=\"paragraph\">\n<p>The <code>Jenkinsfile</code>:s does not point at any implementation of this API. It just invokes it and it is up to the Jenkins installation to implement it, with a <a href=\"/doc/book/pipeline/shared-libraries/\">shared libraries</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>It can even be used by something that is not Jenkins. Perhaps you decide to do something in a Docker container, you can still parse the <code>Jenkinsfile</code> with Groovy or (with some magic) with any language.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"feature-toggling\"><a class=\"anchor\" href=\"#feature-toggling\"></a>Feature Toggling</h3>\n<div class=\"paragraph\">\n<p>The <a href=\"/doc/book/pipeline/shared-libraries/\">shared library</a> can do feature toggling by:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Letting some feature be enabled by default for every repository with name starting with <code>x</code>.</p>\n</li>\n<li>\n<p>Or, adding some default config saying <code>\"feature-x-enabled\": false</code>, while some repos change their <code>Jenkinsfile</code>:s to <code>buildRepo([\"feature-x-enabled\": true])</code>.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Whenever the feature feels stable, it can be enabled for everyone by changing only the <a href=\"/doc/book/pipeline/shared-libraries/\">shared library</a>.</p>\n</div>\n</div>\n</div>\n</div>","id":"7c9b1586-7a87-5fd5-8543-1a27aa94a68f","title":"A sustainable pattern with shared library","date":"2020-10-21T00:00:00.000Z","slug":"/blog/2020/10/21/a-sustainable-pattern-with-shared-library/","links":{"discourse":""},"authors":[{"avatar":{"childImageSharp":null},"blog":"https://bjurr.com/","github":"tomasbjerre","html":"<div class=\"paragraph\">\n<p>Tomas Bjerre is an experienced fullstack software developer. Been working full time since 2010 after graduating with a masters degree in computer science from Lund University (Faculty of Engineering, LTH). Is currently working full time and maintaining a bunch of Jenkins plugins on his spare time.</p>\n</div>","id":"tomasbjerre","irc":null,"linkedin":"tomasbjerre","name":"Tomas Bjerre","slug":"/blog/author/tomasbjerre","twitter":null}]}},"pageContext":{"next":"/blog/2020/10/28/election-candidates/","previous":"/blog/2020/10/20/Cross-Industry-DevOps-3-Firms-Get-It-Right-with-Jenkins/","id":"7c9b1586-7a87-5fd5-8543-1a27aa94a68f"}},
    "staticQueryHashes": ["1271460761","3649515864"]}